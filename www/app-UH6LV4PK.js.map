{
  "version": 3,
  "sources": ["../front/node_modules/@webreflection/mapset/esm/index.js", "../front/node_modules/@webreflection/uparser/esm/index.js", "../front/node_modules/@webreflection/uwire/esm/index.js", "../front/node_modules/uarray/esm/index.js", "../front/node_modules/uhandlers/esm/index.js", "../front/node_modules/udomdiff/esm/index.js", "../front/node_modules/uhtml/esm/utils.js", "../front/node_modules/uhtml/esm/handlers.js", "../front/node_modules/uhtml/esm/rabbit.js", "../front/node_modules/uhtml/esm/index.js", "../front/src/i18n/translations.js", "../front/src/i18n/tr.js", "../front/src/app.js"],
  "sourcesContent": ["export class MapSet extends Map {\n  set(key, value) {\n    super.set(key, value);\n    return value;\n  }\n}\n\nexport class WeakMapSet extends WeakMap {\n  set(key, value) {\n    super.set(key, value);\n    return value;\n  }\n}\n", "/*! (c) Andrea Giammarchi - ISC */\nconst empty = /^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i;\nconst elements = /<([a-z]+[a-z0-9:._-]*)([^>]*?)(\\/?)>/g;\nconst attributes = /([^\\s\\\\>\"'=]+)\\s*=\\s*(['\"]?)\\x01/g;\nconst holes = /[\\x01\\x02]/g;\n\n// \\x01 Node.ELEMENT_NODE\n// \\x02 Node.ATTRIBUTE_NODE\n\n/**\n * Given a template, find holes as both nodes and attributes and\n * return a string with holes as either comment nodes or named attributes.\n * @param {string[]} template a template literal tag array\n * @param {string} prefix prefix to use per each comment/attribute\n * @param {boolean} svg enforces self-closing tags\n * @returns {string} X/HTML with prefixed comments or attributes\n */\nexport default (template, prefix, svg) => {\n  let i = 0;\n  return template\n          .join('\\x01')\n          .trim()\n          .replace(\n            elements,\n            (_, name, attrs, selfClosing) => {\n              let ml = name + attrs.replace(attributes, '\\x02=$2$1').trimEnd();\n              if (selfClosing.length)\n                ml += (svg || empty.test(name)) ? ' /' : ('></' + name);\n              return '<' + ml + '>';\n            }\n          )\n          .replace(\n            holes,\n            hole => hole === '\\x01' ?\n              ('<!--' + prefix + i++ + '-->') :\n              (prefix + i++)\n          );\n};\n", "const ELEMENT_NODE = 1;\nconst nodeType = 111;\n\nconst remove = ({firstChild, lastChild}) => {\n  const range = document.createRange();\n  range.setStartAfter(firstChild);\n  range.setEndAfter(lastChild);\n  range.deleteContents();\n  return firstChild;\n};\n\nexport const diffable = (node, operation) => node.nodeType === nodeType ?\n  ((1 / operation) < 0 ?\n    (operation ? remove(node) : node.lastChild) :\n    (operation ? node.valueOf() : node.firstChild)) :\n  node\n;\n\nexport const persistent = fragment => {\n  const {firstChild, lastChild} = fragment;\n  if (firstChild === lastChild)\n    return lastChild || fragment;\n  const {childNodes} = fragment;\n  const nodes = [...childNodes];\n  return {\n    ELEMENT_NODE,\n    nodeType,\n    firstChild,\n    lastChild,\n    valueOf() {\n      if (childNodes.length !== nodes.length)\n        fragment.append(...nodes);\n      return fragment;\n    }\n  };\n};\n", "const {isArray} = Array;\nconst {indexOf, slice} = [];\n\nexport {isArray, indexOf, slice};\n", "import {isArray} from 'uarray';\n\n// flag for foreign checks (slower path, fast by default)\nlet useForeign = false;\n\nexport class Foreign {\n  constructor(handler, value) {\n    useForeign = true;\n    this._ = (...args) => handler(...args, value);\n  }\n}\n\nexport const foreign = (handler, value) => new Foreign(handler, value);\n\nexport const aria = node => values => {\n  for (const key in values) {\n    const name = key === 'role' ? key : `aria-${key}`;\n    const value = values[key];\n    if (value == null)\n      node.removeAttribute(name);\n    else\n      node.setAttribute(name, value);\n  }\n};\n\nconst getValue = value => value == null ? value : value.valueOf();\n\nexport const attribute = (node, name) => {\n  let oldValue, orphan = true;\n  const attributeNode = document.createAttributeNS(null, name);\n  return newValue => {\n    const value = useForeign && (newValue instanceof Foreign) ?\n                  newValue._(node, name) : getValue(newValue);\n    if (oldValue !== value) {\n      if ((oldValue = value) == null) {\n        if (!orphan) {\n          node.removeAttributeNode(attributeNode);\n          orphan = true;\n        }\n      }\n      else {\n        attributeNode.value = value;\n        if (orphan) {\n          node.setAttributeNodeNS(attributeNode);\n          orphan = false;\n        }\n      }\n    }\n  };\n};\n\nexport const boolean = (node, key, oldValue) => newValue => {\n  const value = !!getValue(newValue);\n  if (oldValue !== value) {\n    // when IE won't be around anymore ...\n    // node.toggleAttribute(key, oldValue = !!value);\n    if ((oldValue = value))\n      node.setAttribute(key, '');\n    else\n      node.removeAttribute(key);\n  }\n};\n\nexport const data = ({dataset}) => values => {\n  for (const key in values) {\n    const value = values[key];\n    if (value == null)\n      delete dataset[key];\n    else\n      dataset[key] = value;\n  }\n};\n\nexport const event = (node, name) => {\n  let oldValue, lower, type = name.slice(2);\n  if (!(name in node) && (lower = name.toLowerCase()) in node)\n    type = lower.slice(2);\n  return newValue => {\n    const info = isArray(newValue) ? newValue : [newValue, false];\n    if (oldValue !== info[0]) {\n      if (oldValue)\n        node.removeEventListener(type, oldValue, info[1]);\n      if (oldValue = info[0])\n        node.addEventListener(type, oldValue, info[1]);\n    }\n  };\n};\n\nexport const ref = node => {\n  let oldValue;\n  return value => {\n    if (oldValue !== value) {\n      oldValue = value;\n      if (typeof value === 'function')\n        value(node);\n      else\n        value.current = node;\n    }\n  };\n};\n\nexport const setter = (node, key) => key === 'dataset' ?\n  data(node) :\n  value => {\n    node[key] = value;\n  };\n\nexport const text = node => {\n  let oldValue;\n  return newValue => {\n    const value = getValue(newValue);\n    if (oldValue != value) {\n      oldValue = value;\n      node.textContent = value == null ? '' : value;\n    }\n  };\n};\n", "/**\n * ISC License\n *\n * Copyright (c) 2020, Andrea Giammarchi, @WebReflection\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/**\n * @param {Node} parentNode The container where children live\n * @param {Node[]} a The list of current/live children\n * @param {Node[]} b The list of future children\n * @param {(entry: Node, action: number) => Node} get\n * The callback invoked per each entry related DOM operation.\n * @param {Node} [before] The optional node used as anchor to insert before.\n * @returns {Node[]} The same list of future children.\n */\nexport default (parentNode, a, b, get, before) => {\n  const bLength = b.length;\n  let aEnd = a.length;\n  let bEnd = bLength;\n  let aStart = 0;\n  let bStart = 0;\n  let map = null;\n  while (aStart < aEnd || bStart < bEnd) {\n    // append head, tail, or nodes in between: fast path\n    if (aEnd === aStart) {\n      // we could be in a situation where the rest of nodes that\n      // need to be added are not at the end, and in such case\n      // the node to `insertBefore`, if the index is more than 0\n      // must be retrieved, otherwise it's gonna be the first item.\n      const node = bEnd < bLength ?\n        (bStart ?\n          (get(b[bStart - 1], -0).nextSibling) :\n          get(b[bEnd - bStart], 0)) :\n        before;\n      while (bStart < bEnd)\n        parentNode.insertBefore(get(b[bStart++], 1), node);\n    }\n    // remove head or tail: fast path\n    else if (bEnd === bStart) {\n      while (aStart < aEnd) {\n        // remove the node only if it's unknown or not live\n        if (!map || !map.has(a[aStart]))\n          parentNode.removeChild(get(a[aStart], -1));\n        aStart++;\n      }\n    }\n    // same node: fast path\n    else if (a[aStart] === b[bStart]) {\n      aStart++;\n      bStart++;\n    }\n    // same tail: fast path\n    else if (a[aEnd - 1] === b[bEnd - 1]) {\n      aEnd--;\n      bEnd--;\n    }\n    // The once here single last swap \"fast path\" has been removed in v1.1.0\n    // https://github.com/WebReflection/udomdiff/blob/single-final-swap/esm/index.js#L69-L85\n    // reverse swap: also fast path\n    else if (\n      a[aStart] === b[bEnd - 1] &&\n      b[bStart] === a[aEnd - 1]\n    ) {\n      // this is a \"shrink\" operation that could happen in these cases:\n      // [1, 2, 3, 4, 5]\n      // [1, 4, 3, 2, 5]\n      // or asymmetric too\n      // [1, 2, 3, 4, 5]\n      // [1, 2, 3, 5, 6, 4]\n      const node = get(a[--aEnd], -1).nextSibling;\n      parentNode.insertBefore(\n        get(b[bStart++], 1),\n        get(a[aStart++], -1).nextSibling\n      );\n      parentNode.insertBefore(get(b[--bEnd], 1), node);\n      // mark the future index as identical (yeah, it's dirty, but cheap 👍)\n      // The main reason to do this, is that when a[aEnd] will be reached,\n      // the loop will likely be on the fast path, as identical to b[bEnd].\n      // In the best case scenario, the next loop will skip the tail,\n      // but in the worst one, this node will be considered as already\n      // processed, bailing out pretty quickly from the map index check\n      a[aEnd] = b[bEnd];\n    }\n    // map based fallback, \"slow\" path\n    else {\n      // the map requires an O(bEnd - bStart) operation once\n      // to store all future nodes indexes for later purposes.\n      // In the worst case scenario, this is a full O(N) cost,\n      // and such scenario happens at least when all nodes are different,\n      // but also if both first and last items of the lists are different\n      if (!map) {\n        map = new Map;\n        let i = bStart;\n        while (i < bEnd)\n          map.set(b[i], i++);\n      }\n      // if it's a future node, hence it needs some handling\n      if (map.has(a[aStart])) {\n        // grab the index of such node, 'cause it might have been processed\n        const index = map.get(a[aStart]);\n        // if it's not already processed, look on demand for the next LCS\n        if (bStart < index && index < bEnd) {\n          let i = aStart;\n          // counts the amount of nodes that are the same in the future\n          let sequence = 1;\n          while (++i < aEnd && i < bEnd && map.get(a[i]) === (index + sequence))\n            sequence++;\n          // effort decision here: if the sequence is longer than replaces\n          // needed to reach such sequence, which would brings again this loop\n          // to the fast path, prepend the difference before a sequence,\n          // and move only the future list index forward, so that aStart\n          // and bStart will be aligned again, hence on the fast path.\n          // An example considering aStart and bStart are both 0:\n          // a: [1, 2, 3, 4]\n          // b: [7, 1, 2, 3, 6]\n          // this would place 7 before 1 and, from that time on, 1, 2, and 3\n          // will be processed at zero cost\n          if (sequence > (index - bStart)) {\n            const node = get(a[aStart], 0);\n            while (bStart < index)\n              parentNode.insertBefore(get(b[bStart++], 1), node);\n          }\n          // if the effort wasn't good enough, fallback to a replace,\n          // moving both source and target indexes forward, hoping that some\n          // similar node will be found later on, to go back to the fast path\n          else {\n            parentNode.replaceChild(\n              get(b[bStart++], 1),\n              get(a[aStart++], -1)\n            );\n          }\n        }\n        // otherwise move the source forward, 'cause there's nothing to do\n        else\n          aStart++;\n      }\n      // this node has no meaning in the future list, so it's more than safe\n      // to remove it, and check the next live node out instead, meaning\n      // that only the live list index should be forwarded\n      else\n        parentNode.removeChild(get(a[aStart++], -1));\n    }\n  }\n  return b;\n};\n", "const {isArray, prototype} = Array;\nconst {indexOf} = prototype;\n\nexport {isArray, indexOf};\n\nconst {\n  createDocumentFragment,\n  createElement,\n  createElementNS,\n  createTextNode,\n  createTreeWalker,\n  importNode\n} = new Proxy({}, {\n  get: (_, method) => document[method].bind(document)\n});\n\nexport {createTextNode, createTreeWalker, importNode};\n\nconst createHTML = html => {\n  const template = createElement('template');\n  template.innerHTML = html;\n  return template.content;\n};\n\nlet xml;\nconst createSVG = svg => {\n  if (!xml) xml = createElementNS('http://www.w3.org/2000/svg', 'svg');\n  xml.innerHTML = svg;\n  const content = createDocumentFragment();\n  content.append(...xml.childNodes);\n  return content;\n};\n\nexport const createContent = (text, svg) => svg ?\n                              createSVG(text) : createHTML(text);\n", "import {diffable} from '@webreflection/uwire';\n\nimport {aria, attribute, boolean, event, ref, setter, text} from 'uhandlers';\nimport udomdiff from 'udomdiff';\n\nimport {isArray, createTextNode} from './utils.js';\n\n// from a generic path, retrieves the exact targeted node\nconst reducePath = ({childNodes}, i) => childNodes[i];\n\n// this helper avoid code bloat around handleAnything() callback\nconst diff = (comment, oldNodes, newNodes) => udomdiff(\n  comment.parentNode,\n  // TODO: there is a possible edge case where a node has been\n  //       removed manually, or it was a keyed one, attached\n  //       to a shared reference between renders.\n  //       In this case udomdiff might fail at removing such node\n  //       as its parent won't be the expected one.\n  //       The best way to avoid this issue is to filter oldNodes\n  //       in search of those not live, or not in the current parent\n  //       anymore, but this would require both a change to uwire,\n  //       exposing a parentNode from the firstChild, as example,\n  //       but also a filter per each diff that should exclude nodes\n  //       that are not in there, penalizing performance quite a lot.\n  //       As this has been also a potential issue with domdiff,\n  //       and both lighterhtml and hyperHTML might fail with this\n  //       very specific edge case, I might as well document this possible\n  //       \"diffing shenanigan\" and call it a day.\n  oldNodes,\n  newNodes,\n  diffable,\n  comment\n);\n\n// if an interpolation represents a comment, the whole\n// diffing will be related to such comment.\n// This helper is in charge of understanding how the new\n// content for such interpolation/hole should be updated\nconst handleAnything = comment => {\n  let oldValue, text, nodes = [];\n  const anyContent = newValue => {\n    switch (typeof newValue) {\n      // primitives are handled as text content\n      case 'string':\n      case 'number':\n      case 'boolean':\n        if (oldValue !== newValue) {\n          oldValue = newValue;\n          if (!text)\n            text = createTextNode('');\n          text.data = newValue;\n          nodes = diff(comment, nodes, [text]);\n        }\n        break;\n      // null, and undefined are used to cleanup previous content\n      case 'object':\n      case 'undefined':\n        if (newValue == null) {\n          if (oldValue != newValue) {\n            oldValue = newValue;\n            nodes = diff(comment, nodes, []);\n          }\n          break;\n        }\n        // arrays and nodes have a special treatment\n        if (isArray(newValue)) {\n          oldValue = newValue;\n          // arrays can be used to cleanup, if empty\n          if (newValue.length === 0)\n            nodes = diff(comment, nodes, []);\n          // or diffed, if these contains nodes or \"wires\"\n          else if (typeof newValue[0] === 'object')\n            nodes = diff(comment, nodes, newValue);\n          // in all other cases the content is stringified as is\n          else\n            anyContent(String(newValue));\n          break;\n        }\n        // if the new value is a DOM node, or a wire, and it's\n        // different from the one already live, then it's diffed.\n        // if the node is a fragment, it's appended once via its childNodes\n        // There is no `else` here, meaning if the content\n        // is not expected one, nothing happens, as easy as that.\n        if (oldValue !== newValue) {\n          if ('ELEMENT_NODE' in newValue) {\n            oldValue = newValue;\n            nodes = diff(\n              comment,\n              nodes,\n              newValue.nodeType === 11 ?\n                [...newValue.childNodes] :\n                [newValue]\n            );\n          }\n          else {\n            const value = newValue.valueOf();\n            if (value !== newValue)\n              anyContent(value);\n          }\n        }\n        break;\n      case 'function':\n        anyContent(newValue(comment));\n        break;\n    }\n  };\n  return anyContent;\n};\n\n// attributes can be:\n//  * ref=${...}      for hooks and other purposes\n//  * aria=${...}     for aria attributes\n//  * ?boolean=${...} for boolean attributes\n//  * .dataset=${...} for dataset related attributes\n//  * .setter=${...}  for Custom Elements setters or nodes with setters\n//                    such as buttons, details, options, select, etc\n//  * @event=${...}   to explicitly handle event listeners\n//  * onevent=${...}  to automatically handle event listeners\n//  * generic=${...}  to handle an attribute just like an attribute\nconst handleAttribute = (node, name/*, svg*/) => {\n  switch (name[0]) {\n    case '?': return boolean(node, name.slice(1), false);\n    case '.': return setter(node, name.slice(1));\n    case '@': return event(node, 'on' + name.slice(1));\n    case 'o': if (name[1] === 'n') return event(node, name);\n  }\n\n  switch (name) {\n    case 'ref': return ref(node);\n    case 'aria': return aria(node);\n  }\n\n  return attribute(node, name/*, svg*/);\n};\n\n// each mapped update carries the update type and its path\n// the type is either node, attribute, or text, while\n// the path is how to retrieve the related node to update.\n// In the attribute case, the attribute name is also carried along.\nexport function handlers(options) {\n  const {type, path} = options;\n  const node = path.reduceRight(reducePath, this);\n  return type === 'node' ?\n    handleAnything(node) :\n    (type === 'attr' ?\n      handleAttribute(node, options.name/*, options.svg*/) :\n      text(node));\n};\n", "import {WeakMapSet} from '@webreflection/mapset';\nimport instrument from '@webreflection/uparser';\nimport {persistent} from '@webreflection/uwire';\n\nimport {handlers} from './handlers.js';\nimport {isArray, indexOf, createContent, createTreeWalker, importNode} from './utils.js';\n\n// from a fragment container, create an array of indexes\n// related to its child nodes, so that it's possible\n// to retrieve later on exact node via reducePath\nconst createPath = node => {\n  const path = [];\n  let {parentNode} = node;\n  while (parentNode) {\n    path.push(indexOf.call(parentNode.childNodes, node));\n    node = parentNode;\n    ({parentNode} = node);\n  }\n  return path;\n};\n\n// the prefix is used to identify either comments, attributes, or nodes\n// that contain the related unique id. In the attribute cases\n// isµX=\"attribute-name\" will be used to map current X update to that\n// attribute name, while comments will be like <!--isµX-->, to map\n// the update to that specific comment node, hence its parent.\n// style and textarea will have <!--isµX--> text content, and are handled\n// directly through text-only updates.\nconst prefix = 'isµ';\n\n// Template Literals are unique per scope and static, meaning a template\n// should be parsed once, and once only, as it will always represent the same\n// content, within the exact same amount of updates each time.\n// This cache relates each template to its unique content and updates.\nconst cache = new WeakMapSet;\n\n// a RegExp that helps checking nodes that cannot contain comments\nconst textOnly = /^(?:textarea|script|style|title|plaintext|xmp)$/;\n\nexport const createCache = () => ({\n  stack: [],    // each template gets a stack for each interpolation \"hole\"\n\n  entry: null,  // each entry contains details, such as:\n                //  * the template that is representing\n                //  * the type of node it represents (html or svg)\n                //  * the content fragment with all nodes\n                //  * the list of updates per each node (template holes)\n                //  * the \"wired\" node or fragment that will get updates\n                // if the template or type are different from the previous one\n                // the entry gets re-created each time\n\n  wire: null    // each rendered node represent some wired content and\n                // this reference to the latest one. If different, the node\n                // will be cleaned up and the new \"wire\" will be appended\n});\n\n// the entry stored in the rendered node cache, and per each \"hole\"\nconst createEntry = (type, template) => {\n  const {content, updates} = mapUpdates(type, template);\n  return {type, template, content, updates, wire: null};\n};\n\n// a template is instrumented to be able to retrieve where updates are needed.\n// Each unique template becomes a fragment, cloned once per each other\n// operation based on the same template, i.e. data => html`<p>${data}</p>`\nconst mapTemplate = (type, template) => {\n  const svg = type === 'svg';\n  const text = instrument(template, prefix, svg);\n  const content = createContent(text, svg);\n  // once instrumented and reproduced as fragment, it's crawled\n  // to find out where each update is in the fragment tree\n  const tw = createTreeWalker(content, 1 | 128);\n  const nodes = [];\n  const length = template.length - 1;\n  let i = 0;\n  // updates are searched via unique names, linearly increased across the tree\n  // <div isµ0=\"attr\" isµ1=\"other\"><!--isµ2--><style><!--isµ3--</style></div>\n  let search = `${prefix}${i}`;\n  while (i < length) {\n    const node = tw.nextNode();\n    // if not all updates are bound but there's nothing else to crawl\n    // it means that there is something wrong with the template.\n    if (!node)\n      throw `bad template: ${text}`;\n    // if the current node is a comment, and it contains isµX\n    // it means the update should take care of any content\n    if (node.nodeType === 8) {\n      // The only comments to be considered are those\n      // which content is exactly the same as the searched one.\n      if (node.data === search) {\n        nodes.push({type: 'node', path: createPath(node)});\n        search = `${prefix}${++i}`;\n      }\n    }\n    else {\n      // if the node is not a comment, loop through all its attributes\n      // named isµX and relate attribute updates to this node and the\n      // attribute name, retrieved through node.getAttribute(\"isµX\")\n      // the isµX attribute will be removed as irrelevant for the layout\n      // let svg = -1;\n      while (node.hasAttribute(search)) {\n        nodes.push({\n          type: 'attr',\n          path: createPath(node),\n          name: node.getAttribute(search)\n        });\n        node.removeAttribute(search);\n        search = `${prefix}${++i}`;\n      }\n      // if the node was a style, textarea, or others, check its content\n      // and if it is <!--isµX--> then update tex-only this node\n      if (\n        textOnly.test(node.localName) &&\n        node.textContent.trim() === `<!--${search}-->`\n      ){\n        node.textContent = '';\n        nodes.push({type: 'text', path: createPath(node)});\n        search = `${prefix}${++i}`;\n      }\n    }\n  }\n  // once all nodes to update, or their attributes, are known, the content\n  // will be cloned in the future to represent the template, and all updates\n  // related to such content retrieved right away without needing to re-crawl\n  // the exact same template, and its content, more than once.\n  return {content, nodes};\n};\n\n// if a template is unknown, perform the previous mapping, otherwise grab\n// its details such as the fragment with all nodes, and updates info.\nconst mapUpdates = (type, template) => {\n  const {content, nodes} = (\n    cache.get(template) ||\n    cache.set(template, mapTemplate(type, template))\n  );\n  // clone deeply the fragment\n  const fragment = importNode(content, true);\n  // and relate an update handler per each node that needs one\n  const updates = nodes.map(handlers, fragment);\n  // return the fragment and all updates to use within its nodes\n  return {content: fragment, updates};\n};\n\n// as html and svg can be nested calls, but no parent node is known\n// until rendered somewhere, the unroll operation is needed to\n// discover what to do with each interpolation, which will result\n// into an update operation.\nexport const unroll = (info, {type, template, values}) => {\n  // interpolations can contain holes and arrays, so these need\n  // to be recursively discovered\n  const length = unrollValues(info, values);\n  let {entry} = info;\n  // if the cache entry is either null or different from the template\n  // and the type this unroll should resolve, create a new entry\n  // assigning a new content fragment and the list of updates.\n  if (!entry || (entry.template !== template || entry.type !== type))\n    info.entry = (entry = createEntry(type, template));\n  const {content, updates, wire} = entry;\n  // even if the fragment and its nodes is not live yet,\n  // it is already possible to update via interpolations values.\n  for (let i = 0; i < length; i++)\n    updates[i](values[i]);\n  // if the entry was new, or representing a different template or type,\n  // create a new persistent entity to use during diffing.\n  // This is simply a DOM node, when the template has a single container,\n  // as in `<p></p>`, or a \"wire\" in `<p></p><p></p>` and similar cases.\n  return wire || (entry.wire = persistent(content));\n};\n\n// the stack retains, per each interpolation value, the cache\n// related to each interpolation value, or null, if the render\n// was conditional and the value is not special (Array or Hole)\nconst unrollValues = ({stack}, values) => {\n  const {length} = values;\n  for (let i = 0; i < length; i++) {\n    const hole = values[i];\n    // each Hole gets unrolled and re-assigned as value\n    // so that domdiff will deal with a node/wire, not with a hole\n    if (hole instanceof Hole)\n      values[i] = unroll(\n        stack[i] || (stack[i] = createCache()),\n        hole\n      );\n    // arrays are recursively resolved so that each entry will contain\n    // also a DOM node or a wire, hence it can be diffed if/when needed\n    else if (isArray(hole))\n      unrollValues(stack[i] || (stack[i] = createCache()), hole);\n    // if the value is nothing special, the stack doesn't need to retain data\n    // this is useful also to cleanup previously retained data, if the value\n    // was a Hole, or an Array, but not anymore, i.e.:\n    // const update = content => html`<div>${content}</div>`;\n    // update(listOfItems); update(null); update(html`hole`)\n    else\n      stack[i] = null;\n  }\n  if (length < stack.length)\n    stack.splice(length);\n  return length;\n};\n\n/**\n * Holds all details wrappers needed to render the content further on.\n * @constructor\n * @param {string} type The hole type, either `html` or `svg`.\n * @param {string[]} template The template literals used to the define the content.\n * @param {Array} values Zero, one, or more interpolated values to render.\n */\nexport class Hole {\n  constructor(type, template, values) {\n    this.type = type;\n    this.template = template;\n    this.values = values;\n  }\n};\n", "import {MapSet, WeakMapSet} from '@webreflection/mapset';\n\nimport {Hole, createCache, unroll} from './rabbit.js';\n\n// both `html` and `svg` template literal tags are polluted\n// with a `for(ref[, id])` and a `node` tag too\nconst tag = type => {\n  // both `html` and `svg` tags have their own cache\n  const keyed = new WeakMapSet;\n  // keyed operations always re-use the same cache and unroll\n  // the template and its interpolations right away\n  const fixed = cache => (template, ...values) => unroll(\n    cache,\n    {type, template, values}\n  );\n  return Object.assign(\n    // non keyed operations are recognized as instance of Hole\n    // during the \"unroll\", recursively resolved and updated\n    (template, ...values) => new Hole(type, template, values),\n    {\n      // keyed operations need a reference object, usually the parent node\n      // which is showing keyed results, and optionally a unique id per each\n      // related node, handy with JSON results and mutable list of objects\n      // that usually carry a unique identifier\n      for(ref, id) {\n        const memo = keyed.get(ref) || keyed.set(ref, new MapSet);\n        return memo.get(id) || memo.set(id, fixed(createCache()));\n      },\n      // it is possible to create one-off content out of the box via node tag\n      // this might return the single created node, or a fragment with all\n      // nodes present at the root level and, of course, their child nodes\n      node: (template, ...values) => unroll(createCache(), new Hole(type, template, values)).valueOf()\n    }\n  );\n};\n\n// each rendered node gets its own cache\nconst cache = new WeakMapSet;\n\n// rendering means understanding what `html` or `svg` tags returned\n// and it relates a specific node to its own unique cache.\n// Each time the content to render changes, the node is cleaned up\n// and the new new content is appended, and if such content is a Hole\n// then it's \"unrolled\" to resolve all its inner nodes.\nconst render = (where, what) => {\n  const hole = typeof what === 'function' ? what() : what;\n  const info = cache.get(where) || cache.set(where, createCache());\n  const wire = hole instanceof Hole ? unroll(info, hole) : hole;\n  if (wire !== info.wire) {\n    info.wire = wire;\n    // valueOf() simply returns the node itself, but in case it was a \"wire\"\n    // it will eventually re-append all nodes to its fragment so that such\n    // fragment can be re-appended many times in a meaningful way\n    // (wires are basically persistent fragments facades with special behavior)\n    where.replaceChildren(wire.valueOf());\n  }\n  return where;\n};\n\nconst html = tag('html');\nconst svg = tag('svg');\n\nexport {Hole, render, html, svg};\n", "export var translations = {\r\n    \"$intro01\": {\r\n        \"en\": \"This application allows the verification of COVID certificates issued by EU Member States and also certificates issued by the UK Government with the same format as the EU Digital COVID Certificate\",\r\n        \"es\": \"Esta aplicación permite la verificación de certificados COVID emitidos por los Estados Miembro de la UE y también los certificados emitidos por el Reino Unido con el mismo formato que el Certificado COVID Digital de la UE\",\r\n        \"ca\": \"Aquesta aplicació permet la verificació dels certificats COVID emesos pels Estats membres de la UE i també els certificats emesos pel Regne Unit en el mateix format que el Certificat COVID digital de la UE\",\r\n        \"fr\": \"Cette application permet de vérifier les certificats COVID émis par les États membres de l'UE, ainsi que les certificats émis par le gouvernement britannique sous le même format que le certificat COVID numérique de l'UE.\",\r\n        \"de\": \"Diese Anwendung ermöglicht die Überprüfung von COVID-Zertifikaten, die von EU-Mitgliedstaaten ausgestellt wurden, sowie von Zertifikaten, die von der britischen Regierung ausgestellt wurden und dasselbe Format wie das digitale COVID-Zertifikat der EU haben.\",\r\n        \"it\": \"Questa applicazione consente di verificare i certificati COVID rilasciati dagli stati membri dell'UE nonché i certificati rilasciati dal governo del Regno Unito con lo stesso formato del certificato digitale COVID UE\"\r\n    },\r\n    \"EU Digital COVID Credential Verifier\": {\r\n        \"es\": \"Verificador de Credenciales COVID\",\r\n        \"ca\": \"Verificador de Credencials COVID\",\r\n        \"fr\": \"Outil de vérification numérique des justificatifs COVID de l'UE\",\r\n        \"de\": \"Digitale COVID-Anmeldeinformationsüberprüfung in der EU\",\r\n        \"it\": \"Strumento di verifica del certificato digitale COVID UE\"\r\n    },\r\n\r\n}", "// *******************************************************\n// Translation support. This module adds to the\n// global scope a translation function T()\n// *******************************************************\n\n// Use \"ca\" as default language unless set explicitly by the\n// user in the application.\nvar preferredLanguage = \"ca\"\n\n// Check if the user had set explicitly the language\nlet l = localStorage.getItem(\"preferredLanguage\")\nif (l) {preferredLanguage = l}\n\n// Set preferred language in global scope, for easy module access\nwindow.preferredLanguage = preferredLanguage\n\nimport {translations} from \"./translations.js\"\n\n// This function is used in runtime to get translated text\nfunction T(key) {\n    // Texts in the application are written in English\n    // If language is \"en\" we do not need to search\n    if ((window.preferredLanguage === \"en\") && (key.charAt(0) != \"$\")) { return key }\n\n    // Check if the entry text has some translation, otherwise return unmodified\n    let entry = translations[key]\n    if (entry === undefined) { return key }\n\n    // Check if we have the text translated to the current language\n    let translated = entry[window.preferredLanguage]\n    if (translated === undefined) { return key }\n    return translated\n}\n// Set the function in the global scope\nwindow.T = T\n", "// @ts-check\r\n\r\n// This is the starting point for the application\r\n// This module starts executing as soon as parsing of the HTML has finished\r\n// We will bootstrap the app and start the loading process for all components\r\n\r\n// For rendering the HTML in the pages\r\nimport { render, html, svg } from 'uhtml';\r\n\r\n// Translation support\r\nimport './i18n/tr.js'\r\n\r\n// The logo in the header\r\n// @ts-ignore\r\nimport logo_img from './img/logo.png'\r\n\r\n// The database operations\r\nimport { storage } from \"./components/db\"\r\nconst myerror = storage.myerror\r\nconst mylog = storage.mylog\r\n\r\n// Prepare for lazy-loading the pages composing the application.\r\n// Typically, the window.pageModules variable is set in the HTML page importing us, but\r\n// it could be overriden (manually) here. It has a structure like this:\r\n//\r\n// window.pageModules = {\r\n//     \"DisplayQR\": \"/pages/DisplayQR-PIO5OPZ6.js\",\r\n//     \"DisplayVC\": \"/pages/DisplayVC-7FJXVKLF.js\",\r\n//     \"LogsPage\": \"/pages/LogsPage-DHLVIEZ4.js\",\r\n//     \"MenuPage\": \"/pages/MenuPage-A455MOK2.js\",\r\n//     \"MicroWallet\": \"/pages/MicroWallet-FGPE6TBO.js\",\r\n//     \"SIOPSelectCredential\": \"/pages/SIOPSelectCredential-2XT6ESFD.js\",\r\n//     \"SWNotify\": \"/pages/SWNotify-GLIQS6YO.js\",\r\n//     \"ScanQrPage\": \"/pages/ScanQrPage-SMX7ETOS.js\",\r\n//     \"SelectCamera\": \"/pages/SelectCamera-PXJHLD5U.js\",\r\n// }\r\n  \r\n// @ts-ignore\r\nconst pageModulesMap = window.pageModules\r\n\r\n// Get the base path of the application in runtime\r\nconst parsedUrl  = new URL(import.meta.url)\r\nconst fullPath = parsedUrl.pathname\r\nconsole.log(\"Fullpath of app:\", fullPath)\r\nconst basePath = fullPath.substring(0, fullPath.lastIndexOf('/'))\r\nconsole.log(\"Base path:\", basePath)\r\n\r\n// Prepend the base path of the application to each page module name\r\n// We do it only if the base path contains more than a '/', which means we are running under a base path\r\n// and the actual JavaScript modules should be loaded under that path\r\nif (basePath.length > 1) {\r\n    for (const path in pageModulesMap) {\r\n        pageModulesMap[path] = basePath + pageModulesMap[path]\r\n    }\r\n}\r\n\r\n// *****************************************************\r\n// This is a micro-router with just-enough functionality\r\n//\r\n// Implements gotoPage(pageName, pageData) and goHome()\r\n// *****************************************************\r\n\r\n// The default home page where to start and when refreshing the app is set\r\n// in the HTML page importing us in the window.homePage variable.\r\n// @ts-ignore\r\nvar homePage = window.homePage\r\n// @ts-ignore\r\nvar myAppTitle = window.myAppTitle\r\nif (!homePage) {\r\n    throw \"No homePage was set.\"\r\n}\r\n\r\n// The name of the page when we try to go to a non-existent page\r\nvar name404 = \"Page404\"\r\n\r\n// This will hold all pages in a (\"pageName\", pageClass) structure, to facilitate page routing\r\nvar pageNameToClass = new Map()\r\n\r\n/**\r\n * Register a new page name, associated to a class instance\r\n * @param {string} pageName\r\n * @param {any} classInstance\r\n */\r\nfunction route(pageName, classInstance) {\r\n    // Just populate the map, replacing whatever was already there\r\n    pageNameToClass.set(pageName, classInstance)\r\n}\r\n\r\n// Set the default home page for the application\r\n/**\r\n * @param {any} page\r\n */\r\nfunction setHomePage(page) {\r\n    homePage = page\r\n}\r\n\r\nasync function goHome() {\r\n\r\n    if (homePage != undefined) {\r\n        await gotoPage(homePage, null);\r\n    }\r\n\r\n}\r\n\r\n// gotoPage transitions to the target page passing pageData object\r\n// It is up to the page to define the structure of pageData\r\n/**\r\n * @param {string} pageName\r\n * @param {any} pageData\r\n */\r\nasync function gotoPage(pageName, pageData) {\r\n    mylog(\"Inside gotoPage:\", pageName)\r\n\r\n    // Catch any exceptions and present an error page in case of error\r\n    try {\r\n\r\n        // We load dynamically the page if it is not yet loaded\r\n        var pageClass = pageNameToClass.get(pageName)\r\n        if (!pageClass) {\r\n\r\n            // Try to load dynamically the page.\r\n            await import(pageModulesMap[pageName])            \r\n\r\n            // If pageName still does not exist, go to the 404 error page\r\n            // passing the target page name as pageData\r\n            if (!pageNameToClass.get(pageName)) {\r\n                myerror(\"Target page does not exist: \", pageName);\r\n                pageData = pageName\r\n                pageName = name404\r\n            }\r\n\r\n        }\r\n\r\n        // Create a new state in the browser history, to support the back button in the browser.\r\n        window.history.pushState(\r\n            { pageName: pageName, pageData: pageData },\r\n            `${pageName}`\r\n        );\r\n\r\n        // Process the page transition\r\n        await processPageEntered(pageNameToClass, pageName, pageData, false);\r\n        \r\n    } catch (error) {\r\n\r\n        myerror(error)\r\n        // Show an error\r\n        await processPageEntered(pageNameToClass, \"ErrorPage\", {title: error.name, msg: error.message}, false);\r\n        \r\n    }\r\n\r\n}\r\n\r\n// Handle page transition\r\n/**\r\n * @param {Map<string, any>} pageNameToClass\r\n * @param {string} pageName\r\n * @param {any} pageData\r\n * @param {boolean} historyData\r\n */\r\nasync function processPageEntered(pageNameToClass, pageName, pageData, historyData) {\r\n\r\n    // Hide all pages of the application. Later we unhide the one we are entering\r\n    // We also tell all other pages to exit, so they can perform any cleanup\r\n    // We call all pages instead of just the active one, because it is more robust and performance does not suffer much\r\n    // @ts-ignore\r\n    for (let [name, classInstance] of pageNameToClass) {\r\n        // Hide the page\r\n        classInstance.domElem.style.display = \"none\"\r\n        // Call the page exit() method for all pages except the target page, so they can perform any cleanup\r\n        // Implementation of the exit() function is optional, so we check for its existence\r\n        if ((name !== pageName) && classInstance.exit) {\r\n            try {\r\n                await classInstance.exit()\r\n            } catch (error) {\r\n                // We just log the error and continue the loop\r\n                myerror(`error calling exit() on ${name}: ${error.name}`);\r\n            }            \r\n        }\r\n    }\r\n\r\n    let targetPage = pageNameToClass.get(pageName)\r\n\r\n    // If the target page is not a registered page, go to the Page404 page,\r\n    // passing the target page as pageData\r\n    if (targetPage === undefined) {\r\n        pageData = pageName\r\n        targetPage = pageNameToClass.get(name404)\r\n    }\r\n\r\n    // Reset scroll position to make sure the page is at the top\r\n    // Special treatment is done if we are using Ionic Framework\r\n    const content = document.querySelector('ion-content')\r\n    if (content) {\r\n        // @ts-ignore\r\n        content.scrollToTop(500)\r\n    } else {\r\n        window.scrollTo(0, 0);\r\n    }\r\n\r\n    // Invoke the page enter() function to enter the page\r\n    // This will allow the page to create dynamic content\r\n    if (targetPage.enter) {\r\n        await targetPage.enter(pageData, historyData);\r\n    } else {\r\n        // Static pages do not have to implement the enter() method.\r\n        // Dynamic pages control their visibility as they need.\r\n        // For static pages we make sure the target page is visible.\r\n        targetPage.style.display = \"block\"\r\n    }\r\n\r\n}\r\n\r\n// Listen for PopStateEvent (navigator Back or Forward buttons are clicked)\r\nwindow.addEventListener(\"popstate\", async function (event) {\r\n    // Ignore the event if state does not have data\r\n    var state = event.state;\r\n    if (state == null) {\r\n        return\r\n    }\r\n\r\n    console.log(event)\r\n\r\n    // Get the page name and data to send\r\n    var pageName = state.pageName;\r\n    var pageData = state.pageData;\r\n\r\n    // Process the page transition\r\n    try {\r\n        await processPageEntered(pageNameToClass, pageName, pageData, true);        \r\n    } catch (error) {\r\n        myerror(error)\r\n        // Show an error\r\n        await processPageEntered(pageNameToClass, \"ErrorPage\", {title: error.name, msg: error.message}, false);\r\n    }\r\n\r\n});\r\n\r\n\r\n// Get the version of the application and store in database\r\n\r\n/**\r\n * \r\n * @returns undefined\r\n */\r\nasync function getAndUpdateVersion() {\r\n    // @ts-ignore\r\n    // let version = import.meta.env.VITE_APP_VERSION\r\n    let version = \"1.1.2\"\r\n\r\n    // Store the version in global Window object and in local storage\r\n    // @ts-ignore\r\n    window.appVersion = version\r\n    window.localStorage.setItem(\"VERSION\", version)\r\n    console.log(\"Version:\", version)\r\n\r\n    return;\r\n}\r\n\r\n\r\n// When this event is fired the DOM is fully loaded and safe to manipulate\r\n// @ts-ignore\r\nwindow.addEventListener('DOMContentLoaded', async (event) => {\r\n    console.log(\"window.DOMContentLoaded event fired\")\r\n\r\n    // Get the version of the application asynchronously\r\n    getAndUpdateVersion()\r\n\r\n    // Go to the home page\r\n    await goHome()\r\n\r\n    // @ts-ignore\r\n    var preloadPages = window.preloadPages\r\n    console.log(\"preloadPages\", preloadPages.length)\r\n\r\n    if (preloadPages && preloadPages.length >= 0) {\r\n        for (let index = 0; index < preloadPages.length; index++) { \r\n            console.log(\"======>Preload\", preloadPages[index])\r\n            import(pageModulesMap[preloadPages[index]])\r\n        }\r\n    } else {\r\n        // Preload all the pages of the application in parallel\r\n        console.log(\"!!!!!!!!!!!!!!!!!!!!!!Preload ALL ppages\")\r\n        for (const path in pageModulesMap) {\r\n            import(pageModulesMap[path])\r\n        }\r\n    }\r\n\r\n});\r\n\r\n\r\nvar INSTALL_SERVICE_WORKER = true\r\n\r\n// This function is called on first load and when a refresh is triggered in any page\r\n// When called the DOM is fully loaded and safe to manipulate\r\n// @ts-ignore\r\nwindow.addEventListener('load', async (event) => {\r\n    console.log(\"window.load event fired\")\r\n\r\n    // Install Service Worker only when in Production\r\n    // @ts-ignore\r\n    if ( JR_IN_DEVELOPMENT ) {\r\n        console.log(\"In development\")\r\n        INSTALL_SERVICE_WORKER = false\r\n    } else {\r\n        console.log(\"In production\")\r\n    }\r\n\r\n    // Install service worker for off-line support\r\n    if (INSTALL_SERVICE_WORKER && (\"serviceWorker\" in navigator)) {\r\n        const { Workbox } = await import('workbox-window');\r\n\r\n        const wb = new Workbox(\"./sw.js\");\r\n\r\n        wb.addEventListener(\"message\", (event) => {\r\n            if (event.data.type === \"CACHE_UPDATED\") {\r\n                const { updatedURL } = event.data.payload;\r\n\r\n                console.log(`A newer version of ${updatedURL} is available!`);\r\n            }\r\n        });\r\n\r\n        wb.addEventListener(\"activated\", async (event) => {\r\n            // `event.isUpdate` will be true if another version of the service\r\n            // worker was controlling the page when this version was registered.\r\n            if (event.isUpdate) {\r\n                console.log(\"Service worker has been updated.\", event);\r\n                await performAppUpgrade(true)\r\n            } else {\r\n                console.log(\"Service worker has been installed for the first time.\", event);\r\n                await performAppUpgrade(false)\r\n            }\r\n        });\r\n\r\n        // @ts-ignore\r\n        wb.addEventListener(\"waiting\", (event) => {\r\n            console.log(\r\n                `A new service worker has installed, but it can't activate` +\r\n                `until all tabs running the current version have fully unloaded.`\r\n            );\r\n        });\r\n\r\n        // Register the service worker after event listeners have been added.\r\n        wb.register();\r\n\r\n        //    const swVersion = await wb.messageSW({ type: \"GET_VERSION\" });\r\n        //    console.log(\"Service Worker version:\", swVersion);\r\n\r\n    }\r\n\r\n});\r\n\r\n\r\n// This is called when a new version of the Service Worker has been activated.\r\n// This means that a new version of the application has been installed\r\n/**\r\n * @param {boolean} isUpdate\r\n */\r\nasync function performAppUpgrade(isUpdate) {\r\n    console.log(\"Performing Upgrade\");\r\n\r\n    // Notify the user and ask to refresh the application\r\n    gotoPage(\"SWNotify\", { isUpdate: isUpdate })\r\n\r\n}\r\n\r\n// *****************************************************\r\n// HeaderBar definition\r\n// *****************************************************\r\n\r\n// @ts-ignore\r\nfunction toggleMenu() {\r\n    let x = document.getElementById(\"dropMenu\")\r\n    if (x) {\r\n        x.classList.toggle(\"hidden\")\r\n    }\r\n}\r\nfunction hideMenu() {\r\n    let x = document.getElementById(\"dropMenu\")\r\n    if (x) {\r\n        x.classList.add(\"hidden\")\r\n    }\r\n}\r\n/**\r\n * @param {string} e\r\n */\r\nfunction T(e) {\r\n    // @ts-ignore\r\n    if (window.T) {\r\n        // @ts-ignore\r\n        return(window.T(e))\r\n    }\r\n    return (e)\r\n}\r\n\r\n// @ts-ignore\r\n/**\r\n * @param {undefined} [e]\r\n */\r\nfunction resetAndGoHome(e) {\r\n    HeaderBar()\r\n    goHome()\r\n}\r\n\r\n\r\n/**\r\n * @param {boolean} backButton - If true, a back button is shown in the header\r\n */\r\nfunction HeaderBar(backButton = true) {\r\n\r\n    var menuB = html`\r\n        <ion-buttons slot=\"end\">\r\n        </ion-buttons>\r\n    `\r\n    if (!backButton) {\r\n        menuB = html`\r\n        <ion-buttons slot=\"end\">\r\n            <ion-button @click=${()=> gotoPage(\"MenuPage\", \"\")}>\r\n                <ion-icon name=\"menu\"></ion-icon>\r\n            </ion-button>\r\n        </ion-buttons>`\r\n    }\r\n\r\n    if (backButton) {\r\n        return html`\r\n        <ion-toolbar color=\"primary\">\r\n        <ion-buttons slot=\"start\">\r\n            <ion-button @click=${()=> history.back()}>\r\n                <ion-icon slot=\"start\" name=\"chevron-back\"></ion-icon>\r\n                Back\r\n            </ion-button>\r\n        </ion-buttons>\r\n        <ion-title>${myAppTitle}</ion-title>\r\n        ${menuB}\r\n        </ion-toolbar>\r\n        `;\r\n    } else {\r\n        return html`\r\n        <ion-toolbar color=\"primary\">\r\n        <ion-title>${myAppTitle}</ion-title>\r\n        ${menuB}\r\n        </ion-toolbar>\r\n    `;\r\n\r\n    }    \r\n\r\n}\r\n\r\n\r\n/**\r\n * @param {string} title\r\n * @param {string} message\r\n */\r\nfunction ErrorPanel(title, message) {\r\n    let theHtml = html`\r\n\r\n    <ion-card>\r\n        <ion-card-header>\r\n            <ion-card-title>${title}</ion-card-title>\r\n        </ion-card-header>\r\n\r\n        <ion-card-content class=\"ion-padding-bottom\">\r\n            <div class=\"text-larger\">${message}</div>\r\n        </ion-card-content>\r\n\r\n        <div class=\"ion-margin-start ion-margin-bottom\">\r\n\r\n            <ion-button color=\"danger\" @click=${()=> cleanReload()}>\r\n                <ion-icon slot=\"start\" name=\"home\"></ion-icon>\r\n                ${T(\"Home\")}\r\n            </ion-button>\r\n\r\n        </div>\r\n    </ion-card>\r\n    `\r\n\r\n    return theHtml\r\n}\r\n\r\n\r\n\r\n// *****************************************************\r\n// AbstractPage is the superclass of all pages in the application\r\n// *****************************************************\r\n\r\nclass AbstractPage {\r\n    html;           // The uhtml html function, for subclasses\r\n    domElem;        // The DOM Element that holds the page\r\n    pageName;       // The name of the page for routing\r\n    headerBar = HeaderBar\r\n\r\n    /**\r\n     * @param {string} id - The name of the page to be registered. This will be used for page routing\r\n     */\r\n    constructor(id) {\r\n        if (!id) { throw \"A page name is needed\"}\r\n\r\n        // Set the 'html' and 'svg' tag function so subclasses do not have to import 'uhtml'\r\n        this.html = html\r\n        this.svg = svg\r\n\r\n        // Create a <div> tag to contain the page\r\n        this.domElem = document.createElement('page')\r\n\r\n        // Set the id and name of the page for routing\r\n        this.pageName = id\r\n        this.domElem.id = id\r\n\r\n        // Register the page in the router\r\n        route(this.pageName, this)\r\n\r\n        // The page starts hidden\r\n        this.domElem.style.display = \"none\"\r\n\r\n        // Insert into the DOM inside the <main> element and after pages registered before\r\n        var mainElem = document.querySelector('main')\r\n        if (mainElem) {\r\n            mainElem.appendChild(this.domElem)\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * @param {(() => import(\"uhtml\").Renderable) | import(\"uhtml\").Renderable} theHtml\r\n     * @param {boolean} [backButton=true] \r\n     */\r\n    render(theHtml, backButton = true) {\r\n        // This is called by subclasses to render its contents\r\n\r\n        // Hide the Splash Screen (just in case it was being displayed)\r\n        let elem = document.getElementById(\"SplashScreen\")\r\n        if (elem) {\r\n            elem.style.display = \"none\"\r\n        }    \r\n\r\n        // Mark the page as visible\r\n        this.domElem.style.display = \"block\"\r\n\r\n        // Redraw the header just in case the menu was active\r\n        // The caller can specify if the back button has to be displayed in the header\r\n        let header = document.getElementById('the_header')\r\n        if (header) {\r\n            render(header, HeaderBar(backButton))\r\n        }    \r\n\r\n        // Render the html of the page into the DOM element of this page\r\n        render(this.domElem, theHtml)\r\n    }\r\n\r\n    /**\r\n     * @param {string} title\r\n     * @param {string} message\r\n     */\r\n    showError(title, message) {\r\n        this.render(ErrorPanel(title, message))\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @param {string} pageName\r\n * @param {any} classDefinition\r\n */\r\nfunction register(pageName, classDefinition) {\r\n    // Just create an instance. The constructor will take care of everything else\r\n    new classDefinition(pageName)\r\n}\r\n\r\nfunction cleanReload() {\r\n    // Reload the application with a clean URL\r\n    //@ts-ignore\r\n    window.location = window.location.origin + window.location.pathname\r\n    return    \r\n}\r\n\r\nregister(\"Page404\", class extends AbstractPage {\r\n\r\n    /**\r\n     * @param {string} id\r\n     */\r\n    constructor(id) {\r\n        super(id)\r\n    }\r\n\r\n    /**\r\n     * @param {string} pageData\r\n     */\r\n    enter(pageData) {\r\n\r\n        this.showError(\"Page not found\", `The requested page does not exist: ${pageData}`)\r\n    }\r\n})\r\n\r\nregister(\"ErrorPage\", class extends AbstractPage {\r\n\r\n    /**\r\n     * @param {string} id\r\n     */\r\n    constructor(id) {\r\n        super(id)\r\n    }\r\n\r\n    /**\r\n     * @param {{title: string;msg: string;back:boolean}} pageData\r\n     */\r\n    enter(pageData) {\r\n        let html = this.html\r\n\r\n        // We expect pageData to be an object with two fields:\r\n        // - title: the string to be used for the title of the error page\r\n        // - msg: the string with the details of the error\r\n\r\n        // Provide a default title if the user did not set the title\r\n        let title = T(\"Error\")\r\n        if (pageData && pageData.title) {\r\n            title = T(pageData.title)\r\n        }\r\n\r\n        //Provide a defaul message if the user did not specify it\r\n        let msg = T(\"An error has happened.\")\r\n        if (pageData && pageData.msg) {\r\n            msg = T(pageData.msg)\r\n        }\r\n\r\n        // Display the title and message, with a button that reloads the whole application\r\n        let theHtml = html`\r\n\r\n        <ion-card>\r\n\r\n            <ion-card-header>\r\n                <ion-card-title>${title}</ion-card-title>\r\n            </ion-card-header>\r\n\r\n            <ion-card-content class=\"ion-padding-bottom\">\r\n                <div class=\"text-larger\">${msg}</div>\r\n                ${pageData && (pageData.back == true) ? null : html`<div>${T(\"Please click Accept to refresh the page.\")}</div>`}\r\n            </ion-card-content>\r\n\r\n            <div class=\"ion-margin-start ion-margin-bottom\">\r\n\r\n                ${pageData && (pageData.back == true) ? html`\r\n                <ion-button @click=${()=> history.back()}>\r\n                    <ion-icon slot=\"start\" name=\"chevron-back\"></ion-icon>${T(\"Back\")}\r\n                </ion-button>` : html`\r\n                <ion-button color=\"danger\" @click=${()=> cleanReload()}>${T(\"Accept\")}\r\n                </ion-button>`}\r\n\r\n            </div>\r\n        </ion-card>\r\n        `\r\n        this.render(theHtml)\r\n    }\r\n})\r\n\r\n\r\n/**\r\n * @param {string} input\r\n */\r\nfunction btoaUrl(input) {\r\n\r\n    // Encode using the standard Javascript function\r\n    let astr = btoa(input)\r\n\r\n    // Replace non-url compatible chars with base64 standard chars\r\n    astr = astr.replace(/\\+/g, '-').replace(/\\//g, '_');\r\n\r\n    return astr;\r\n}\r\n\r\n/**\r\n * @param {string} input\r\n */\r\nfunction atobUrl(input) {\r\n\r\n    // Replace non-url compatible chars with base64 standard chars\r\n    input = input.replace(/-/g, '+').replace(/_/g, '/');\r\n\r\n    // Decode using the standard Javascript function\r\n    let bstr = decodeURIComponent(escape(atob(input)));\r\n\r\n    return bstr;\r\n}\r\n\r\n\r\n// This module exports the `MHR` object into the global namespace, where we will add\r\n// the relevant functions that we want globally available to other modules.\r\n// This way they do not have to import us (and avoid circular references in some cases) and\r\n// we do not pollute the global namespace with our functions and variables\r\n// @ts-ignore\r\nwindow.MHR = {\r\n    mylog: storage.mylog,\r\n    storage: storage,\r\n    route: route,\r\n    goHome: goHome,\r\n    gotoPage: gotoPage,\r\n    processPageEntered: processPageEntered,\r\n    AbstractPage: AbstractPage,\r\n    register: register,\r\n    ErrorPanel: ErrorPanel,\r\n    cleanReload: cleanReload,\r\n    html: html,\r\n    render: render,\r\n    btoaUrl: btoaUrl,\r\n    atobUrl: atobUrl,\r\n    pageNameToClass: pageNameToClass\r\n}\r\n"],
  "mappings": "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",
  "names": ["prefix", "svg", "esm_default", "isArray", "indexOf", "html", "svg", "text", "esm_default", "text", "isArray", "indexOf", "svg", "text", "isArray", "cache", "ref", "pageNameToClass", "event", "T", "T", "html"]
}
