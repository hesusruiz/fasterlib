{
  "version": 3,
  "sources": ["../../front/src/components/camerainfo.js"],
  "sourcesContent": ["// **************************************\n// Functions supporting the camera\n// **************************************\n\n// Get the OS of the device\nexport function getPlatformOS() {\n    const userAgent = window.navigator.userAgent;\n    let os = null;\n\n    const isIOS = (/iPad|iPhone|iPod/.test(userAgent) ||\n        (/Mac|Mac OS|MacIntel/gi.test(userAgent) && (navigator.maxTouchPoints > 1 || \"ontouchend\" in document))) && !window.MSStream;\n\n    if (/Macintosh|Mac|Mac OS|MacIntel|MacPPC|Mac68K/gi.test(userAgent)) {\n        os = 'Mac OS';\n    } else if (isIOS) {\n        os = 'iOS';\n    } else if (/'Win32|Win64|Windows|Windows NT|WinCE/gi.test(userAgent)) {\n        os = 'Windows';\n    } else if (/Android/gi.test(userAgent)) {\n        os = 'Android';\n    } else if (/Linux/gi.test(userAgent)) {\n        os = 'Linux';\n    }\n\n    return os;\n}\nconsole.log(\"running on:\", getPlatformOS())\n\nexport async function getVideoDevices() {\n    // Returns an array of video devices or undefined if none\n\n    // Get the video devices\n    if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {\n        console.log(\"enumerateDevices() not supported.\");\n        return undefined;\n    }\n\n    let allDevices = await navigator.mediaDevices.enumerateDevices()\n    let videoDevices = allDevices.filter((device) => {\n        return device.kind === \"videoinput\";\n    });\n    console.log(videoDevices)\n    if (videoDevices.length == 0) {\n        return undefined;\n    }\n\n    // Check if they have labels. If they don't, it means we have to request permission from the user\n    let allLabelsEmpty = videoDevices.every((device) => { return device.label === \"\" })\n    if (!allLabelsEmpty) {\n        return videoDevices;\n    }\n\n    let stream;\n    try {\n        // Request a stream to force the system to ask the user\n        stream = await navigator.mediaDevices.getUserMedia({\n            video: true,\n            audio: false,\n        });\n        // Try again to get the devices with label and id information\n        allDevices = await navigator.mediaDevices.enumerateDevices()\n        videoDevices = allDevices.filter((device) => {\n            return device.kind === \"videoinput\";\n        });\n    }\n    catch {\n        // Ignored\n        console.log(\"Probably the user did not authorise request\")\n    } finally {\n        // Release resources if the previous call was successful\n        if (stream !== undefined) {\n            stream.getVideoTracks().forEach((track) => {\n                track.stop();\n            });\n        }\n    }\n    return videoDevices\n}\n\nexport async function getPreferredVideoDevice() {\n\n    // Prepare undefined response\n    let undefinedVideoDevice = {\n        defaultPreferredCamera: undefined,\n        videoDevices: []\n    }\n\n    // Get all video devices, front and back\n    let videoDevices = await getVideoDevices()\n    if (!videoDevices) {\n        return undefinedVideoDevice;\n    }\n\n    let defaultPreferredCamera;\n\n    // Select specific device only for Android devices\n    if (\"Android\" == getPlatformOS()) {\n        // The main recommended back camera is the last one in the list\n        defaultPreferredCamera = videoDevices[videoDevices.length - 1]\n    }\n\n    return {\n        defaultPreferredCamera: defaultPreferredCamera,\n        videoDevices: videoDevices\n    }\n\n}\n"],
  "mappings": ";AAKO,SAAS,gBAAgB;AAC5B,QAAM,YAAY,OAAO,UAAU;AACnC,MAAI,KAAK;AAET,QAAM,SAAS,mBAAmB,KAAK,SAAS,KAC3C,wBAAwB,KAAK,SAAS,MAAM,UAAU,iBAAiB,KAAK,gBAAgB,cAAe,CAAC,OAAO;AAExH,MAAI,gDAAgD,KAAK,SAAS,GAAG;AACjE,SAAK;AAAA,EACT,WAAW,OAAO;AACd,SAAK;AAAA,EACT,WAAW,0CAA0C,KAAK,SAAS,GAAG;AAClE,SAAK;AAAA,EACT,WAAW,YAAY,KAAK,SAAS,GAAG;AACpC,SAAK;AAAA,EACT,WAAW,UAAU,KAAK,SAAS,GAAG;AAClC,SAAK;AAAA,EACT;AAEA,SAAO;AACX;AACA,QAAQ,IAAI,eAAe,cAAc,CAAC;AAE1C,eAAsB,kBAAkB;AAIpC,MAAI,CAAC,UAAU,gBAAgB,CAAC,UAAU,aAAa,kBAAkB;AACrE,YAAQ,IAAI,mCAAmC;AAC/C,WAAO;AAAA,EACX;AAEA,MAAI,aAAa,MAAM,UAAU,aAAa,iBAAiB;AAC/D,MAAI,eAAe,WAAW,OAAO,CAAC,WAAW;AAC7C,WAAO,OAAO,SAAS;AAAA,EAC3B,CAAC;AACD,UAAQ,IAAI,YAAY;AACxB,MAAI,aAAa,UAAU,GAAG;AAC1B,WAAO;AAAA,EACX;AAGA,MAAI,iBAAiB,aAAa,MAAM,CAAC,WAAW;AAAE,WAAO,OAAO,UAAU;AAAA,EAAG,CAAC;AAClF,MAAI,CAAC,gBAAgB;AACjB,WAAO;AAAA,EACX;AAEA,MAAI;AACJ,MAAI;AAEA,aAAS,MAAM,UAAU,aAAa,aAAa;AAAA,MAC/C,OAAO;AAAA,MACP,OAAO;AAAA,IACX,CAAC;AAED,iBAAa,MAAM,UAAU,aAAa,iBAAiB;AAC3D,mBAAe,WAAW,OAAO,CAAC,WAAW;AACzC,aAAO,OAAO,SAAS;AAAA,IAC3B,CAAC;AAAA,EACL,QACM;AAEF,YAAQ,IAAI,6CAA6C;AAAA,EAC7D,UAAE;AAEE,QAAI,WAAW,QAAW;AACtB,aAAO,eAAe,EAAE,QAAQ,CAAC,UAAU;AACvC,cAAM,KAAK;AAAA,MACf,CAAC;AAAA,IACL;AAAA,EACJ;AACA,SAAO;AACX;AAEA,eAAsB,0BAA0B;AAG5C,MAAI,uBAAuB;AAAA,IACvB,wBAAwB;AAAA,IACxB,cAAc,CAAC;AAAA,EACnB;AAGA,MAAI,eAAe,MAAM,gBAAgB;AACzC,MAAI,CAAC,cAAc;AACf,WAAO;AAAA,EACX;AAEA,MAAI;AAGJ,MAAI,aAAa,cAAc,GAAG;AAE9B,6BAAyB,aAAa,aAAa,SAAS,CAAC;AAAA,EACjE;AAEA,SAAO;AAAA,IACH;AAAA,IACA;AAAA,EACJ;AAEJ;",
  "names": []
}
