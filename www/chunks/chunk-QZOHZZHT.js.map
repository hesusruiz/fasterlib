{
  "version": 3,
  "sources": ["../../front/src/log.js"],
  "sourcesContent": ["// **************************************************\n// Logging and error management\n// **************************************************\n\n// Logging level (if false, only log Errors)\nconst LOG_ALL = true\n\n// Basic rotating log. When buffer is full, new entry overwrites oldest one\nexport var log = {\n    MAX_LOG_ENTRIES: 100,\n    logItems: [],\n    next_item: 0,\n\n    mylog_entry(_level, _desc, _item) {\n    \n        // Create the object to store\n        var logItem = {\n            timestamp: Date.now(),\n            level: _level,\n            desc: _desc,\n            item: _item\n        }\n    \n        // Store the object\n    \n        // If the list is not yet full, append a new entry to the end\n        if (this.logItems.length < this.MAX_LOG_ENTRIES) {\n            this.logItems.push(logItem)\n            return;\n        }\n    \n        // The list is alredy full, overwrite the oldest one and keep track of it\n        this.logItems[this.next_item] = logItem\n        this.next_item = this.next_item + 1\n        if (this.next_item == this.MAX_LOG_ENTRIES) {\n            this.next_item = 0\n        }\n        return;\n    \n    },\n        \n    log(_desc, ...additional) {\n        if (LOG_ALL) {\n            console.log(_desc, ...additional)\n            this.mylog_entry(\"N\", _desc, ...additional)\n        }\n    },\n\n    \n    warn(_desc, ...additional) {\n        if (LOG_ALL) {\n            let msg = _desc\n            // Get the stack trace if available\n            try {\n                let e = new Warning(_desc)\n                msg = e.stack\n            } catch {}\n            console.warn(msg, ...additional)\n            this.mylog_entry(\"W\", msg, ...additional)\n        }\n    }, \n\n    error(_desc, ...additional) {\n        let msg = _desc\n        // Get the stack trace if available\n        try {\n            let e = new Error(_desc)\n            msg = e.stack\n        } catch {}\n    \n        console.error(msg, ...additional)\n        this.mylog_entry(\"E\", msg, ...additional)\n    },  \n\n    num_items() {\n        if (this.logItems.length < this.MAX_LOG_ENTRIES) { return this.logItems.length }\n        return this.MAX_LOG_ENTRIES\n    },\n\n    item(index) {\n        if (index >= this.num_items()) {\n            return undefined\n        }\n\n        if (this.logItems.length < this.MAX_LOG_ENTRIES) {\n            return this.logItems[index]\n        } else {\n            let real_index = (this.next_item + index) % this.MAX_LOG_ENTRIES\n            return this.logItems[real_index]\n        }\n    }\n        \n}\n"],
  "mappings": ";AAKA,IAAM,UAAU;AAGT,IAAI,MAAM;AAAA,EACb,iBAAiB;AAAA,EACjB,UAAU,CAAC;AAAA,EACX,WAAW;AAAA,EAEX,YAAY,QAAQ,OAAO,OAAO;AAG9B,QAAI,UAAU;AAAA,MACV,WAAW,KAAK,IAAI;AAAA,MACpB,OAAO;AAAA,MACP,MAAM;AAAA,MACN,MAAM;AAAA,IACV;AAKA,QAAI,KAAK,SAAS,SAAS,KAAK,iBAAiB;AAC7C,WAAK,SAAS,KAAK,OAAO;AAC1B;AAAA,IACJ;AAGA,SAAK,SAAS,KAAK,SAAS,IAAI;AAChC,SAAK,YAAY,KAAK,YAAY;AAClC,QAAI,KAAK,aAAa,KAAK,iBAAiB;AACxC,WAAK,YAAY;AAAA,IACrB;AACA;AAAA,EAEJ;AAAA,EAEA,IAAI,UAAU,YAAY;AACtB,QAAI,SAAS;AACT,cAAQ,IAAI,OAAO,GAAG,UAAU;AAChC,WAAK,YAAY,KAAK,OAAO,GAAG,UAAU;AAAA,IAC9C;AAAA,EACJ;AAAA,EAGA,KAAK,UAAU,YAAY;AACvB,QAAI,SAAS;AACT,UAAI,MAAM;AAEV,UAAI;AACA,YAAI,IAAI,IAAI,QAAQ,KAAK;AACzB,cAAM,EAAE;AAAA,MACZ,QAAQ;AAAA,MAAC;AACT,cAAQ,KAAK,KAAK,GAAG,UAAU;AAC/B,WAAK,YAAY,KAAK,KAAK,GAAG,UAAU;AAAA,IAC5C;AAAA,EACJ;AAAA,EAEA,MAAM,UAAU,YAAY;AACxB,QAAI,MAAM;AAEV,QAAI;AACA,UAAI,IAAI,IAAI,MAAM,KAAK;AACvB,YAAM,EAAE;AAAA,IACZ,QAAQ;AAAA,IAAC;AAET,YAAQ,MAAM,KAAK,GAAG,UAAU;AAChC,SAAK,YAAY,KAAK,KAAK,GAAG,UAAU;AAAA,EAC5C;AAAA,EAEA,YAAY;AACR,QAAI,KAAK,SAAS,SAAS,KAAK,iBAAiB;AAAE,aAAO,KAAK,SAAS;AAAA,IAAO;AAC/E,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,KAAK,OAAO;AACR,QAAI,SAAS,KAAK,UAAU,GAAG;AAC3B,aAAO;AAAA,IACX;AAEA,QAAI,KAAK,SAAS,SAAS,KAAK,iBAAiB;AAC7C,aAAO,KAAK,SAAS,KAAK;AAAA,IAC9B,OAAO;AACH,UAAI,cAAc,KAAK,YAAY,SAAS,KAAK;AACjD,aAAO,KAAK,SAAS,UAAU;AAAA,IACnC;AAAA,EACJ;AAEJ;",
  "names": []
}
