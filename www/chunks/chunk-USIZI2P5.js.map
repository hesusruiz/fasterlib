{
  "version": 3,
  "sources": ["../../front/src/components/jwt.js"],
  "sourcesContent": ["let log = window.MHR.log\n\n/**\n * decodeJWT decodes the JWT without checking the signature.\n * But we will perform some important validations like expiration\n * @param {string}  jwt - The encoded JWT as a string with the three components separated by a dot.\n * @returns {{error: boolean, header: JSONObject, body: JSONObject, signature: string}} \n */\nexport function decodeJWT(jwt) {\n    // We will decode the JWT without checking the signature\n    // But we will perform some important validations like expiration\n\n    // This is the object that will be returned\n    let decoded = {\n        error: false,\n        header: undefined,\n        body: undefined,\n        signature: undefined\n    }\n\n    let components = \"\"\n\n    // Check that jwt is a string\n    if(typeof jwt === \"string\" || jwt instanceof String){\n        // Split the input in three components using the dots \".\" as separator\n        components = jwt.split(\".\");\n    } else {\n        decoded.error = \"Format error. Encoded credential is not a string\"\n        log.error(decoded.error)\n        return decoded;\n    }    \n\n    if (components.length != 3) {\n        decoded.error = \"Malformed JWT, not enough components: \" + components.length\n        log.error(decoded.error);\n        return decoded;\n    }\n\n    // Decode the header and the body into JSON objects\n    try {\n        decoded.header = JSON.parse(atobUrl(components[0]))\n        decoded.body = JSON.parse(atobUrl(components[1]))\n        decoded.signature = components[2]\n    } catch (error) {\n        decoded.error = \"Error parsing header or body\"\n        log.error(decoded.error)\n        return decoded;        \n    }\n\n    // Perform some consistency checks\n    if (!decoded.header) {\n        decoded.error = \"Field does not exist in JWT (header)\"\n        log.error(decoded.error)\n        return decoded;\n    }\n\n    return decoded;\n\n}\n\nfunction btoaUrl(input) {\n\n    // Encode using the standard Javascript function\n    let astr = btoa(input)\n\n    // Replace non-url compatible chars with base64 standard chars\n    astr = astr.replace(/\\+/g, '-').replace(/\\//g, '_');\n\n    return astr;\n}\n\nfunction atobUrl(input) {\n\n    // Replace non-url compatible chars with base64 standard chars\n    input = input.replace(/-/g, '+').replace(/_/g, '/');\n\n    // Decode using the standard Javascript function\n    let bstr = decodeURIComponent(escape(atob(input)));\n\n    return bstr;\n}\n"],
  "mappings": ";AAAA,IAAI,MAAM,OAAO,IAAI;AAQd,SAAS,UAAU,KAAK;AAK3B,MAAI,UAAU;AAAA,IACV,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,MAAM;AAAA,IACN,WAAW;AAAA,EACf;AAEA,MAAI,aAAa;AAGjB,MAAG,OAAO,QAAQ,YAAY,eAAe,QAAO;AAEhD,iBAAa,IAAI,MAAM,GAAG;AAAA,EAC9B,OAAO;AACH,YAAQ,QAAQ;AAChB,QAAI,MAAM,QAAQ,KAAK;AACvB,WAAO;AAAA,EACX;AAEA,MAAI,WAAW,UAAU,GAAG;AACxB,YAAQ,QAAQ,2CAA2C,WAAW;AACtE,QAAI,MAAM,QAAQ,KAAK;AACvB,WAAO;AAAA,EACX;AAGA,MAAI;AACA,YAAQ,SAAS,KAAK,MAAM,QAAQ,WAAW,CAAC,CAAC,CAAC;AAClD,YAAQ,OAAO,KAAK,MAAM,QAAQ,WAAW,CAAC,CAAC,CAAC;AAChD,YAAQ,YAAY,WAAW,CAAC;AAAA,EACpC,SAAS,OAAO;AACZ,YAAQ,QAAQ;AAChB,QAAI,MAAM,QAAQ,KAAK;AACvB,WAAO;AAAA,EACX;AAGA,MAAI,CAAC,QAAQ,QAAQ;AACjB,YAAQ,QAAQ;AAChB,QAAI,MAAM,QAAQ,KAAK;AACvB,WAAO;AAAA,EACX;AAEA,SAAO;AAEX;AAaA,SAAS,QAAQ,OAAO;AAGpB,UAAQ,MAAM,QAAQ,MAAM,GAAG,EAAE,QAAQ,MAAM,GAAG;AAGlD,MAAI,OAAO,mBAAmB,OAAO,KAAK,KAAK,CAAC,CAAC;AAEjD,SAAO;AACX;",
  "names": []
}
