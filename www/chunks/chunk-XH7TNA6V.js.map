{
  "version": 3,
  "sources": ["../../front/src/src/ClientResponseError.ts", "../../front/src/src/stores/utils/cookie.ts", "../../front/src/src/stores/utils/jwt.ts", "../../front/src/src/stores/BaseAuthStore.ts", "../../front/src/src/stores/LocalAuthStore.ts", "../../front/src/src/services/utils/BaseService.ts", "../../front/src/src/services/SettingsService.ts", "../../front/src/src/services/utils/CrudService.ts", "../../front/src/src/services/utils/legacy.ts", "../../front/src/src/services/utils/refresh.ts", "../../front/src/src/services/AdminService.ts", "../../front/src/src/services/RealtimeService.ts", "../../front/src/src/services/RecordService.ts", "../../front/src/src/services/CollectionService.ts", "../../front/src/src/services/LogService.ts", "../../front/src/src/services/HealthService.ts", "../../front/src/src/services/FileService.ts", "../../front/src/src/services/BackupService.ts", "../../front/src/src/Client.ts", "../../front/src/src/stores/AsyncAuthStore.ts"],
  "sourcesContent": ["/**\n * ClientResponseError is a custom Error class that is intended to wrap\n * and normalize any error thrown by `Client.send()`.\n */\nexport class ClientResponseError extends Error {\n    url: string                    = '';\n    status: number                 = 0;\n    response: {[key: string]: any} = {};\n    isAbort:  boolean              = false;\n    originalError: any             = null;\n\n    constructor(errData?: any) {\n        super(\"ClientResponseError\");\n\n        // Set the prototype explicitly.\n        // https://github.com/Microsoft/TypeScript-wiki/blob/main/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n        Object.setPrototypeOf(this, ClientResponseError.prototype);\n\n        if (errData !== null && typeof errData === 'object') {\n            this.url           = typeof errData.url === 'string' ? errData.url : '';\n            this.status        = typeof errData.status === 'number' ? errData.status : 0;\n            this.isAbort       = !!errData.isAbort;\n            this.originalError = errData.originalError;\n\n            if (errData.response !== null && typeof errData.response === 'object')  {\n                this.response =  errData.response;\n            } else if (errData.data !== null && typeof errData.data === 'object')  {\n                this.response =  errData.data;\n            } else {\n                this.response =  {};\n            }\n        }\n\n        if (!this.originalError && !(errData instanceof ClientResponseError)) {\n            this.originalError = errData;\n        }\n\n        if (typeof DOMException !== 'undefined' && errData instanceof DOMException) {\n            this.isAbort = true;\n        }\n\n        this.name = \"ClientResponseError \" + this.status;\n        this.message = this.response?.message;\n        if (!this.message) {\n            if (this.isAbort) {\n                this.message = 'The request was autocancelled. You can find more info in https://github.com/pocketbase/js-sdk#auto-cancellation.';\n            } else if (this.originalError?.cause?.message?.includes(\"ECONNREFUSED ::1\")) {\n                this.message = 'Failed to connect to the PocketBase server. Try changing the SDK URL from localhost to 127.0.0.1 (https://github.com/pocketbase/js-sdk/issues/21).';\n            } else {\n                this.message = 'Something went wrong while processing your request.';\n            }\n        }\n    }\n\n    /**\n     * Alias for `this.response` to preserve the backward compatibility.\n     */\n    get data() {\n        return this.response;\n    }\n\n    /**\n     * Make a POJO's copy of the current error class instance.\n     * @see https://github.com/vuex-orm/vuex-orm/issues/255\n     */\n    toJSON() {\n        return { ...this };\n    }\n}\n", "/**\n * -------------------------------------------------------------------\n * Simple cookie parse and serialize utilities mostly based on the\n * node module https://github.com/jshttp/cookie.\n * -------------------------------------------------------------------\n */\n\n/**\n * RegExp to match field-content in RFC 7230 sec 3.2\n *\n * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n * field-vchar   = VCHAR / obs-text\n * obs-text      = %x80-FF\n */\nconst fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\n\nexport interface ParseOptions{\n    decode?: (val: string) => string,\n}\n\n/**\n* Parses the given cookie header string into an object\n* The object has the various cookies as keys(names) => values\n*/\nexport function cookieParse(str: string, options?: ParseOptions): { [key: string]: any }  {\n    const result: { [key: string]: any } = {};\n\n    if (typeof str !== 'string') {\n        return result;\n    }\n\n    const opt    = Object.assign({}, options || {});\n    const decode = opt.decode || defaultDecode;\n\n    let index = 0;\n    while (index < str.length) {\n        const eqIdx = str.indexOf('=', index);\n\n        // no more cookie pairs\n        if (eqIdx === -1) {\n            break;\n        }\n\n        let endIdx = str.indexOf(';', index);\n\n        if (endIdx === -1) {\n            endIdx = str.length;\n        } else if (endIdx < eqIdx) {\n            // backtrack on prior semicolon\n            index = str.lastIndexOf(';', eqIdx - 1) + 1;\n            continue;\n        }\n\n        const key = str.slice(index, eqIdx).trim();\n\n        // only assign once\n        if (undefined === result[key]) {\n            let val = str.slice(eqIdx + 1, endIdx).trim();\n\n            // quoted values\n            if (val.charCodeAt(0) === 0x22) {\n                val = val.slice(1, -1);\n            }\n\n            try {\n                result[key] = decode(val);\n            } catch (_) {\n                result[key] = val; // no decoding\n            }\n        }\n\n        index = endIdx + 1;\n    }\n\n    return result;\n};\n\nexport interface SerializeOptions {\n    encode?:   (val: string | number | boolean) => string,\n    maxAge?:   number,\n    domain?:   string,\n    path?:     string,\n    expires?:  Date,\n    httpOnly?: boolean,\n    secure?:   boolean,\n    priority?: string,\n    sameSite?: boolean|string,\n}\n\n/**\n * Serialize data into a cookie header.\n *\n * Serialize the a name value pair into a cookie string suitable for\n * http headers. An optional options object specified cookie parameters.\n *\n * ```js\n * cookieSerialize('foo', 'bar', { httpOnly: true }) // \"foo=bar; httpOnly\"\n * ```\n */\nexport function cookieSerialize(name: string, val: string, options?: SerializeOptions): string {\n    const opt    = Object.assign({}, options || {});\n    const encode = opt.encode || defaultEncode;\n\n    if (!fieldContentRegExp.test(name)) {\n        throw new TypeError('argument name is invalid');\n    }\n\n    const value = encode(val);\n\n    if (value && !fieldContentRegExp.test(value)) {\n        throw new TypeError('argument val is invalid');\n    }\n\n    let result = name + '=' + value;\n\n    if (opt.maxAge != null) {\n        const maxAge = opt.maxAge - 0;\n\n        if (isNaN(maxAge) || !isFinite(maxAge)) {\n            throw new TypeError('option maxAge is invalid');\n        }\n\n        result += '; Max-Age=' + Math.floor(maxAge);\n    }\n\n    if (opt.domain) {\n        if (!fieldContentRegExp.test(opt.domain)) {\n            throw new TypeError('option domain is invalid');\n        }\n\n        result += '; Domain=' + opt.domain;\n    }\n\n    if (opt.path) {\n        if (!fieldContentRegExp.test(opt.path)) {\n            throw new TypeError('option path is invalid');\n        }\n\n        result += '; Path=' + opt.path;\n    }\n\n    if (opt.expires) {\n        if (!isDate(opt.expires) || isNaN(opt.expires.valueOf())) {\n            throw new TypeError('option expires is invalid');\n        }\n\n        result += '; Expires=' + opt.expires.toUTCString();\n    }\n\n    if (opt.httpOnly) {\n        result += '; HttpOnly';\n    }\n\n    if (opt.secure) {\n        result += '; Secure';\n    }\n\n    if (opt.priority) {\n        const priority = typeof opt.priority === 'string' ? opt.priority.toLowerCase() : opt.priority;\n\n        switch (priority) {\n            case 'low':\n                result += '; Priority=Low';\n                break;\n            case 'medium':\n                result += '; Priority=Medium';\n                break;\n            case 'high':\n                result += '; Priority=High';\n                break;\n            default:\n                throw new TypeError('option priority is invalid');\n        }\n    }\n\n    if (opt.sameSite) {\n        const sameSite = typeof opt.sameSite === 'string' ? opt.sameSite.toLowerCase() : opt.sameSite;\n\n        switch (sameSite) {\n            case true:\n                result += '; SameSite=Strict';\n                break;\n            case 'lax':\n                result += '; SameSite=Lax';\n                break;\n            case 'strict':\n                result += '; SameSite=Strict';\n                break;\n            case 'none':\n                result += '; SameSite=None';\n                break;\n            default:\n                throw new TypeError('option sameSite is invalid');\n        }\n    }\n\n    return result;\n};\n\n/**\n * Default URL-decode string value function.\n * Optimized to skip native call when no `%`.\n */\nfunction defaultDecode(val: string): string {\n    return val.indexOf('%') !== -1\n        ? decodeURIComponent(val)\n        : val;\n}\n\n/**\n * Default URL-encode value function.\n */\nfunction defaultEncode(val: string | number | boolean): string {\n    return encodeURIComponent(val);\n}\n\n/**\n * Determines if value is a Date.\n */\nfunction isDate(val: any): boolean {\n    return (\n        Object.prototype.toString.call(val) === '[object Date]' ||\n        val instanceof Date\n    );\n}\n", "let atobPolyfill: Function;\nif (typeof atob === 'function') {\n    atobPolyfill = atob\n} else {\n    /**\n     * The code was extracted from:\n     * https://github.com/davidchambers/Base64.js\n     */\n    atobPolyfill = (input: any) => {\n        const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n\n        let str = String(input).replace(/=+$/, \"\");\n        if (str.length % 4 == 1) {\n            throw new Error(\"'atob' failed: The string to be decoded is not correctly encoded.\");\n        }\n\n        for (\n            // initialize result and counters\n            var bc = 0, bs, buffer, idx = 0, output = \"\";\n            // get next character\n            (buffer = str.charAt(idx++));\n            // character found in table? initialize bit storage and add its ascii value;\n            ~buffer &&\n            ((bs = bc % 4 ? (bs as any) * 64 + buffer : buffer),\n                // and if not first of each 4 characters,\n                // convert the first 8 bits to one ascii character\n                bc++ % 4) ?\n            (output += String.fromCharCode(255 & (bs >> ((-2 * bc) & 6)))) :\n            0\n        ) {\n            // try to find character in table (0-63, not found => -1)\n            buffer = chars.indexOf(buffer);\n        }\n\n        return output;\n    };\n}\n\n/**\n * Returns JWT token's payload data.\n */\nexport function getTokenPayload(token: string): { [key: string]: any } {\n    if (token) {\n        try {\n            const encodedPayload = decodeURIComponent(atobPolyfill(token.split('.')[1]).split('').map(function (c: string) {\n                return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\n            }).join(''));\n\n            return JSON.parse(encodedPayload) || {};\n        } catch (e) {\n        }\n    }\n\n    return {};\n}\n\n/**\n * Checks whether a JWT token is expired or not.\n * Tokens without `exp` payload key are considered valid.\n * Tokens with empty payload (eg. invalid token strings) are considered expired.\n *\n * @param token The token to check.\n * @param [expirationThreshold] Time in seconds that will be subtracted from the token `exp` property.\n */\nexport function isTokenExpired(token: string, expirationThreshold = 0): boolean {\n    let payload = getTokenPayload(token);\n\n    if (\n        Object.keys(payload).length > 0 &&\n        (!payload.exp || (payload.exp - expirationThreshold) > (Date.now() / 1000))\n    ) {\n        return false;\n    }\n\n    return true;\n}\n", "import { cookieParse, cookieSerialize, SerializeOptions } from '@/stores/utils/cookie';\nimport { isTokenExpired, getTokenPayload } from '@/stores/utils/jwt';\n\nexport type AuthModel = { [key: string]: any }|null;\n\nexport type OnStoreChangeFunc = (token: string, model: AuthModel) => void;\n\nconst defaultCookieKey = 'pb_auth';\n\n/**\n * Base AuthStore class that is intended to be extended by all other\n * PocketBase AuthStore implementations.\n */\nexport abstract class BaseAuthStore {\n    protected baseToken: string = '';\n    protected baseModel: AuthModel = null;\n\n    private _onChangeCallbacks: Array<OnStoreChangeFunc> = [];\n\n    /**\n     * Retrieves the stored token (if any).\n     */\n    get token(): string {\n        return this.baseToken;\n    }\n\n    /**\n     * Retrieves the stored model data (if any).\n     */\n    get model(): AuthModel {\n        return this.baseModel;\n    }\n\n    /**\n     * Loosely checks if the store has valid token (aka. existing and unexpired exp claim).\n     */\n    get isValid(): boolean {\n        return !isTokenExpired(this.token);\n    }\n\n    /**\n     * Checks whether the current store state is for admin authentication.\n     */\n    get isAdmin(): boolean {\n        return getTokenPayload(this.token).type === \"admin\";\n    }\n\n    /**\n     * Checks whether the current store state is for auth record authentication.\n     */\n    get isAuthRecord(): boolean {\n        return getTokenPayload(this.token).type === \"authRecord\";\n    }\n\n    /**\n     * Saves the provided new token and model data in the auth store.\n     */\n    save(token: string, model?: AuthModel): void {\n        this.baseToken = token || '';\n        this.baseModel = model || null;\n\n        this.triggerChange();\n    }\n\n    /**\n     * Removes the stored token and model data form the auth store.\n     */\n    clear(): void {\n        this.baseToken = '';\n        this.baseModel = null;\n        this.triggerChange();\n    }\n\n    /**\n     * Parses the provided cookie string and updates the store state\n     * with the cookie's token and model data.\n     *\n     * NB! This function doesn't validate the token or its data.\n     * Usually this isn't a concern if you are interacting only with the\n     * PocketBase API because it has the proper server-side security checks in place,\n     * but if you are using the store `isValid` state for permission controls\n     * in a node server (eg. SSR), then it is recommended to call `authRefresh()`\n     * after loading the cookie to ensure an up-to-date token and model state.\n     * For example:\n     *\n     * ```js\n     * pb.authStore.loadFromCookie(\"cookie string...\");\n     *\n     * try {\n     *     // get an up-to-date auth store state by veryfing and refreshing the loaded auth model (if any)\n     *     pb.authStore.isValid && await pb.collection('users').authRefresh();\n     * } catch (_) {\n     *     // clear the auth store on failed refresh\n     *     pb.authStore.clear();\n     * }\n     * ```\n     */\n    loadFromCookie(cookie: string, key = defaultCookieKey): void {\n        const rawData = cookieParse(cookie || '')[key] || '';\n\n        let data: { [key: string]: any } = {};\n        try {\n            data = JSON.parse(rawData);\n            // normalize\n            if (typeof data === null || typeof data !== 'object' || Array.isArray(data)) {\n                data = {};\n            }\n        } catch (_) {}\n\n        this.save(data.token || '', data.model || null);\n    }\n\n    /**\n     * Exports the current store state as cookie string.\n     *\n     * By default the following optional attributes are added:\n     * - Secure\n     * - HttpOnly\n     * - SameSite=Strict\n     * - Path=/\n     * - Expires={the token expiration date}\n     *\n     * NB! If the generated cookie exceeds 4096 bytes, this method will\n     * strip the model data to the bare minimum to try to fit within the\n     * recommended size in https://www.rfc-editor.org/rfc/rfc6265#section-6.1.\n     */\n    exportToCookie(options?: SerializeOptions, key = defaultCookieKey): string {\n        const defaultOptions: SerializeOptions = {\n            secure:   true,\n            sameSite: true,\n            httpOnly: true,\n            path:     \"/\",\n        };\n\n        // extract the token expiration date\n        const payload = getTokenPayload(this.token);\n        if (payload?.exp) {\n            defaultOptions.expires = new Date(payload.exp * 1000);\n        } else {\n            defaultOptions.expires = new Date('1970-01-01');\n        }\n\n        // merge with the user defined options\n        options = Object.assign({}, defaultOptions, options);\n\n        const rawData = {\n            token: this.token,\n            model: this.model ? JSON.parse(JSON.stringify(this.model)) : null,\n        };\n\n        let result = cookieSerialize(key, JSON.stringify(rawData), options);\n\n        const resultLength = typeof Blob !== 'undefined' ?\n            (new Blob([result])).size : result.length;\n\n        // strip down the model data to the bare minimum\n        if (rawData.model && resultLength > 4096) {\n            rawData.model = {id: rawData?.model?.id, email: rawData?.model?.email};\n            const extraProps = [\"collectionId\", \"username\", \"verified\"];\n            for (const prop in this.model) {\n                if (extraProps.includes(prop)) {\n                    rawData.model[prop] = this.model[prop];\n                }\n            }\n            result = cookieSerialize(key, JSON.stringify(rawData), options);\n        }\n\n        return result;\n    }\n\n    /**\n     * Register a callback function that will be called on store change.\n     *\n     * You can set the `fireImmediately` argument to true in order to invoke\n     * the provided callback right after registration.\n     *\n     * Returns a removal function that you could call to \"unsubscribe\" from the changes.\n     */\n    onChange(callback: OnStoreChangeFunc, fireImmediately = false): () => void {\n        this._onChangeCallbacks.push(callback);\n\n        if (fireImmediately) {\n            callback(this.token, this.model);\n        }\n\n        return () => {\n            for (let i = this._onChangeCallbacks.length - 1; i >= 0; i--) {\n                if (this._onChangeCallbacks[i] == callback) {\n                    delete this._onChangeCallbacks[i];    // removes the function reference\n                    this._onChangeCallbacks.splice(i, 1); // reindex the array\n                    return;\n                }\n            }\n        }\n    }\n\n    protected triggerChange(): void {\n        for (const callback of this._onChangeCallbacks) {\n            callback && callback(this.token, this.model);\n        }\n    }\n}\n", "import { BaseAuthStore, AuthModel } from '@/stores/BaseAuthStore';\n\n/**\n * The default token store for browsers with auto fallback\n * to runtime/memory if local storage is undefined (eg. in node env).\n */\nexport class LocalAuthStore extends BaseAuthStore {\n    private storageFallback: { [key: string]: any } = {};\n    private storageKey: string\n\n    constructor(storageKey = \"pocketbase_auth\") {\n        super();\n\n        this.storageKey = storageKey;\n\n        this._bindStorageEvent();\n    }\n\n    /**\n     * @inheritdoc\n     */\n    get token(): string {\n        const data = this._storageGet(this.storageKey) || {};\n\n        return data.token || '';\n    }\n\n    /**\n     * @inheritdoc\n     */\n    get model(): AuthModel {\n        const data = this._storageGet(this.storageKey) || {};\n\n        return data.model || null;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    save(token: string, model?: AuthModel) {\n        this._storageSet(this.storageKey, {\n            'token': token,\n            'model': model,\n        });\n\n        super.save(token, model);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    clear() {\n        this._storageRemove(this.storageKey);\n\n        super.clear();\n    }\n\n    // ---------------------------------------------------------------\n    // Internal helpers:\n    // ---------------------------------------------------------------\n\n    /**\n     * Retrieves `key` from the browser's local storage\n     * (or runtime/memory if local storage is undefined).\n     */\n    private _storageGet(key: string): any {\n        if (typeof window !== 'undefined' && window?.localStorage) {\n            const rawValue = window.localStorage.getItem(key) || '';\n            try {\n                return JSON.parse(rawValue);\n            } catch (e) { // not a json\n                return rawValue;\n            }\n        }\n\n        // fallback\n        return this.storageFallback[key];\n    }\n\n    /**\n     * Stores a new data in the browser's local storage\n     * (or runtime/memory if local storage is undefined).\n     */\n    private _storageSet(key: string, value: any) {\n        if (typeof window !== 'undefined' && window?.localStorage) {\n            // store in local storage\n            let normalizedVal = value;\n            if (typeof value !== 'string') {\n                normalizedVal = JSON.stringify(value);\n            }\n            window.localStorage.setItem(key, normalizedVal);\n        } else {\n            // store in fallback\n            this.storageFallback[key] = value;\n        }\n    }\n\n    /**\n     * Removes `key` from the browser's local storage and the runtime/memory.\n     */\n    private _storageRemove(key: string) {\n        // delete from local storage\n        if (typeof window !== 'undefined' && window?.localStorage) {\n            window.localStorage?.removeItem(key);\n        }\n\n        // delete from fallback\n        delete this.storageFallback[key];\n    }\n\n    /**\n     * Updates the current store state on localStorage change.\n     */\n    private _bindStorageEvent() {\n        if (typeof window === 'undefined' || !window?.localStorage || !window.addEventListener) {\n            return;\n        }\n\n        window.addEventListener('storage', (e) => {\n            if (e.key != this.storageKey) {\n                return;\n            }\n\n            const data = this._storageGet(this.storageKey) || {};\n\n            super.save(data.token || '', data.model || null);\n        });\n    }\n}\n", "import Client from '@/Client';\n\n/**\n * BaseService class that should be inherited from all API services.\n */\nexport abstract class BaseService {\n    readonly client: Client\n\n    constructor(client: Client) {\n        this.client = client;\n    }\n}\n", "import { BaseService }   from '@/services/utils/BaseService';\nimport { CommonOptions } from '@/services/utils/options';\n\ninterface appleClientSecret {\n    secret: string;\n}\n\nexport class SettingsService extends BaseService {\n    /**\n     * Fetch all available app settings.\n     */\n    getAll(options?: CommonOptions): Promise<{[key: string]:any}> {\n        options = Object.assign({\n            'method': 'GET',\n        }, options);\n\n        return this.client.send('/api/settings', options);\n    }\n\n    /**\n     * Bulk updates app settings.\n     */\n    update(\n        bodyParams?: {[key:string]:any}|FormData,\n        options?: CommonOptions,\n    ): Promise<{[key: string]:any}> {\n        options = Object.assign({\n            'method': 'PATCH',\n            'body':   bodyParams,\n        }, options);\n\n        return this.client.send('/api/settings', options);\n    }\n\n    /**\n     * Performs a S3 filesystem connection test.\n     *\n     * The currently supported `filesystem` are \"storage\" and \"backups\".\n     */\n    testS3(filesystem: string = \"storage\", options?: CommonOptions): Promise<boolean> {\n        options = Object.assign({\n            'method': 'POST',\n            'body': {\n                'filesystem': filesystem,\n            },\n        }, options);\n\n        return this.client.send('/api/settings/test/s3', options)\n            .then(() => true);\n    }\n\n    /**\n     * Sends a test email.\n     *\n     * The possible `emailTemplate` values are:\n     * - verification\n     * - password-reset\n     * - email-change\n     */\n    testEmail(toEmail: string, emailTemplate: string, options?: CommonOptions): Promise<boolean> {\n        options = Object.assign({\n            'method': 'POST',\n            'body': {\n                'email':    toEmail,\n                'template': emailTemplate,\n            },\n        }, options);\n\n        return this.client.send('/api/settings/test/email', options)\n            .then(() => true);\n    }\n\n    /**\n     * Generates a new Apple OAuth2 client secret.\n     */\n    generateAppleClientSecret(\n        clientId: string,\n        teamId: string,\n        keyId: string,\n        privateKey: string,\n        duration: number,\n        options?: CommonOptions,\n    ): Promise<appleClientSecret> {\n        options = Object.assign({\n            'method': 'POST',\n            'body': {\n                clientId,\n                teamId,\n                keyId,\n                privateKey,\n                duration,\n            },\n        }, options);\n\n        return this.client.send('/api/settings/apple/generate-client-secret', options);\n    }\n}\n", "import { BaseService }         from '@/services/utils/BaseService';\nimport { ClientResponseError } from '@/ClientResponseError';\nimport { ListResult }          from '@/services/utils/dtos';\nimport {\n    CommonOptions,\n    ListOptions,\n    FullListOptions\n} from '@/services/utils/options';\n\nexport abstract class CrudService<M> extends BaseService   {\n    /**\n     * Base path for the crud actions (without trailing slash, eg. '/admins').\n     */\n    abstract get baseCrudPath(): string\n\n    /**\n     * Response data decoder.\n     */\n    decode<T = M>(data: { [key: string]: any }): T {\n        return data as T;\n    }\n\n    /**\n     * Returns a promise with all list items batch fetched at once\n     * (by default 500 items per request; to change it set the `batch` query param).\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     */\n    getFullList<T = M>(options?: FullListOptions): Promise<Array<T>>\n\n    /**\n     * Legacy version of getFullList with explicitly specified batch size.\n     */\n    getFullList<T = M>(batch?: number, options?: ListOptions): Promise<Array<T>>\n\n    getFullList<T = M>(batchOrqueryParams?: number|FullListOptions, options?: ListOptions): Promise<Array<T>> {\n        if (typeof batchOrqueryParams == \"number\") {\n            return this._getFullList<T>(batchOrqueryParams, options);\n        }\n\n        options = Object.assign({}, batchOrqueryParams, options);\n\n        let batch = 500;\n        if (options.batch) {\n            batch = options.batch;\n            delete options.batch;\n        }\n\n        return this._getFullList<T>(batch, options);\n    }\n\n    /**\n     * Returns paginated items list.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     */\n    getList<T = M>(page = 1, perPage = 30, options?: ListOptions): Promise<ListResult<T>> {\n        options = Object.assign({\n            method: 'GET'\n        }, options);\n\n        options.query = Object.assign({\n            'page':    page,\n            'perPage': perPage,\n        }, options.query);\n\n        return this.client.send(this.baseCrudPath, options)\n            .then((responseData: any) => {\n                responseData.items = responseData.items?.map((item: any) => {\n                    return this.decode<T>(item);\n                }) || [];\n\n                return responseData;\n            });\n    }\n\n    /**\n     * Returns the first found item by the specified filter.\n     *\n     * Internally it calls `getList(1, 1, { filter, skipTotal })` and\n     * returns the first found item.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     *\n     * For consistency with `getOne`, this method will throw a 404\n     * ClientResponseError if no item was found.\n     */\n    getFirstListItem<T = M>(filter: string, options?: CommonOptions): Promise<T> {\n        options = Object.assign({\n            'requestKey': 'one_by_filter_' + this.baseCrudPath + \"_\" + filter,\n        }, options);\n\n        options.query = Object.assign({\n            'filter':     filter,\n            'skipTotal':  1,\n        }, options.query);\n\n        return this.getList<T>(1, 1, options)\n            .then((result) => {\n                if (!result?.items?.length) {\n                    throw new ClientResponseError({\n                        status: 404,\n                        data: {\n                            code: 404,\n                            message: \"The requested resource wasn't found.\",\n                            data: {},\n                        },\n                    });\n                }\n\n                return result.items[0];\n            });\n    }\n\n    /**\n     * Returns single item by its id.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     */\n    getOne<T = M>(id: string, options?: CommonOptions): Promise<T> {\n        options = Object.assign({\n            'method': 'GET',\n        }, options);\n\n        return this.client.send(this.baseCrudPath + '/' + encodeURIComponent(id), options)\n            .then((responseData: any) => this.decode<T>(responseData));\n    }\n\n    /**\n     * Creates a new item.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     */\n    create<T = M>(\n        bodyParams?: {[key:string]:any}|FormData,\n        options?: CommonOptions,\n    ): Promise<T> {\n        options = Object.assign({\n            'method': 'POST',\n            'body':   bodyParams,\n        }, options);\n\n        return this.client.send(this.baseCrudPath, options)\n            .then((responseData: any) => this.decode<T>(responseData));\n    }\n\n    /**\n     * Updates an existing item by its id.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     */\n    update<T = M>(\n        id: string,\n        bodyParams?: {[key:string]:any}|FormData,\n        options?: CommonOptions,\n    ): Promise<T> {\n        options = Object.assign({\n            'method': 'PATCH',\n            'body':   bodyParams,\n        }, options);\n\n        return this.client.send(this.baseCrudPath + '/' + encodeURIComponent(id), options)\n            .then((responseData: any) => this.decode<T>(responseData));\n    }\n\n    /**\n     * Deletes an existing item by its id.\n     */\n    delete(id: string, options?: CommonOptions): Promise<boolean> {\n        options = Object.assign({\n            'method': 'DELETE',\n        }, options);\n\n        return this.client.send(this.baseCrudPath + '/' + encodeURIComponent(id), options)\n            .then(() => true);\n    }\n\n    /**\n     * Returns a promise with all list items batch fetched at once.\n     */\n    protected _getFullList<T = M>(batchSize = 500, options?: ListOptions): Promise<Array<T>> {\n        options = options || {};\n        options.query = Object.assign({\n            'skipTotal': 1,\n        }, options.query);\n\n        let result: Array<T> = [];\n\n        let request = async (page: number): Promise<Array<any>> => {\n            return this.getList(page, batchSize || 500, options).then((list) => {\n                const castedList = (list as any as ListResult<T>);\n                const items      = castedList.items;\n\n                result = result.concat(items);\n\n                if (items.length == list.perPage) {\n                    return request(page + 1);\n                }\n\n                return result;\n            });\n        }\n\n        return request(1);\n    }\n}\n", "import { SendOptions } from '@/services/utils/options';\n\nexport function normalizeLegacyOptionsArgs(legacyWarn: string, baseOptions: SendOptions, bodyOrOptions?: any, query?: any): SendOptions {\n    const hasBodyOrOptions = typeof bodyOrOptions !== 'undefined';\n    const hasQuery = typeof query !== 'undefined';\n\n    if (!hasQuery && !hasBodyOrOptions) {\n        return baseOptions;\n    }\n\n    if (hasQuery) {\n        console.warn(legacyWarn);\n        baseOptions.body = Object.assign({}, baseOptions.body, bodyOrOptions);\n        baseOptions.query = Object.assign({}, baseOptions.query, query);\n\n        return baseOptions;\n    }\n\n    return Object.assign(baseOptions, bodyOrOptions);\n}\n", "import Client             from '@/Client';\nimport { isTokenExpired } from '@/stores/utils/jwt';\n\n// reset previous auto refresh registrations\nexport function resetAutoRefresh(client: Client) {\n    (client as any)._resetAutoRefresh?.();\n}\n\nexport function registerAutoRefresh(\n  client: Client,\n  threshold: number,\n  refreshFunc: () => Promise<any>,\n  reauthenticateFunc: () => Promise<any>,\n) {\n    resetAutoRefresh(client);\n\n    const oldBeforeSend = client.beforeSend;\n    const oldModel = client.authStore.model;\n\n    // unset the auto refresh in case the auth store was cleared\n    // OR a new model was authenticated\n    const unsubStoreChange = client.authStore.onChange((newToken, model) => {\n        if (\n            !newToken ||\n            model?.id != oldModel?.id ||\n            // check the collection id in case an admin and auth record share the same id\n            ((model?.collectionId || oldModel?.collectionId) && model?.collectionId != oldModel?.collectionId)\n        ) {\n            resetAutoRefresh(client);\n        }\n    });\n\n    // initialize a reset function and attach it dynamically to the client\n    (client as any)._resetAutoRefresh = function() {\n        unsubStoreChange();\n        client.beforeSend = oldBeforeSend;\n        delete (client as any)._resetAutoRefresh;\n    };\n\n    client.beforeSend = async (url, sendOptions) => {\n        const oldToken = client.authStore.token;\n\n        if (sendOptions.query?.autoRefresh) {\n            return oldBeforeSend ? oldBeforeSend(url, sendOptions) : { url, sendOptions };\n        }\n\n        let isValid = client.authStore.isValid;\n        if (\n            // is loosely valid\n            isValid &&\n            // but it is going to expire in the next \"threshold\" seconds\n            isTokenExpired(client.authStore.token, threshold)\n        ) {\n            try {\n                await refreshFunc();\n            } catch (_) {\n                isValid = false;\n            }\n        }\n\n        // still invalid -> reauthenticate\n        if (!isValid) {\n            await reauthenticateFunc();\n        }\n\n        // the request wasn't sent with a custom token\n        const headers = sendOptions.headers || {};\n        for (let key in headers) {\n            if (\n                key.toLowerCase() == \"authorization\" &&\n                // the request wasn't sent with a custom token\n                oldToken == headers[key] &&\n                client.authStore.token\n            ) {\n                // set the latest store token\n                headers[key] = client.authStore.token;\n                break;\n            }\n        }\n        sendOptions.headers = headers;\n\n        return oldBeforeSend ? oldBeforeSend(url, sendOptions) : { url, sendOptions };\n    }\n}\n", "import { CrudService }                           from '@/services/utils/CrudService';\nimport { AdminModel }                            from '@/services/utils/dtos';\nimport { AuthOptions, CommonOptions }            from '@/services/utils/options';\nimport { normalizeLegacyOptionsArgs }            from '@/services/utils/legacy';\nimport { registerAutoRefresh, resetAutoRefresh } from '@/services/utils/refresh';\n\nexport interface AdminAuthResponse {\n    [key: string]: any;\n\n    token: string;\n    admin: AdminModel;\n}\n\nexport class AdminService extends CrudService<AdminModel> {\n    /**\n     * @inheritdoc\n     */\n    get baseCrudPath(): string {\n        return '/api/admins';\n    }\n\n    // ---------------------------------------------------------------\n    // Post update/delete AuthStore sync\n    // ---------------------------------------------------------------\n\n    /**\n     * @inheritdoc\n     *\n     * If the current `client.authStore.model` matches with the updated id, then\n     * on success the `client.authStore.model` will be updated with the result.\n     */\n    update<T = AdminModel>(\n        id: string,\n        bodyParams?: {[key:string]:any}|FormData,\n        options?: CommonOptions,\n    ): Promise<T> {\n        return super.update(id, bodyParams, options).then((item) => {\n            // update the store state if the updated item id matches with the stored model\n            if (\n                this.client.authStore.model?.id === item.id &&\n                typeof this.client.authStore.model?.collectionId === 'undefined' // is not record auth\n            ) {\n                this.client.authStore.save(this.client.authStore.token, item);\n            }\n\n            return item as any as T;\n        });\n    }\n\n    /**\n     * @inheritdoc\n     *\n     * If the current `client.authStore.model` matches with the deleted id,\n     * then on success the `client.authStore` will be cleared.\n     */\n    delete(id: string, options?: CommonOptions): Promise<boolean> {\n        return super.delete(id, options).then((success) => {\n            // clear the store state if the deleted item id matches with the stored model\n            if (\n                success &&\n                this.client.authStore.model?.id === id &&\n                typeof this.client.authStore.model?.collectionId === 'undefined' // is not record auth\n            ) {\n                this.client.authStore.clear();\n            }\n\n            return success;\n        });\n    }\n\n    // ---------------------------------------------------------------\n    // Auth handlers\n    // ---------------------------------------------------------------\n\n    /**\n     * Prepare successful authorize response.\n     */\n    protected authResponse(responseData: any): AdminAuthResponse {\n        const admin = this.decode(responseData?.admin || {});\n\n        if (responseData?.token && responseData?.admin) {\n            this.client.authStore.save(responseData.token, admin);\n        }\n\n        return Object.assign({}, responseData, {\n            // normalize common fields\n            'token': responseData?.token || '',\n            'admin': admin,\n        });\n    }\n\n    /**\n     * Authenticate an admin account with its email and password\n     * and returns a new admin token and data.\n     *\n     * On success this method automatically updates the client's AuthStore data.\n     */\n    authWithPassword(email: string, password: string, options?: AuthOptions): Promise<AdminAuthResponse>\n\n    /**\n     * @deprecated\n     * Consider using authWithPassword(email, password, options?).\n     */\n    authWithPassword(email: string, password: string, body?: any, query?: any): Promise<AdminAuthResponse>\n\n    async authWithPassword(\n        email: string,\n        password: string,\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<AdminAuthResponse> {\n        let options: any = {\n            'method': 'POST',\n            'body': {\n                'identity': email,\n                'password': password,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            'This form of authWithPassword(email, pass, body?, query?) is deprecated. Consider replacing it with authWithPassword(email, pass, options?).',\n            options,\n            bodyOrOptions,\n            query\n        );\n\n        const autoRefreshThreshold = options.autoRefreshThreshold;\n        delete options.autoRefreshThreshold;\n\n        // not from auto refresh reauthentication\n        if (!options.autoRefresh) {\n            resetAutoRefresh(this.client);\n        }\n\n        let authData = await this.client.send(this.baseCrudPath + '/auth-with-password', options);\n\n        authData = this.authResponse(authData);\n\n        if (autoRefreshThreshold) {\n            registerAutoRefresh(\n                this.client,\n                autoRefreshThreshold,\n                () => this.authRefresh({autoRefresh: true}),\n                () => this.authWithPassword(email, password, Object.assign({autoRefresh: true}, options)),\n            );\n        }\n\n        return authData;\n    }\n\n    /**\n     * Refreshes the current admin authenticated instance and\n     * returns a new token and admin data.\n     *\n     * On success this method automatically updates the client's AuthStore data.\n     */\n    authRefresh(options?: CommonOptions): Promise<AdminAuthResponse>\n\n    /**\n     * @deprecated\n     * Consider using authRefresh(options?).\n     */\n    authRefresh(body?: any, query?: any): Promise<AdminAuthResponse>\n\n    authRefresh(bodyOrOptions?: any, query?: any): Promise<AdminAuthResponse> {\n        let options: any = {\n            'method': 'POST',\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            'This form of authRefresh(body?, query?) is deprecated. Consider replacing it with authRefresh(options?).',\n            options,\n            bodyOrOptions,\n            query\n        );\n\n        return this.client.send(this.baseCrudPath + '/auth-refresh', options)\n            .then(this.authResponse.bind(this));\n    }\n\n    /**\n     * Sends admin password reset request.\n     */\n    requestPasswordReset(email: string, options?: CommonOptions): Promise<boolean>\n\n    /**\n     * @deprecated\n     * Consider using requestPasswordReset(email, options?).\n     */\n    requestPasswordReset(email: string, body?: any, query?: any): Promise<boolean>\n\n    requestPasswordReset(email: string, bodyOrOptions?: any, query?: any): Promise<boolean> {\n        let options: any = {\n            'method': 'POST',\n            'body': {\n                'email': email,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            'This form of requestPasswordReset(email, body?, query?) is deprecated. Consider replacing it with requestPasswordReset(email, options?).',\n            options,\n            bodyOrOptions,\n            query\n        );\n\n        return this.client.send(this.baseCrudPath + '/request-password-reset', options)\n            .then(() => true);\n    }\n\n    /**\n     * Confirms admin password reset request.\n     */\n    confirmPasswordReset(resetToken: string, password: string, passwordConfirm: string, options?: CommonOptions): Promise<boolean>\n\n    /**\n     * @deprecated\n     * Consider using confirmPasswordReset(resetToken, password, passwordConfirm, options?).\n     */\n    confirmPasswordReset(resetToken: string, password: string, passwordConfirm: string, body?: any, query?: any): Promise<boolean>\n\n    confirmPasswordReset(resetToken: string, password: string, passwordConfirm: string, bodyOrOptions?: any, query?: any): Promise<boolean>{\n        let options: any = {\n            'method': 'POST',\n            'body': {\n                'token':           resetToken,\n                'password':        password,\n                'passwordConfirm': passwordConfirm,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            'This form of confirmPasswordReset(resetToken, password, passwordConfirm, body?, query?) is deprecated. Consider replacing it with confirmPasswordReset(resetToken, password, passwordConfirm, options?).',\n            options,\n            bodyOrOptions,\n            query\n        );\n\n        return this.client.send(this.baseCrudPath + '/confirm-password-reset', options)\n            .then(() => true);\n    }\n}\n", "import { BaseService }         from '@/services/utils/BaseService';\nimport { ClientResponseError } from '@/ClientResponseError';\n\ninterface promiseCallbacks {\n    resolve: Function\n    reject: Function\n}\n\nexport type UnsubscribeFunc = () => Promise<void>;\n\nexport class RealtimeService extends BaseService {\n    clientId: string = \"\";\n\n    private eventSource: EventSource | null = null;\n    private subscriptions: { [key: string]: Array<EventListener> } = {};\n    private lastSentTopics: Array<string> = [];\n    private connectTimeoutId: any;\n    private maxConnectTimeout: number = 15000;\n    private reconnectTimeoutId: any;\n    private reconnectAttempts: number = 0;\n    private maxReconnectAttempts: number = Infinity;\n    private predefinedReconnectIntervals: Array<number> = [\n        200, 300, 500, 1000, 1200, 1500, 2000,\n    ];\n    private pendingConnects: Array<promiseCallbacks> = [];\n\n    /**\n     * Returns whether the realtime connection has been established.\n     */\n    get isConnected(): boolean {\n        return !!this.eventSource && !!this.clientId && !this.pendingConnects.length;\n    }\n\n    /**\n     * Register the subscription listener.\n     *\n     * You can subscribe multiple times to the same topic.\n     *\n     * If the SSE connection is not started yet,\n     * this method will also initialize it.\n     */\n    async subscribe(topic: string, callback: (data: any) => void): Promise<UnsubscribeFunc> {\n        if (!topic) {\n            throw new Error('topic must be set.')\n        }\n\n        const listener = function (e: Event) {\n            const msgEvent = (e as MessageEvent);\n\n            let data;\n            try {\n                data = JSON.parse(msgEvent?.data);\n            } catch {}\n\n            callback(data || {});\n        };\n\n        // store the listener\n        if (!this.subscriptions[topic]) {\n            this.subscriptions[topic] = [];\n        }\n        this.subscriptions[topic].push(listener);\n\n        if (!this.isConnected) {\n            // initialize sse connection\n            await this.connect();\n        } else if (this.subscriptions[topic].length === 1) {\n            // send the updated subscriptions (if it is the first for the topic)\n            await this.submitSubscriptions();\n        } else {\n            // only register the listener\n            this.eventSource?.addEventListener(topic, listener);\n        }\n\n        return async (): Promise<void> => {\n            return this.unsubscribeByTopicAndListener(topic, listener);\n        };\n    }\n\n    /**\n     * Unsubscribe from all subscription listeners with the specified topic.\n     *\n     * If `topic` is not provided, then this method will unsubscribe\n     * from all active subscriptions.\n     *\n     * This method is no-op if there are no active subscriptions.\n     *\n     * The related sse connection will be autoclosed if after the\n     * unsubscribe operation there are no active subscriptions left.\n     */\n    async unsubscribe(topic?: string): Promise<void> {\n        if (!this.hasSubscriptionListeners(topic)) {\n            return; // already unsubscribed\n        }\n\n        if (!topic) {\n            // remove all subscriptions\n            this.subscriptions = {};\n        } else {\n            // remove all topic listeners\n            for (let listener of this.subscriptions[topic]) {\n                this.eventSource?.removeEventListener(topic, listener);\n            }\n            delete this.subscriptions[topic];\n        }\n\n        if (!this.hasSubscriptionListeners()) {\n            // no other active subscriptions -> close the sse connection\n            this.disconnect();\n        } else if (!this.hasSubscriptionListeners(topic)) {\n            // submit subscriptions change if there are no other active subscriptions related to the topic\n            await this.submitSubscriptions();\n        }\n    }\n\n    /**\n     * Unsubscribe from all subscription listeners starting with the specified topic prefix.\n     *\n     * This method is no-op if there are no active subscriptions with the specified topic prefix.\n     *\n     * The related sse connection will be autoclosed if after the\n     * unsubscribe operation there are no active subscriptions left.\n     */\n    async unsubscribeByPrefix(topicPrefix: string): Promise<void> {\n        let hasAtleastOneTopic = false;\n        for (let topic in this.subscriptions) {\n            if (!topic.startsWith(topicPrefix)) {\n                continue;\n            }\n\n            hasAtleastOneTopic = true;\n            for (let listener of this.subscriptions[topic]) {\n                this.eventSource?.removeEventListener(topic, listener);\n            }\n            delete this.subscriptions[topic];\n        }\n\n        if (!hasAtleastOneTopic) {\n            return; // nothing to unsubscribe from\n        }\n\n        if (this.hasSubscriptionListeners()) {\n            // submit the deleted subscriptions\n            await this.submitSubscriptions();\n        } else {\n            // no other active subscriptions -> close the sse connection\n            this.disconnect();\n        }\n    }\n\n    /**\n     * Unsubscribe from all subscriptions matching the specified topic and listener function.\n     *\n     * This method is no-op if there are no active subscription with\n     * the specified topic and listener.\n     *\n     * The related sse connection will be autoclosed if after the\n     * unsubscribe operation there are no active subscriptions left.\n     */\n    async unsubscribeByTopicAndListener(topic: string, listener: EventListener): Promise<void> {\n        if (!Array.isArray(this.subscriptions[topic]) || !this.subscriptions[topic].length) {\n            return; // already unsubscribed\n        }\n\n        let exist = false;\n        for (let i = this.subscriptions[topic].length - 1; i >= 0; i--) {\n            if (this.subscriptions[topic][i] !== listener) {\n                continue;\n            }\n\n            exist = true;                           // has at least one matching listener\n            delete this.subscriptions[topic][i];    // removes the function reference\n            this.subscriptions[topic].splice(i, 1); // reindex the array\n            this.eventSource?.removeEventListener(topic, listener);\n        }\n        if (!exist) {\n            return;\n        }\n\n        // remove the topic from the subscriptions list if there are no other listeners\n        if (!this.subscriptions[topic].length) {\n            delete this.subscriptions[topic];\n        }\n\n        if (!this.hasSubscriptionListeners()) {\n            // no other active subscriptions -> close the sse connection\n            this.disconnect();\n        } else if (!this.hasSubscriptionListeners(topic)) {\n            // submit subscriptions change if there are no other active subscriptions related to the topic\n            await this.submitSubscriptions();\n        }\n    }\n\n    private hasSubscriptionListeners(topicToCheck?: string): boolean {\n        this.subscriptions = this.subscriptions || {};\n\n        // check the specified topic\n        if (topicToCheck) {\n            return !!this.subscriptions[topicToCheck]?.length;\n        }\n\n        // check for at least one non-empty topic\n        for (let topic in this.subscriptions) {\n            if (!!this.subscriptions[topic]?.length) {\n                return true\n            }\n        }\n\n        return false;\n    }\n\n    private async submitSubscriptions(): Promise<void> {\n        if (!this.clientId) {\n            return; // no client/subscriber\n        }\n\n        // optimistic update\n        this.addAllSubscriptionListeners();\n\n        this.lastSentTopics = this.getNonEmptySubscriptionTopics();\n\n        return this.client.send('/api/realtime', {\n            'method': 'POST',\n            'body': {\n                'clientId': this.clientId,\n                'subscriptions': this.lastSentTopics,\n            },\n            'query': {\n                'requestKey': this.getSubscriptionsCancelKey(),\n            },\n        }).catch((err) => {\n            if (err?.isAbort) {\n                return; // silently ignore aborted pending requests\n            }\n            throw err;\n        });\n    }\n\n    private getSubscriptionsCancelKey(): string {\n        return \"realtime_\" + this.clientId;\n    }\n\n    private getNonEmptySubscriptionTopics(): Array<string> {\n        const result : Array<string> = [];\n\n        for (let topic in this.subscriptions) {\n            if (this.subscriptions[topic].length) {\n                result.push(topic);\n            }\n        }\n\n        return result;\n    }\n\n    private addAllSubscriptionListeners(): void {\n        if (!this.eventSource) {\n            return;\n        }\n\n        this.removeAllSubscriptionListeners();\n\n        for (let topic in this.subscriptions) {\n            for (let listener of this.subscriptions[topic]) {\n                this.eventSource.addEventListener(topic, listener);\n            }\n        }\n    }\n\n    private removeAllSubscriptionListeners(): void {\n        if (!this.eventSource) {\n            return;\n        }\n\n        for (let topic in this.subscriptions) {\n            for (let listener of this.subscriptions[topic]) {\n                this.eventSource.removeEventListener(topic, listener);\n            }\n        }\n    }\n\n    private async connect(): Promise<void> {\n        if (this.reconnectAttempts > 0)  {\n            // immediately resolve the promise to avoid indefinitely\n            // blocking the client during reconnection\n            return;\n        }\n\n        return new Promise((resolve, reject) => {\n            this.pendingConnects.push({ resolve, reject });\n\n            if (this.pendingConnects.length > 1) {\n                // all promises will be resolved once the connection is established\n                return;\n            }\n\n            this.initConnect();\n        })\n    }\n\n    private initConnect() {\n        this.disconnect(true);\n\n        // wait up to 15s for connect\n        clearTimeout(this.connectTimeoutId);\n        this.connectTimeoutId = setTimeout(() => {\n            this.connectErrorHandler(new Error(\"EventSource connect took too long.\"));\n        }, this.maxConnectTimeout);\n\n        this.eventSource = new EventSource(this.client.buildUrl('/api/realtime'))\n\n        this.eventSource.onerror = (_) => {\n            this.connectErrorHandler(new Error(\"Failed to establish realtime connection.\"));\n        };\n\n        this.eventSource.addEventListener('PB_CONNECT', (e) => {\n            const msgEvent = (e as MessageEvent);\n            this.clientId = msgEvent?.lastEventId;\n\n            this.submitSubscriptions()\n            .then(async () => {\n                let retries = 3;\n                while (this.hasUnsentSubscriptions() && retries > 0) {\n                    retries--;\n                    // resubscribe to ensure that the latest topics are submitted\n                    //\n                    // This is needed because missed topics could happen on reconnect\n                    // if after the pending sent `submitSubscriptions()` call another `subscribe()`\n                    // was made before the submit was able to complete.\n                    await this.submitSubscriptions();\n                }\n            }).then(() => {\n                for (let p of this.pendingConnects) {\n                    p.resolve();\n                }\n\n                // reset connect meta\n                this.pendingConnects = [];\n                this.reconnectAttempts = 0;\n                clearTimeout(this.reconnectTimeoutId);\n                clearTimeout(this.connectTimeoutId);\n            }).catch((err) => {\n                this.clientId = \"\";\n                this.connectErrorHandler(err);\n            });\n        });\n    }\n\n    private hasUnsentSubscriptions(): boolean {\n        const latestTopics = this.getNonEmptySubscriptionTopics();\n        if (latestTopics.length != this.lastSentTopics.length) {\n            return true;\n        }\n\n        for (const t of latestTopics) {\n            if (!this.lastSentTopics.includes(t)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private connectErrorHandler(err: any) {\n        clearTimeout(this.connectTimeoutId);\n        clearTimeout(this.reconnectTimeoutId);\n\n        if (\n            // wasn't previously connected -> direct reject\n            (!this.clientId && !this.reconnectAttempts) ||\n            // was previously connected but the max reconnection limit has been reached\n            this.reconnectAttempts > this.maxReconnectAttempts\n        ) {\n            for (let p of this.pendingConnects) {\n                p.reject(new ClientResponseError(err));\n            }\n            this.pendingConnects = [];\n            this.disconnect();\n            return;\n        }\n\n        // otherwise -> reconnect in the background\n        this.disconnect(true);\n        const timeout = this.predefinedReconnectIntervals[this.reconnectAttempts] || this.predefinedReconnectIntervals[this.predefinedReconnectIntervals.length - 1];\n        this.reconnectAttempts++;\n        this.reconnectTimeoutId = setTimeout(() => {\n            this.initConnect();\n        }, timeout);\n    }\n\n    private disconnect(fromReconnect = false): void {\n        clearTimeout(this.connectTimeoutId);\n        clearTimeout(this.reconnectTimeoutId);\n        this.removeAllSubscriptionListeners();\n        this.client.cancelRequest(this.getSubscriptionsCancelKey());\n        this.eventSource?.close();\n        this.eventSource = null;\n        this.clientId = \"\";\n\n        if (!fromReconnect) {\n            this.reconnectAttempts = 0;\n\n            // resolve any remaining connect promises\n            //\n            // this is done to avoid unnecessary throwing errors in case\n            // unsubscribe is called before the pending connect promises complete\n            // (see https://github.com/pocketbase/pocketbase/discussions/2897#discussioncomment-6423818)\n            for (let p of this.pendingConnects) {\n                p.resolve();\n            }\n            this.pendingConnects = [];\n        }\n    }\n}\n", "import Client from '@/Client';\nimport { CrudService } from '@/services/utils/CrudService';\nimport { RealtimeService, UnsubscribeFunc } from '@/services/RealtimeService';\nimport { ClientResponseError } from '@/ClientResponseError';\nimport { ListResult, RecordModel, ExternalAuthModel } from '@/services/utils/dtos';\nimport {\n    SendOptions,\n    CommonOptions,\n    RecordOptions,\n    RecordListOptions,\n    RecordFullListOptions,\n} from '@/services/utils/options';\nimport { normalizeLegacyOptionsArgs } from '@/services/utils/legacy';\n\nexport interface RecordAuthResponse<T = RecordModel> {\n    /**\n     * The signed PocketBase auth record.\n     */\n    record: T;\n\n    /**\n     * The PocketBase record auth token.\n     *\n     * If you are looking for the OAuth2 access and refresh tokens\n     * they are available under the `meta.accessToken` and `meta.refreshToken` props.\n     */\n    token: string;\n\n    /**\n     * Auth meta data usually filled when OAuth2 is used.\n     */\n    meta?: {[key: string]: any};\n}\n\nexport interface AuthProviderInfo {\n    name:                string;\n    state:               string;\n    codeVerifier:        string;\n    codeChallenge:       string;\n    codeChallengeMethod: string;\n    authUrl:             string;\n}\n\nexport interface AuthMethodsList {\n    usernamePassword: boolean;\n    emailPassword:    boolean;\n    authProviders:    Array<AuthProviderInfo>;\n}\n\nexport interface RecordSubscription<T = RecordModel> {\n    action: string; // eg. create, update, delete\n    record: T;\n}\n\nexport type OAuth2UrlCallback = (url: string) => void|Promise<void>;\n\nexport interface OAuth2AuthConfig extends SendOptions {\n    // the name of the OAuth2 provider (eg. \"google\")\n    provider: string;\n\n    // custom scopes to overwrite the default ones\n    scopes?: Array<string>;\n\n    // optional record create data\n    createData?: {[key: string]: any};\n\n    // optional callback that is triggered after the OAuth2 sign-in/sign-up url generation\n    urlCallback?: OAuth2UrlCallback;\n\n    // optional query params to send with the PocketBase auth request (eg. fields, expand, etc.)\n    query?: RecordOptions;\n}\n\nexport class RecordService extends CrudService<RecordModel> {\n    readonly collectionIdOrName: string;\n\n    constructor(client: Client, collectionIdOrName: string) {\n        super(client);\n\n        this.collectionIdOrName = collectionIdOrName;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    get baseCrudPath(): string {\n        return this.baseCollectionPath + '/records';\n    }\n\n    /**\n     * Returns the current collection service base path.\n     */\n    get baseCollectionPath(): string {\n        return '/api/collections/' + encodeURIComponent(this.collectionIdOrName);\n    }\n\n    // ---------------------------------------------------------------\n    // Realtime handlers\n    // ---------------------------------------------------------------\n\n    /**\n     * @deprecated Use subscribe(recordId, callback) instead.\n     *\n     * Subscribe to the realtime changes of a single record in the collection.\n     */\n    async subscribeOne<T = RecordModel>(recordId: string, callback: (data: RecordSubscription<T>) => void): Promise<UnsubscribeFunc> {\n        console.warn(\"PocketBase: subscribeOne(recordId, callback) is deprecated. Please replace it with subscribe(recordId, callback).\");\n        return this.client.realtime.subscribe(this.collectionIdOrName + \"/\" + recordId, callback);\n    }\n\n    /**\n     * @deprecated This form of subscribe is deprecated. Please use `subscribe(\"*\", callback)`.\n     */\n    async subscribe<T = RecordModel>(callback: (data: RecordSubscription<T>) => void): Promise<UnsubscribeFunc>\n\n    /**\n     * Subscribe to realtime changes to the specified topic (\"*\" or record id).\n     *\n     * If `topic` is the wildcard \"*\", then this method will subscribe to\n     * any record changes in the collection.\n     *\n     * If `topic` is a record id, then this method will subscribe only\n     * to changes of the specified record id.\n     *\n     * It's OK to subscribe multiple times to the same topic.\n     * You can use the returned `UnsubscribeFunc` to remove only a single subscription.\n     * Or use `unsubscribe(topic)` if you want to remove all subscriptions attached to the topic.\n     */\n    async subscribe<T = RecordModel>(topic: string, callback: (data: RecordSubscription<T>) => void): Promise<UnsubscribeFunc>\n\n    async subscribe<T = RecordModel>(\n        topicOrCallback: string|((data: RecordSubscription<T>) => void),\n        callback?: (data: RecordSubscription<T>) => void\n    ): Promise<UnsubscribeFunc> {\n        if (typeof topicOrCallback === 'function') {\n            console.warn(\"PocketBase: subscribe(callback) is deprecated. Please replace it with subscribe('*', callback).\");\n            return this.client.realtime.subscribe(this.collectionIdOrName, topicOrCallback);\n        }\n\n        if (!callback) {\n            throw new Error(\"Missing subscription callback.\");\n        }\n\n        if (topicOrCallback === \"\") {\n            throw new Error(\"Missing topic.\");\n        }\n\n        let topic = this.collectionIdOrName;\n        if (topicOrCallback !== \"*\") {\n            topic += ('/' + topicOrCallback);\n        }\n\n        return this.client.realtime.subscribe(topic, callback)\n    }\n\n    /**\n     * Unsubscribe from all subscriptions of the specified topic\n     * (\"*\" or record id).\n     *\n     * If `topic` is not set, then this method will unsubscribe from\n     * all subscriptions associated to the current collection.\n     */\n    async unsubscribe(topic?: string): Promise<void> {\n        // unsubscribe wildcard topic\n        if (topic === \"*\") {\n            return this.client.realtime.unsubscribe(this.collectionIdOrName);\n        }\n\n        // unsubscribe recordId topic\n        if (topic) {\n            return this.client.realtime.unsubscribe(this.collectionIdOrName + \"/\" + topic);\n        }\n\n        // unsubscribe from everything related to the collection\n        return this.client.realtime.unsubscribeByPrefix(this.collectionIdOrName);\n    }\n\n    // ---------------------------------------------------------------\n    // Crud handers\n    // ---------------------------------------------------------------\n    /**\n     * @inheritdoc\n     */\n    getFullList<T = RecordModel>(options?: RecordFullListOptions): Promise<Array<T>>\n\n    /**\n     * @inheritdoc\n     */\n    getFullList<T = RecordModel>(batch?: number, options?: RecordListOptions): Promise<Array<T>>\n\n    /**\n     * @inheritdoc\n     */\n    getFullList<T = RecordModel>(batchOrOptions?: number|RecordFullListOptions, options?: RecordListOptions): Promise<Array<T>> {\n        if (typeof batchOrOptions == \"number\") {\n            return super.getFullList<T>(batchOrOptions, options);\n        }\n\n        const params = Object.assign({}, batchOrOptions, options);\n\n        return super.getFullList<T>(params);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    getList<T = RecordModel>(page = 1, perPage = 30, options?: RecordListOptions): Promise<ListResult<T>> {\n        return super.getList<T>(page, perPage, options);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    getFirstListItem<T = RecordModel>(filter: string, options?: RecordListOptions): Promise<T> {\n        return super.getFirstListItem<T>(filter, options);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    getOne<T = RecordModel>(id: string, options?: RecordOptions): Promise<T> {\n        return super.getOne<T>(id, options);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    create<T = RecordModel>(bodyParams?: {[key:string]:any}|FormData, options?: RecordOptions): Promise<T> {\n        return super.create<T>(bodyParams, options);\n    }\n\n    /**\n     * @inheritdoc\n     *\n     * If the current `client.authStore.model` matches with the updated id, then\n     * on success the `client.authStore.model` will be updated with the result.\n     */\n    update<T = RecordModel>(id: string, bodyParams?: {[key:string]:any}|FormData, options?: RecordOptions): Promise<T> {\n        return super.update<RecordModel>(id, bodyParams, options).then((item) => {\n            if (\n                // is record auth\n                this.client.authStore.model?.id === item?.id &&\n                (\n                    this.client.authStore.model?.collectionId === this.collectionIdOrName ||\n                    this.client.authStore.model?.collectionName === this.collectionIdOrName\n                )\n            ) {\n                this.client.authStore.save(this.client.authStore.token, item);\n            }\n\n            return item as any as T;\n        });\n    }\n\n    /**\n     * @inheritdoc\n     *\n     * If the current `client.authStore.model` matches with the deleted id,\n     * then on success the `client.authStore` will be cleared.\n     */\n    delete(id: string, options?: CommonOptions): Promise<boolean> {\n        return super.delete(id, options).then((success) => {\n            if (\n                success &&\n                // is record auth\n                this.client.authStore.model?.id === id &&\n                (\n                    this.client.authStore.model?.collectionId === this.collectionIdOrName ||\n                    this.client.authStore.model?.collectionName === this.collectionIdOrName\n                )\n            ) {\n                this.client.authStore.clear();\n            }\n\n            return success;\n        });\n    }\n\n    // ---------------------------------------------------------------\n    // Auth handlers\n    // ---------------------------------------------------------------\n\n    /**\n     * Prepare successful collection authorization response.\n     */\n    protected authResponse<T = RecordModel>(responseData: any): RecordAuthResponse<T> {\n        const record = this.decode(responseData?.record || {});\n\n        this.client.authStore.save(responseData?.token, record);\n\n        return Object.assign({}, responseData, {\n            // normalize common fields\n            'token':  responseData?.token || '',\n            'record': record as any as T,\n        });\n    }\n\n    /**\n     * Returns all available collection auth methods.\n     */\n    listAuthMethods(options?: CommonOptions): Promise<AuthMethodsList> {\n        options = Object.assign({\n            'method': 'GET',\n        }, options);\n\n        return this.client.send(this.baseCollectionPath + '/auth-methods', options)\n            .then((responseData: any) => {\n                return Object.assign({}, responseData, {\n                    // normalize common fields\n                    'usernamePassword': !!responseData?.usernamePassword,\n                    'emailPassword':    !!responseData?.emailPassword,\n                    'authProviders':    Array.isArray(responseData?.authProviders) ? responseData?.authProviders : [],\n                });\n            });\n    }\n\n    /**\n     * Authenticate a single auth collection record via its username/email and password.\n     *\n     * On success, this method also automatically updates\n     * the client's AuthStore data and returns:\n     * - the authentication token\n     * - the authenticated record model\n     */\n    authWithPassword<T = RecordModel>(usernameOrEmail: string, password: string, options?: RecordOptions): Promise<RecordAuthResponse<T>>\n\n    /**\n     * @deprecated\n     * Consider using authWithPassword(usernameOrEmail, password, options?).\n     */\n    authWithPassword<T = RecordModel>(usernameOrEmail: string, password: string, body?: any, query?: any): Promise<RecordAuthResponse<T>>\n\n    authWithPassword<T = RecordModel>(usernameOrEmail: string, password: string, bodyOrOptions?: any, query?: any): Promise<RecordAuthResponse<T>> {\n        let options: any = {\n            'method': 'POST',\n            'body': {\n                'identity': usernameOrEmail,\n                'password': password,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            'This form of authWithPassword(usernameOrEmail, pass, body?, query?) is deprecated. Consider replacing it with authWithPassword(usernameOrEmail, pass, options?).',\n            options,\n            bodyOrOptions,\n            query\n        );\n\n        return this.client.send(this.baseCollectionPath + '/auth-with-password', options)\n            .then((data) => this.authResponse<T>(data));\n    }\n\n    /**\n     * Authenticate a single auth collection record with OAuth2 code.\n     *\n     * If you don't have an OAuth2 code you may also want to check `authWithOAuth2` method.\n     *\n     * On success, this method also automatically updates\n     * the client's AuthStore data and returns:\n     * - the authentication token\n     * - the authenticated record model\n     * - the OAuth2 account data (eg. name, email, avatar, etc.)\n     */\n    authWithOAuth2Code<T = RecordModel>(\n        provider: string,\n        code: string,\n        codeVerifier: string,\n        redirectUrl: string,\n        createData?: {[key:string]:any},\n        options?: RecordOptions,\n    ): Promise<RecordAuthResponse<T>>\n\n    /**\n     * @deprecated\n     * Consider using authWithOAuth2Code(provider, code, codeVerifier, redirectUrl, createdData, options?).\n     */\n    authWithOAuth2Code<T = RecordModel>(\n        provider: string,\n        code: string,\n        codeVerifier: string,\n        redirectUrl: string,\n        createData?: {[key:string]:any},\n        body?: any,\n        query?: any\n    ): Promise<RecordAuthResponse<T>>\n\n    authWithOAuth2Code<T = RecordModel>(\n        provider: string,\n        code: string,\n        codeVerifier: string,\n        redirectUrl: string,\n        createData?: {[key:string]:any},\n        bodyOrOptions?: any,\n        query?: any\n    ): Promise<RecordAuthResponse<T>> {\n        let options: any = {\n            'method': 'POST',\n            'body': {\n                'provider':     provider,\n                'code':         code,\n                'codeVerifier': codeVerifier,\n                'redirectUrl':  redirectUrl,\n                'createData':   createData,\n            },\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            'This form of authWithOAuth2Code(provider, code, codeVerifier, redirectUrl, createData?, body?, query?) is deprecated. Consider replacing it with authWithOAuth2Code(provider, code, codeVerifier, redirectUrl, createData?, options?).',\n            options,\n            bodyOrOptions,\n            query\n        );\n\n        return this.client.send(this.baseCollectionPath + '/auth-with-oauth2', options)\n            .then((data) => this.authResponse<T>(data));\n    }\n\n    /**\n     * @deprecated This form of authWithOAuth2 is deprecated.\n     *\n     * Please use `authWithOAuth2Code()` OR its simplified realtime version\n     * as shown in https://pocketbase.io/docs/authentication/#oauth2-integration.\n     */\n    async authWithOAuth2<T = RecordModel>(\n        provider: string,\n        code: string,\n        codeVerifier: string,\n        redirectUrl: string,\n        createData?: {[key: string]: any},\n        bodyParams?: {[key: string]: any},\n        queryParams?: RecordOptions,\n    ): Promise<RecordAuthResponse<T>>\n\n    /**\n     * Authenticate a single auth collection record with OAuth2\n     * **without custom redirects, deeplinks or even page reload**.\n     *\n     * This method initializes a one-off realtime subscription and will\n     * open a popup window with the OAuth2 vendor page to authenticate.\n     * Once the external OAuth2 sign-in/sign-up flow is completed, the popup\n     * window will be automatically closed and the OAuth2 data sent back\n     * to the user through the previously established realtime connection.\n     *\n     * You can specify an optional `urlCallback` prop to customize\n     * the default url `window.open` behavior.\n     *\n     * On success, this method also automatically updates\n     * the client's AuthStore data and returns:\n     * - the authentication token\n     * - the authenticated record model\n     * - the OAuth2 account data (eg. name, email, avatar, etc.)\n     *\n     * Example:\n     *\n     * ```js\n     * const authData = await pb.collection(\"users\").authWithOAuth2({\n     *     provider: \"google\",\n     * })\n     * ```\n     *\n     * _Site-note_: when creating the OAuth2 app in the provider dashboard\n     * you have to configure `https://yourdomain.com/api/oauth2-redirect`\n     * as redirect URL.\n     */\n    async authWithOAuth2<T = RecordModel>(options: OAuth2AuthConfig): Promise<RecordAuthResponse<T>>\n\n    async authWithOAuth2<T = RecordModel>(...args: any): Promise<RecordAuthResponse<T>> {\n        // fallback to legacy format\n        if (args.length > 1 || typeof args?.[0] === 'string') {\n            console.warn(\"PocketBase: This form of authWithOAuth2() is deprecated and may get removed in the future. Please replace with authWithOAuth2Code() OR use the authWithOAuth2() realtime form as shown in https://pocketbase.io/docs/authentication/#oauth2-integration.\");\n            return this.authWithOAuth2Code<T>(\n                args?.[0] || '',\n                args?.[1] || '',\n                args?.[2] || '',\n                args?.[3] || '',\n                args?.[4] || {},\n                args?.[5] || {},\n                args?.[6] || {},\n            );\n        }\n\n        const config = args?.[0] || {};\n\n        const authMethods = await this.listAuthMethods();\n\n        const provider = authMethods.authProviders.find((p) => p.name === config.provider);\n        if (!provider) {\n            throw new ClientResponseError(new Error(`Missing or invalid provider \"${config.provider}\".`));\n        }\n\n        const redirectUrl = this.client.buildUrl('/api/oauth2-redirect');\n\n        // initialize a one-off realtime service\n        const realtime = new RealtimeService(this.client);\n\n        // open a new popup window in case config.urlCallback is not set\n        //\n        // note: it is opened before the async call due to Safari restrictions\n        // (see https://github.com/pocketbase/pocketbase/discussions/2429#discussioncomment-5943061)\n        let eagerDefaultPopup: Window|null = null;\n        if (!config.urlCallback) {\n            eagerDefaultPopup = openBrowserPopup(undefined);\n        }\n\n        function cleanup() {\n            eagerDefaultPopup?.close();\n            realtime.unsubscribe();\n        }\n\n        return new Promise(async (resolve, reject) => {\n            try {\n                await realtime.subscribe('@oauth2', async (e) => {\n                    const oldState = realtime.clientId;\n\n                    try {\n                        if (!e.state || oldState !== e.state) {\n                            throw new Error(\"State parameters don't match.\");\n                        }\n\n                        // clear the non SendOptions props\n                        const options = Object.assign({}, config);\n                        delete options.provider;\n                        delete options.scopes;\n                        delete options.createData;\n                        delete options.urlCallback;\n\n                        const authData = await this.authWithOAuth2Code<T>(\n                            provider.name,\n                            e.code,\n                            provider.codeVerifier,\n                            redirectUrl,\n                            config.createData,\n                            options,\n                        );\n\n                        resolve(authData);\n                    } catch (err) {\n                        reject(new ClientResponseError(err));\n                    }\n\n                    cleanup();\n                });\n\n                const replacements: {[key: string]: any} = {\n                    \"state\": realtime.clientId,\n                }\n                if (config.scopes?.length) {\n                    replacements[\"scope\"] = config.scopes.join(\" \");\n                }\n\n                const url = this._replaceQueryParams(provider.authUrl + redirectUrl, replacements);\n\n                let urlCallback = config.urlCallback || function (url: string) {\n                    if (eagerDefaultPopup) {\n                       eagerDefaultPopup.location.href = url;\n                    } else {\n                        // it could have been blocked due to its empty initial url,\n                        // try again...\n                        eagerDefaultPopup = openBrowserPopup(url);\n                    }\n                }\n\n                await urlCallback(url);\n            } catch (err) {\n                cleanup();\n                reject(new ClientResponseError(err));\n            }\n        });\n    }\n\n    /**\n     * Refreshes the current authenticated record instance and\n     * returns a new token and record data.\n     *\n     * On success this method also automatically updates the client's AuthStore.\n     */\n    authRefresh<T = RecordModel>(options?: RecordOptions): Promise<RecordAuthResponse<T>>\n\n    /**\n     * @deprecated\n     * Consider using authRefresh(options?).\n     */\n    authRefresh<T = RecordModel>(body?: any, query?: any): Promise<RecordAuthResponse<T>>\n\n    authRefresh<T = RecordModel>(bodyOrOptions?: any, query?: any): Promise<RecordAuthResponse<T>> {\n        let options: any = {\n            'method': 'POST',\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            'This form of authRefresh(body?, query?) is deprecated. Consider replacing it with authRefresh(options?).',\n            options,\n            bodyOrOptions,\n            query\n        );\n\n        return this.client.send(this.baseCollectionPath + '/auth-refresh', options)\n            .then((data) => this.authResponse<T>(data));\n    }\n\n    /**\n     * Sends auth record password reset request.\n     */\n    requestPasswordReset(email: string, options?: CommonOptions): Promise<boolean>\n\n    /**\n     * @deprecated\n     * Consider using requestPasswordReset(email, options?).\n     */\n    requestPasswordReset(email: string, body?: any, query?: any): Promise<boolean>\n\n    requestPasswordReset(email: string, bodyOrOptions?: any, query?: any): Promise<boolean> {\n        let options: any = {\n            'method': 'POST',\n            'body': {\n                'email': email,\n            }\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            'This form of requestPasswordReset(email, body?, query?) is deprecated. Consider replacing it with requestPasswordReset(email, options?).',\n            options,\n            bodyOrOptions,\n            query\n        );\n\n        return this.client.send(this.baseCollectionPath + '/request-password-reset', options).then(() => true);\n    }\n\n    /**\n     * Confirms auth record password reset request.\n     */\n    confirmPasswordReset(\n        passwordResetToken: string,\n        password: string,\n        passwordConfirm: string,\n        options?: CommonOptions,\n    ): Promise<boolean>\n\n    /**\n     * @deprecated\n     * Consider using confirmPasswordReset(passwordResetToken, password, passwordConfirm, options?).\n     */\n    confirmPasswordReset(\n        passwordResetToken: string,\n        password: string,\n        passwordConfirm: string,\n        body?: any,\n        query?: any,\n    ): Promise<boolean>\n\n    confirmPasswordReset(\n        passwordResetToken: string,\n        password: string,\n        passwordConfirm: string,\n        bodyOrOptions?: any,\n        query?: any,\n    ): Promise<boolean> {\n        let options: any = {\n            'method': 'POST',\n            'body': {\n                'token':           passwordResetToken,\n                'password':        password,\n                'passwordConfirm': passwordConfirm,\n            }\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            'This form of confirmPasswordReset(token, password, passwordConfirm, body?, query?) is deprecated. Consider replacing it with confirmPasswordReset(token, password, passwordConfirm, options?).',\n            options,\n            bodyOrOptions,\n            query\n        );\n\n        return this.client.send(this.baseCollectionPath + '/confirm-password-reset', options)\n            .then(() => true);\n    }\n\n    /**\n     * Sends auth record verification email request.\n     */\n    requestVerification(email: string, options?: CommonOptions): Promise<boolean>\n\n    /**\n     * @deprecated\n     * Consider using requestVerification(email, options?).\n     */\n    requestVerification(email: string, body?: any, query?: any): Promise<boolean>\n\n    requestVerification(email: string, bodyOrOptions?: any, query?: any): Promise<boolean> {\n        let options: any = {\n            'method': 'POST',\n            'body': {\n                'email': email,\n            }\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            'This form of requestVerification(email, body?, query?) is deprecated. Consider replacing it with requestVerification(email, options?).',\n            options,\n            bodyOrOptions,\n            query\n        );\n\n        return this.client.send(this.baseCollectionPath + '/request-verification', options)\n            .then(() => true);\n    }\n\n    /**\n     * Confirms auth record email verification request.\n     */\n    confirmVerification(verificationToken: string, options?: CommonOptions): Promise<boolean>\n\n    /**\n     * @deprecated\n     * Consider using confirmVerification(verificationToken, options?).\n     */\n    confirmVerification(verificationToken: string, body?: any, query?: any): Promise<boolean>\n\n    confirmVerification(verificationToken: string, bodyOrOptions?: any, query?: any): Promise<boolean> {\n        let options: any = {\n            'method': 'POST',\n            'body': {\n                'token': verificationToken,\n            }\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            'This form of confirmVerification(token, body?, query?) is deprecated. Consider replacing it with confirmVerification(token, options?).',\n            options,\n            bodyOrOptions,\n            query\n        );\n\n        return this.client.send(this.baseCollectionPath + '/confirm-verification', options)\n            .then(() => true);\n    }\n\n    /**\n     * Sends an email change request to the authenticated record model.\n     */\n    requestEmailChange(newEmail: string, options?: CommonOptions): Promise<boolean>\n\n    /**\n     * @deprecated\n     * Consider using requestEmailChange(newEmail, options?).\n     */\n    requestEmailChange(newEmail: string, body?: any, query?: any): Promise<boolean>\n\n    requestEmailChange(newEmail: string, bodyOrOptions?: any, query?: any): Promise<boolean> {\n        let options: any = {\n            'method': 'POST',\n            'body': {\n                'newEmail': newEmail,\n            }\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            'This form of requestEmailChange(newEmail, body?, query?) is deprecated. Consider replacing it with requestEmailChange(newEmail, options?).',\n            options,\n            bodyOrOptions,\n            query\n        );\n\n        return this.client.send(this.baseCollectionPath + '/request-email-change', options)\n            .then(() => true);\n    }\n\n    /**\n     * Confirms auth record's new email address.\n     */\n    confirmEmailChange(emailChangeToken: string, password: string, options?: CommonOptions): Promise<boolean>\n\n\n    /**\n     * @deprecated\n     * Consider using confirmEmailChange(emailChangeToken, password, options?).\n     */\n    confirmEmailChange(emailChangeToken: string, password: string, body?: any, query?: any): Promise<boolean>\n\n    confirmEmailChange(emailChangeToken: string, password: string, bodyOrOptions?: any, query?: any): Promise<boolean> {\n        let options: any = {\n            'method': 'POST',\n            'body': {\n                'token':    emailChangeToken,\n                'password': password,\n            }\n        };\n\n        options = normalizeLegacyOptionsArgs(\n            'This form of confirmEmailChange(token, password, body?, query?) is deprecated. Consider replacing it with confirmEmailChange(token, password, options?).',\n            options,\n            bodyOrOptions,\n            query\n        );\n\n        return this.client.send(this.baseCollectionPath + '/confirm-email-change', options)\n            .then(() => true);\n    }\n\n    /**\n     * Lists all linked external auth providers for the specified auth record.\n     */\n    listExternalAuths(recordId: string, options?: CommonOptions): Promise<Array<ExternalAuthModel>> {\n        options = Object.assign({\n            'method': 'GET',\n        }, options);\n\n        return this.client.send(this.baseCrudPath + '/' + encodeURIComponent(recordId) + '/external-auths', options);\n    }\n\n    /**\n     * Unlink a single external auth provider from the specified auth record.\n     */\n    unlinkExternalAuth(recordId: string, provider: string, options?: CommonOptions): Promise<boolean> {\n        options = Object.assign({\n            'method': 'DELETE',\n        }, options);\n\n        return this.client.send(this.baseCrudPath + '/' + encodeURIComponent(recordId) + '/external-auths/' + encodeURIComponent(provider), options)\n            .then(() => true);\n    }\n\n    // ---------------------------------------------------------------\n\n    // very rudimentary url query params replacement because at the moment\n    // URL (and URLSearchParams) doesn't seem to be fully supported in React Native\n    //\n    // note: for details behind some of the decode/encode parsing check https://unixpapa.com/js/querystring.html\n    private _replaceQueryParams(url: string, replacements: {[key: string]: any} = {}): string {\n        let urlPath = url\n        let query = \"\";\n\n        const queryIndex = url.indexOf(\"?\");\n        if (queryIndex >= 0) {\n            urlPath = url.substring(0, url.indexOf(\"?\"));\n            query = url.substring(url.indexOf(\"?\") + 1);\n        }\n\n        const parsedParams: {[key: string]: string} = {};\n\n        // parse the query parameters\n        const rawParams = query.split(\"&\");\n        for (const param of rawParams) {\n            if (param == \"\") {\n                continue\n            }\n\n            const pair = param.split(\"=\");\n            parsedParams[decodeURIComponent(pair[0].replace(/\\+/g,' '))] = decodeURIComponent((pair[1] || \"\").replace(/\\+/g,' '));\n        }\n\n        // apply the replacements\n        for (let key in replacements) {\n            if (!replacements.hasOwnProperty(key)) {\n                continue;\n            }\n\n            if (replacements[key] == null) {\n                delete parsedParams[key];\n            } else {\n                parsedParams[key] = replacements[key];\n            }\n        }\n\n        // construct back the full query string\n        query = \"\";\n        for (let key in parsedParams) {\n            if (!parsedParams.hasOwnProperty(key)) {\n                continue;\n            }\n\n            if (query != \"\") {\n                query += \"&\";\n            }\n\n            query += encodeURIComponent(key.replace(/%20/g,'+')) + \"=\" + encodeURIComponent(parsedParams[key].replace(/%20/g,'+'));\n        }\n\n        return query != \"\" ? (urlPath + \"?\" + query) : urlPath;\n    }\n}\n\nfunction openBrowserPopup(url?: string): Window|null {\n    if (typeof window === \"undefined\" || !window?.open) {\n        throw new ClientResponseError(new Error(`Not in a browser context - please pass a custom urlCallback function.`));\n    }\n\n    let width  = 1024;\n    let height = 768;\n\n    let windowWidth  = window.innerWidth;\n    let windowHeight = window.innerHeight;\n\n    // normalize window size\n    width  = width > windowWidth ? windowWidth : width;\n    height = height > windowHeight ? windowHeight : height;\n\n    let left = (windowWidth / 2) - (width / 2);\n    let top  = (windowHeight / 2) - (height / 2);\n\n    // note: we don't use the noopener and noreferrer attributes since\n    // for some reason browser blocks such windows then url is undefined/blank\n    return window.open(\n        url,\n        'popup_window',\n        'width='+width+',height='+height+',top='+top+',left='+left+',resizable,menubar=no'\n    );\n}\n", "import { CrudService }     from '@/services/utils/CrudService';\nimport { CollectionModel } from '@/services/utils/dtos';\nimport { CommonOptions }   from '@/services/utils/options';\n\nexport class CollectionService extends CrudService<CollectionModel> {\n    /**\n     * @inheritdoc\n     */\n    get baseCrudPath(): string {\n        return '/api/collections';\n    }\n\n    /**\n     * Imports the provided collections.\n     *\n     * If `deleteMissing` is `true`, all local collections and schema fields,\n     * that are not present in the imported configuration, WILL BE DELETED\n     * (including their related records data)!\n     */\n    async import(\n        collections: Array<CollectionModel>,\n        deleteMissing: boolean = false,\n        options?: CommonOptions,\n    ): Promise<true> {\n        options = Object.assign({\n            'method': 'PUT',\n            'body': {\n                'collections':   collections,\n                'deleteMissing': deleteMissing,\n            }\n        }, options);\n\n        return this.client.send(this.baseCrudPath + '/import', options)\n            .then(() => true);\n    }\n}\n", "import { BaseService } from '@/services/utils/BaseService';\nimport { ListResult, LogRequestModel }  from '@/services/utils/dtos';\nimport {\n    CommonOptions,\n    ListOptions,\n    LogStatsOptions,\n} from '@/services/utils/options';\n\nexport interface HourlyStats {\n    total: number;\n    date:  string;\n}\n\nexport class LogService extends BaseService {\n    /**\n     * Returns paginated logged requests list.\n     */\n    getRequestsList(page = 1, perPage = 30, options?: ListOptions): Promise<ListResult<LogRequestModel>> {\n        options = Object.assign({'method': 'GET'}, options);\n\n        options.query = Object.assign({\n            'page':    page,\n            'perPage': perPage,\n        }, options.query);\n\n        return this.client.send('/api/logs/requests', options);\n    }\n\n    /**\n     * Returns a single logged request by its id.\n     */\n    getRequest(id: string, options?: CommonOptions): Promise<LogRequestModel> {\n        options = Object.assign({\n            'method': 'GET',\n        }, options);\n\n        return this.client.send('/api/logs/requests/' + encodeURIComponent(id), options);\n    }\n\n    /**\n     * Returns request logs statistics.\n     */\n    getRequestsStats(options?: LogStatsOptions): Promise<Array<HourlyStats>> {\n        options = Object.assign({\n            'method': 'GET',\n        }, options);\n\n        return this.client.send('/api/logs/requests/stats', options);\n    }\n}\n", "import { BaseService }   from '@/services/utils/BaseService';\nimport { CommonOptions } from '@/services/utils/options';\n\nexport interface HealthCheckResponse {\n    code:    number;\n    message: string;\n    data:    {[key: string]: any};\n}\n\nexport class HealthService extends BaseService {\n    /**\n     * Checks the health status of the api.\n     */\n    check(options?: CommonOptions): Promise<HealthCheckResponse> {\n        options = Object.assign({\n            'method': 'GET',\n        }, options);\n\n        return this.client.send('/api/health', options);\n    }\n}\n", "import { BaseService } from '@/services/utils/BaseService';\nimport { CommonOptions, FileOptions } from '@/services/utils/options';\n\nexport class FileService extends BaseService {\n    /**\n     * Builds and returns an absolute record file url for the provided filename.\n     */\n    getUrl(\n        record: {[key:string]:any},\n        filename: string,\n        queryParams: FileOptions = {}\n    ): string {\n        if (\n            !filename ||\n            !record?.id ||\n            !(record?.collectionId || record?.collectionName)\n        ) {\n            return '';\n        }\n\n        const parts = [];\n        parts.push('api')\n        parts.push('files')\n        parts.push(encodeURIComponent(record.collectionId || record.collectionName))\n        parts.push(encodeURIComponent(record.id))\n        parts.push(encodeURIComponent(filename))\n\n        let result = this.client.buildUrl(parts.join('/'));\n\n        if (Object.keys(queryParams).length) {\n            // normalize the download query param for consistency with the Dart sdk\n            if (queryParams.download === false) {\n                delete(queryParams.download);\n            }\n\n            const params = new URLSearchParams(queryParams);\n\n            result += (result.includes('?') ? '&' : '?') + params;\n        }\n\n        return result\n    }\n\n    /**\n     * Requests a new private file access token for the current auth model (admin or record).\n     */\n    getToken(options?: CommonOptions): Promise<string> {\n        options = Object.assign({\n            'method': 'POST',\n        }, options);\n\n        return this.client.send('/api/files/token', options)\n            .then((data) => data?.token || '');\n    }\n}\n", "import { BaseService }   from '@/services/utils/BaseService';\nimport { CommonOptions } from '@/services/utils/options';\n\nexport interface BackupFileInfo {\n    key:      string;\n    size:     number;\n    modified: string;\n}\n\nexport class BackupService extends BaseService {\n    /**\n     * Returns list with all available backup files.\n     */\n    getFullList(options?: CommonOptions): Promise<Array<BackupFileInfo>> {\n        options = Object.assign({\n            'method': 'GET',\n        }, options);\n\n        return this.client.send('/api/backups', options);\n    }\n\n    /**\n     * Initializes a new backup.\n     */\n    create(basename: string, options?: CommonOptions): Promise<boolean> {\n        options = Object.assign({\n            'method': 'POST',\n            'body':   {\n                'name': basename,\n            },\n        }, options);\n\n        return this.client.send('/api/backups', options)\n            .then(() => true);\n    }\n\n    /**\n     * Uploads an existing backup file.\n     *\n     * Example:\n     *\n     * ```js\n     * await pb.backups.upload({\n     *     file: new Blob([...]),\n     * });\n     * ```\n     */\n    upload(bodyParams: {[key:string]:any}|FormData, options?: CommonOptions): Promise<boolean> {\n        options = Object.assign({\n            'method': 'POST',\n            'body':   bodyParams,\n        }, options);\n\n        return this.client.send('/api/backups/upload', options)\n            .then(() => true);\n    }\n\n    /**\n     * Deletes a single backup file.\n     */\n    delete(key: string, options?: CommonOptions): Promise<boolean> {\n        options = Object.assign({\n            'method': 'DELETE',\n        }, options);\n\n        return this.client.send(`/api/backups/${encodeURIComponent(key)}`, options)\n            .then(() => true);\n    }\n\n    /**\n     * Initializes an app data restore from an existing backup.\n     */\n    restore(key: string, options?: CommonOptions): Promise<boolean> {\n        options = Object.assign({\n            'method': 'POST',\n        }, options);\n\n        return this.client.send(`/api/backups/${encodeURIComponent(key)}/restore`, options)\n            .then(() => true);\n    }\n\n    /**\n     * Builds a download url for a single existing backup using an\n     * admin file token and the backup file key.\n     *\n     * The file token can be generated via `pb.files.getToken()`.\n     */\n    getDownloadUrl(token: string, key: string): string {\n        return this.client.buildUrl(`/api/backups/${encodeURIComponent(key)}?token=${encodeURIComponent(token)}`);\n    }\n}\n", "import { ClientResponseError }      from '@/ClientResponseError';\nimport { BaseAuthStore }            from '@/stores/BaseAuthStore';\nimport { LocalAuthStore }           from '@/stores/LocalAuthStore';\nimport { SettingsService }          from '@/services/SettingsService';\nimport { AdminService }             from '@/services/AdminService';\nimport { RecordService }            from '@/services/RecordService';\nimport { CollectionService }        from '@/services/CollectionService';\nimport { LogService }               from '@/services/LogService';\nimport { RealtimeService }          from '@/services/RealtimeService';\nimport { HealthService }            from '@/services/HealthService';\nimport { FileService }              from '@/services/FileService';\nimport { BackupService }            from '@/services/BackupService';\nimport { SendOptions, FileOptions } from '@/services/utils/options';\n\n// list of known SendOptions keys (everything else is treated as query param)\nconst knownSendOptionsKeys = [\n    'requestKey',\n    '$cancelKey',\n    '$autoCancel',\n    'fetch',\n    'headers',\n    'body',\n    'query',\n    'params',\n    // ---,\n    'cache',\n    'credentials',\n    'headers',\n    'integrity',\n    'keepalive',\n    'method',\n    'mode',\n    'redirect',\n    'referrer',\n    'referrerPolicy',\n    'signal',\n    'window',\n];\n\nexport interface BeforeSendResult {\n    [key:     string]: any, // for backward compatibility\n    url?:     string,\n    options?: {[key: string]: any}\n}\n\n/**\n * PocketBase JS Client.\n */\nexport default class Client {\n    /**\n     * The base PocketBase backend url address (eg. 'http://127.0.0.1.8090').\n     */\n    baseUrl: string;\n\n    /**\n     * Hook that get triggered right before sending the fetch request,\n     * allowing you to inspect and modify the url and request options.\n     *\n     * For list of the possible options check https://developer.mozilla.org/en-US/docs/Web/API/fetch#options\n     *\n     * You can return a non-empty result object `{ url, options }` to replace the url and request options entirely.\n     *\n     * Example:\n     * ```js\n     * client.beforeSend = function (url, options) {\n     *     options.headers = Object.assign({}, options.headers, {\n     *         'X-Custom-Header': 'example',\n     *     });\n     *\n     *     return { url, options }\n     * };\n     * ```\n     */\n    beforeSend?: (url: string, options: SendOptions) => BeforeSendResult|Promise<BeforeSendResult>;\n\n    /**\n     * Hook that get triggered after successfully sending the fetch request,\n     * allowing you to inspect/modify the response object and its parsed data.\n     *\n     * Returns the new Promise resolved `data` that will be returned to the client.\n     *\n     * Example:\n     * ```js\n     * client.afterSend = function (response, data) {\n     *     if (response.status != 200) {\n     *         throw new ClientResponseError({\n     *             url:      response.url,\n     *             status:   response.status,\n     *             data:     data,\n     *         });\n     *     }\n     *\n     *     return data;\n     * };\n     * ```\n     */\n    afterSend?: (response: Response, data: any) => any;\n\n    /**\n     * Optional language code (default to `en-US`) that will be sent\n     * with the requests to the server as `Accept-Language` header.\n     */\n    lang: string;\n\n    /**\n     * A replaceable instance of the local auth store service.\n     */\n    authStore: BaseAuthStore;\n\n    /**\n     * An instance of the service that handles the **Settings APIs**.\n     */\n    readonly settings: SettingsService;\n\n    /**\n     * An instance of the service that handles the **Admin APIs**.\n     */\n    readonly admins: AdminService;\n\n    /**\n     * An instance of the service that handles the **Collection APIs**.\n     */\n    readonly collections: CollectionService;\n\n    /**\n     * An instance of the service that handles the **File APIs**.\n     */\n    readonly files: FileService;\n\n    /**\n     * An instance of the service that handles the **Log APIs**.\n     */\n    readonly logs: LogService;\n\n    /**\n     * An instance of the service that handles the **Realtime APIs**.\n     */\n    readonly realtime: RealtimeService;\n\n    /**\n     * An instance of the service that handles the **Health APIs**.\n     */\n    readonly health: HealthService;\n\n    /**\n     * An instance of the service that handles the **Backup APIs**.\n     */\n    readonly backups: BackupService;\n\n    private cancelControllers: { [key: string]: AbortController } = {};\n    private recordServices: { [key: string]: RecordService } = {};\n    private enableAutoCancellation: boolean = true;\n\n    constructor(\n        baseUrl = '/',\n        authStore?: BaseAuthStore | null,\n        lang = 'en-US',\n    ) {\n        this.baseUrl   = baseUrl;\n        this.lang      = lang;\n        this.authStore = authStore || new LocalAuthStore();\n\n        // services\n        this.admins      = new AdminService(this);\n        this.collections = new CollectionService(this);\n        this.files       = new FileService(this);\n        this.logs        = new LogService(this);\n        this.settings    = new SettingsService(this);\n        this.realtime    = new RealtimeService(this);\n        this.health      = new HealthService(this);\n        this.backups     = new BackupService(this);\n    }\n\n    /**\n     * Returns the RecordService associated to the specified collection.\n     *\n     * @param  {string} idOrName\n     * @return {RecordService}\n     */\n    collection(idOrName: string): RecordService {\n        if (!this.recordServices[idOrName]) {\n            this.recordServices[idOrName] = new RecordService(this, idOrName);\n        }\n\n        return this.recordServices[idOrName];\n    }\n\n    /**\n     * Globally enable or disable auto cancellation for pending duplicated requests.\n     */\n    autoCancellation(enable: boolean): Client {\n        this.enableAutoCancellation = !!enable;\n\n        return this;\n    }\n\n    /**\n     * Cancels single request by its cancellation key.\n     */\n    cancelRequest(requestKey: string): Client {\n        if (this.cancelControllers[requestKey]) {\n            this.cancelControllers[requestKey].abort();\n            delete this.cancelControllers[requestKey];\n        }\n\n        return this;\n    }\n\n    /**\n     * Cancels all pending requests.\n     */\n    cancelAllRequests(): Client {\n        for (let k in this.cancelControllers) {\n            this.cancelControllers[k].abort();\n        }\n\n        this.cancelControllers = {};\n\n        return this;\n    }\n\n    /**\n     * Legacy alias of `pb.files.getUrl()`.\n     */\n    getFileUrl(\n        record: {[key:string]:any},\n        filename: string,\n        queryParams: FileOptions = {}\n    ): string {\n        return this.files.getUrl(record, filename, queryParams);\n    }\n\n    /**\n     * Builds a full client url by safely concatenating the provided path.\n     */\n    buildUrl(path: string): string {\n        let url = this.baseUrl;\n\n        // construct an absolute base url if in a browser environment\n        if (\n            typeof window !== 'undefined' &&\n            !!window.location &&\n            !url.startsWith('https://') &&\n            !url.startsWith('http://')\n        ) {\n            url = window.location.origin?.endsWith('/') ?\n                window.location.origin.substring(0, window.location.origin.length - 1) :\n                (window.location.origin || '');\n\n            if (!this.baseUrl.startsWith('/')) {\n                url += window.location.pathname || '/';\n                url += url.endsWith('/') ? '' : '/';\n            }\n\n            url += this.baseUrl;\n        }\n\n        // concatenate the path\n        if (path) {\n            url += url.endsWith('/') ? '' : '/'; // append trailing slash if missing\n            url += path.startsWith('/') ? path.substring(1) : path;\n        }\n\n        return url;\n    }\n\n    /**\n     * Sends an api http request.\n     */\n    async send<T = any>(path: string, options: SendOptions): Promise<T> {\n        options = this.initSendOptions(path, options);\n\n        // build url + path\n        let url = this.buildUrl(path);\n\n        if (this.beforeSend) {\n            const result = Object.assign({}, await this.beforeSend(url, options));\n            if (typeof result.url !== 'undefined' || typeof result.options !== 'undefined') {\n                url = result.url || url;\n                options = result.options || options;\n            } else if (Object.keys(result).length) {\n                // legacy behavior\n                options = result as SendOptions;\n                console?.warn && console.warn('Deprecated format of beforeSend return: please use `return { url, options }`, instead of `return options`.');\n            }\n        }\n\n        // serialize the query parameters\n        if (typeof options.query !== 'undefined') {\n            const query = this.serializeQueryParams(options.query)\n            if (query) {\n                url += (url.includes('?') ? '&' : '?') + query;\n            }\n            delete options.query;\n        }\n\n        // ensures that the json body is serialized\n        if (\n            this.getHeader(options.headers, 'Content-Type') == 'application/json' &&\n            options.body && typeof options.body !== 'string'\n        ) {\n            options.body = JSON.stringify(options.body);\n        }\n\n        const fetchFunc = options.fetch || fetch;\n\n        // send the request\n        return fetchFunc(url, options)\n            .then(async (response) => {\n                let data : any = {};\n\n                try {\n                    data = await response.json();\n                } catch (_) {\n                    // all api responses are expected to return json\n                    // with the exception of the realtime event and 204\n                }\n\n                if (this.afterSend) {\n                    data = await this.afterSend(response, data);\n                }\n\n                if (response.status >= 400) {\n                    throw new ClientResponseError({\n                        url:      response.url,\n                        status:   response.status,\n                        data:     data,\n                    });\n                }\n\n                return data as T;\n            }).catch((err) => {\n                // wrap to normalize all errors\n                throw new ClientResponseError(err);\n            });\n    }\n\n    /**\n     * Shallow copy the provided object and takes care to initialize\n     * any options required to preserve the backward compatability.\n     *\n     * @param  {SendOptions} options\n     * @return {SendOptions}\n     */\n    private initSendOptions(path: string, options: SendOptions): SendOptions {\n        options = Object.assign({ method: 'GET' } as SendOptions, options)\n        options.query = options.query || {};\n\n        // auto convert the body to FormData, if needed\n        options.body = this.convertToFormDataIfNeeded(options.body);\n\n        // move unknown send options as query parameters\n        for (let key in options) {\n            if (knownSendOptionsKeys.includes(key)) {\n                continue\n            }\n\n            options.query[key] = options[key];\n            delete (options[key]);\n        }\n\n        // requestKey normalizations for backward-compatibility\n        // ---\n        options.query = Object.assign({}, options.params, options.query);\n        if (typeof options.requestKey === 'undefined') {\n            if (options.$autoCancel === false || options.query.$autoCancel === false) {\n                options.requestKey = null;\n            } else if (options.$cancelKey || options.query.$cancelKey) {\n                options.requestKey = options.$cancelKey || options.query.$cancelKey;\n            }\n        }\n        // remove the deprecated special cancellation params from the other query params\n        delete options.$autoCancel;\n        delete options.query.$autoCancel;\n        delete options.$cancelKey;\n        delete options.query.$cancelKey;\n        // ---\n\n        // add the json header, if not explicitly set\n        // (for FormData body the Content-Type header should be skipped since the boundary is autogenerated)\n        if (\n            this.getHeader(options.headers, 'Content-Type') === null &&\n            !this.isFormData(options.body)\n        ) {\n            options.headers = Object.assign({}, options.headers, {\n                'Content-Type': 'application/json',\n            });\n        }\n\n        // add Accept-Language header, if not explicitly set\n        if (this.getHeader(options.headers, 'Accept-Language') === null) {\n            options.headers = Object.assign({}, options.headers, {\n                'Accept-Language': this.lang,\n            });\n        }\n\n        // check if Authorization header can be added\n        if (\n            // has valid token\n            this.authStore.token &&\n            // auth header is not explicitly set\n            (this.getHeader(options.headers, 'Authorization') === null)\n        ) {\n            options.headers = Object.assign({}, options.headers, {\n                'Authorization': this.authStore.token,\n            });\n        }\n\n        // handle auto cancelation for duplicated pending request\n        if (this.enableAutoCancellation && options.requestKey !== null) {\n            const requestKey = options.requestKey || ((options.method || 'GET') + path);\n\n            delete options.requestKey;\n\n            // cancel previous pending requests\n            this.cancelRequest(requestKey);\n\n            const controller = new AbortController();\n            this.cancelControllers[requestKey] = controller;\n            options.signal = controller.signal;\n        }\n\n        return options\n    }\n\n    /**\n     * Converts analyzes the provided body and converts it to FormData\n     * in case a plain object with File/Blob values is used.\n     */\n    private convertToFormDataIfNeeded(body: any): any {\n        if (\n            typeof FormData === 'undefined' ||\n            typeof body === \"undefined\" ||\n            typeof body !== \"object\" ||\n            body === null ||\n            this.isFormData(body) ||\n            !this.hasBlobField(body)\n        ) {\n            return body;\n        }\n\n        const form = new FormData();\n\n        for (let key in body) {\n            const values = Array.isArray(body[key]) ? body[key] : [body[key]];\n            for (let val of values) {\n                form.append(key, val);\n            }\n        }\n\n        return form;\n    }\n\n    /**\n     * Checks if the submitted body object has at least one Blob/File field.\n     */\n    private hasBlobField(body: {[key:string]: any}): boolean {\n        for (let key in body) {\n            const values = Array.isArray(body[key]) ? body[key] : [body[key]];\n            for (let v of values) {\n                if (\n                    (typeof Blob !== 'undefined' && v instanceof Blob) ||\n                    (typeof File !== 'undefined' && v instanceof File)\n                ) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Extracts the header with the provided name in case-insensitive manner.\n     * Returns `null` if no header matching the name is found.\n     */\n    private getHeader(headers: {[key:string]:string}|undefined, name: string): string|null {\n        headers = headers || {};\n        name = name.toLowerCase();\n\n        for (let key in headers) {\n            if (key.toLowerCase() == name) {\n                return headers[key];\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Loosely checks if the specified body is a FormData instance.\n     */\n    private isFormData(body: any): boolean {\n        return body && (\n            // we are checking the constructor name because FormData\n            // is not available natively in some environments and the\n            // polyfill(s) may not be globally accessible\n            body.constructor.name === 'FormData' ||\n            // fallback to global FormData instance check\n            // note: this is needed because the constructor.name could be different in case of\n            //       custom global FormData implementation, eg. React Native on Android/iOS\n            (typeof FormData !== 'undefined' && body instanceof FormData)\n        )\n    }\n\n    /**\n     * Serializes the provided query parameters into a query string.\n     */\n    private serializeQueryParams(params: {[key: string]: any}): string {\n        const result: Array<string> = [];\n        for (const key in params) {\n            if (params[key] === null) {\n                // skip null query params\n                continue;\n            }\n\n            const value = params[key];\n            const encodedKey = encodeURIComponent(key);\n\n            if (Array.isArray(value)) {\n                // repeat array params\n                for (const v of value) {\n                    result.push(encodedKey + '=' + encodeURIComponent(v));\n                }\n            } else if (value instanceof Date) {\n                result.push(encodedKey + '=' + encodeURIComponent(value.toISOString()));\n            } else if (typeof value !== null && typeof value === 'object') {\n                result.push(encodedKey + '=' + encodeURIComponent(JSON.stringify(value)));\n            } else {\n                result.push(encodedKey + '=' + encodeURIComponent(value));\n            }\n        }\n\n        return result.join('&');\n    }\n}\n", "import { BaseAuthStore, AuthModel } from '@/stores/BaseAuthStore';\n\nexport type AsyncSaveFunc = (serializedPayload: string) => Promise<void>;\n\nexport type AsyncClearFunc = () => Promise<void>;\n\ntype queueFunc = () => Promise<void>;\n\n/**\n * AsyncAuthStore is a helper auth store implementation\n * that could be used with any external async persistent layer\n * (key-value db, local file, etc.).\n *\n * Here is an example with the React Native AsyncStorage package:\n *\n * ```\n * import AsyncStorage from \"@react-native-async-storage/async-storage\";\n * import PocketBase, { AsyncAuthStore } from \"pocketbase\";\n *\n * const store = new AsyncAuthStore({\n *     save:    async (serialized) => AsyncStorage.setItem(\"pb_auth\", serialized),\n *     initial: await AsyncStorage.getItem(\"pb_auth\"),\n * });\n *\n * const pb = new PocketBase(\"https://example.com\", store)\n * ```\n */\nexport class AsyncAuthStore extends BaseAuthStore {\n    private saveFunc: AsyncSaveFunc;\n    private clearFunc?: AsyncClearFunc;\n    private queue: Array<queueFunc> = [];\n\n    constructor(config: {\n        // The async function that is called every time\n        // when the auth store state needs to be persisted.\n        save: AsyncSaveFunc,\n\n        /// An *optional* async function that is called every time\n        /// when the auth store needs to be cleared.\n        ///\n        /// If not explicitly set, `saveFunc` with empty data will be used.\n        clear?: AsyncClearFunc,\n\n        // initial data to load into the store\n        initial?: string,\n    }) {\n        super();\n\n        this.saveFunc = config.save;\n        this.clearFunc = config.clear;\n\n        this._loadInitial(config.initial);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    save(token: string, model?: AuthModel): void {\n        super.save(token, model);\n\n        let value = '';\n        try {\n            value = JSON.stringify({token, model})\n        } catch (err) {\n            console.warn('AsyncAuthStore: failed to stringify the new state');\n        }\n\n        this._enqueue(() => this.saveFunc(value));\n    }\n\n    /**\n     * @inheritdoc\n     */\n    clear(): void {\n        super.clear();\n\n        if (this.clearFunc) {\n            this._enqueue(() => this.clearFunc!());\n        } else {\n            this._enqueue(() => this.saveFunc(\"\"));\n        }\n    }\n\n\n    /**\n     * Initializes the auth store state.\n     */\n    private _loadInitial(payload?: string) {\n        if (!payload) {\n            return; // nothing to load\n        }\n\n        try {\n            const parsed = JSON.parse(payload) || {};\n\n            this.save(parsed.token || \"\", parsed.model || null);\n        } catch (_) {}\n    }\n\n    /**\n     * Appends an async function to the queue.\n     */\n    private _enqueue(asyncCallback: () => Promise<void>) {\n        this.queue.push(asyncCallback);\n\n        if (this.queue.length == 1) {\n            this._dequeue();\n        }\n    }\n\n    /**\n     * Starts the queue processing.\n     */\n    private _dequeue() {\n        if (!this.queue.length) {\n            return;\n        }\n\n        this.queue[0]().finally(() => {\n            this.queue.shift();\n\n            if (!this.queue.length) {\n                return;\n            }\n\n            this._dequeue();\n        });\n    }\n}\n"],
  "mappings": "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",
  "names": ["ClientResponseError", "Error", "errData", "super", "this", "url", "status", "response", "isAbort", "originalError", "Object", "setPrototypeOf", "prototype", "data", "DOMException", "name", "message", "_a", "_d", "_c", "_b", "cause", "includes", "toJSON", "assign", "fieldContentRegExp", "cookieParse", "str", "options", "result", "decode", "defaultDecode", "index", "length", "eqIdx", "indexOf", "endIdx", "lastIndexOf", "key", "slice", "trim", "val", "charCodeAt", "_", "cookieSerialize", "opt", "encode", "defaultEncode", "test", "TypeError", "value", "maxAge", "isNaN", "isFinite", "Math", "floor", "domain", "path", "expires", "isDate", "toString", "call", "Date", "valueOf", "toUTCString", "httpOnly", "secure", "priority", "toLowerCase", "sameSite", "decodeURIComponent", "encodeURIComponent", "atobPolyfill", "getTokenPayload", "token", "encodedPayload", "split", "map", "c", "join", "JSON", "parse", "e", "isTokenExpired", "expirationThreshold", "payload", "keys", "exp", "now", "atob", "input", "String", "replace", "bs", "buffer", "bc", "idx", "output", "charAt", "fromCharCode", "defaultCookieKey", "BaseAuthStore", "constructor", "baseToken", "baseModel", "_onChangeCallbacks", "model", "isValid", "isAdmin", "type", "isAuthRecord", "triggerChange", "clear", "cookie", "rawData", "Array", "isArray", "save", "defaultOptions", "stringify", "resultLength", "Blob", "size", "id", "email", "extraProps", "prop", "callback", "fireImmediately", "push", "i", "splice", "LocalAuthStore", "storageKey", "storageFallback", "_bindStorageEvent", "_storageGet", "_storageSet", "_storageRemove", "window", "localStorage", "rawValue", "getItem", "normalizedVal", "setItem", "removeItem", "addEventListener", "BaseService", "client", "SettingsService", "method", "send", "bodyParams", "body", "filesystem", "then", "toEmail", "emailTemplate", "template", "clientId", "teamId", "keyId", "privateKey", "duration", "CrudService", "batchOrqueryParams", "_getFullList", "batch", "page", "perPage", "query", "baseCrudPath", "responseData", "items", "t", "item", "filter", "requestKey", "skipTotal", "getList", "code", "batchSize", "request", "__awaiter", "list", "concat", "normalizeLegacyOptionsArgs", "legacyWarn", "baseOptions", "bodyOrOptions", "hasQuery", "console", "warn", "resetAutoRefresh", "_resetAutoRefresh", "AdminService", "update", "authStore", "collectionId", "delete", "success", "admin", "password", "identity", "autoRefreshThreshold", "autoRefresh", "authData", "authResponse", "registerAutoRefresh", "threshold", "refreshFunc", "reauthenticateFunc", "oldBeforeSend", "beforeSend", "oldModel", "unsubStoreChange", "onChange", "newToken", "sendOptions", "oldToken", "headers", "authRefresh", "authWithPassword", "bind", "resetToken", "passwordConfirm", "RealtimeService", "eventSource", "subscriptions", "lastSentTopics", "maxConnectTimeout", "reconnectAttempts", "maxReconnectAttempts", "Infinity", "predefinedReconnectIntervals", "pendingConnects", "isConnected", "topic", "listener", "msgEvent", "submitSubscriptions", "connect", "unsubscribeByTopicAndListener", "hasSubscriptionListeners", "removeEventListener", "disconnect", "topicPrefix", "hasAtleastOneTopic", "startsWith", "exist", "topicToCheck", "addAllSubscriptionListeners", "getNonEmptySubscriptionTopics", "getSubscriptionsCancelKey", "catch", "err", "removeAllSubscriptionListeners", "Promise", "resolve", "reject", "initConnect", "clearTimeout", "connectTimeoutId", "setTimeout", "connectErrorHandler", "EventSource", "buildUrl", "onerror", "lastEventId", "retries", "hasUnsentSubscriptions", "p", "reconnectTimeoutId", "latestTopics", "timeout", "fromReconnect", "cancelRequest", "close", "RecordService", "collectionIdOrName", "baseCollectionPath", "recordId", "realtime", "subscribe", "topicOrCallback", "unsubscribe", "unsubscribeByPrefix", "batchOrOptions", "getFullList", "params", "getFirstListItem", "getOne", "create", "collectionName", "record", "usernamePassword", "emailPassword", "authProviders", "usernameOrEmail", "provider", "codeVerifier", "redirectUrl", "createData", "args", "authWithOAuth2Code", "config", "listAuthMethods", "find", "eagerDefaultPopup", "cleanup", "urlCallback", "openBrowserPopup", "undefined", "oldState", "state", "scopes", "replacements", "_replaceQueryParams", "authUrl", "location", "href", "passwordResetToken", "verificationToken", "newEmail", "emailChangeToken", "urlPath", "substring", "parsedParams", "rawParams", "param", "pair", "hasOwnProperty", "open", "width", "height", "windowWidth", "innerWidth", "windowHeight", "innerHeight", "left", "top", "CollectionService", "collections", "deleteMissing", "LogService", "HealthService", "FileService", "filename", "queryParams", "parts", "download", "URLSearchParams", "BackupService", "basename", "knownSendOptionsKeys", "Client", "baseUrl", "lang", "cancelControllers", "recordServices", "enableAutoCancellation", "admins", "files", "logs", "settings", "health", "backups", "idOrName", "enable", "abort", "cancelAllRequests", "k", "getUrl", "origin", "endsWith", "pathname", "initSendOptions", "serializeQueryParams", "getHeader", "fetch", "json", "afterSend", "convertToFormDataIfNeeded", "$autoCancel", "$cancelKey", "isFormData", "Authorization", "controller", "AbortController", "signal", "FormData", "hasBlobField", "form", "values", "append", "v", "File", "encodedKey", "toISOString"]
}
