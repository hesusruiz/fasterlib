{
  "version": 3,
  "sources": ["../../front/src/pages/LoadAndSaveQRVC.js"],
  "sourcesContent": ["import { credentialsSave } from '../components/db';\r\nimport { decodeJWT } from '../components/jwt';\r\nimport { getOrCreateDidKey, signWithJWK, signJWT } from '../components/crypto'\r\n\r\nimport { renderLEARCredentialCard } from '../components/renderLEAR';\r\n\r\n// Setup some local variables for convenience\r\nlet gotoPage = window.MHR.gotoPage\r\nlet goHome = window.MHR.goHome\r\nlet html = window.MHR.html\r\nlet storage = window.MHR.storage\r\nlet myerror = window.MHR.storage.myerror\r\nlet mylog = window.MHR.storage.mylog\r\n\r\nconst PRE_AUTHORIZED_CODE_GRANT_TYPE = 'urn:ietf:params:oauth:grant-type:pre-authorized_code';\r\n\r\nwindow.MHR.register(\"LoadAndSaveQRVC\", class extends window.MHR.AbstractPage {\r\n\r\n    constructor(id) {\r\n        super(id)\r\n        this.VC = \"\"\r\n        this.VCType = \"\"\r\n        this.VCStatus = \"\"\r\n    }\r\n\r\n    async enter(qrData) {\r\n        this.qrData = qrData\r\n\r\n        mylog(`LoadAndSaveQRVC: ${qrData}`)\r\n        debugger\r\n\r\n        let html = this.html\r\n\r\n        // We should have received a URL that was scanned as a QR code or as a redirection\r\n        // Perform some sanity checks on the parameter\r\n        if (qrData == null || !qrData.startsWith) {\r\n            console.log(\"The scanned QR does not contain a valid URL\")\r\n            gotoPage(\"ErrorPage\", { \"title\": \"No data received\", \"msg\": \"The scanned QR does not contain a valid URL\" })\r\n            return\r\n        }\r\n\r\n        // Make sure it is a fully qualified URL\r\n        if (!qrData.startsWith(\"https://\") && !qrData.startsWith(\"http://\")) {\r\n            console.log(\"The scanned QR does not contain a valid URL\")\r\n            gotoPage(\"ErrorPage\", { \"title\": \"No data received\", \"msg\": \"The scanned QR does not contain a valid URL\" })\r\n            return\r\n        }\r\n\r\n        if (qrData.includes(\"state=\") && qrData.includes(\"auth-mock\")) {\r\n            gotoPage(\"EBSIRedirect\", qrData)\r\n            return\r\n        }\r\n\r\n        if (qrData.includes(\"code=\")) {\r\n            gotoPage(\"EBSIRedirectCode\", qrData)\r\n            return\r\n        }\r\n        \r\n        mylog(qrData)\r\n        // The QR points to an an OpenID4VCI credential issuance offer\r\n        if (qrData.includes(\"credential_offer_uri=\")) {\r\n\r\n            // Retrieve the credential offer from the Issuer\r\n            var credentialOffer = await getCredentialOffer(qrData);\r\n            this.credentialOffer = credentialOffer\r\n            // Save temporarily for redirections (with page reloads)\r\n            await storage.settingsPut(\"credentialOffer\", credentialOffer)\r\n            console.log(\"credentialOffer\", credentialOffer)\r\n\r\n            // Get the credential_issuer url to retrieve its metadata\r\n            const credential_issuer = credentialOffer[\"credential_issuer\"]\r\n            if (!credential_issuer) {\r\n                let msg = \"credential_issuer object not found in credentialOffer\"\r\n                myerror(msg)\r\n                gotoPage(\"ErrorPage\", { \"title\": \"Invalid credentialOffer\", \"msg\": msg })\r\n                return\r\n            }\r\n\r\n            // Get the Issuer metadata from the well-known endpoint of the Issuer\r\n            var issuerMetaData = await getIssuerMetadata(credential_issuer)\r\n            this.issuerMetaData = issuerMetaData\r\n            await storage.settingsPut(\"issuerMetaData\", issuerMetaData)\r\n\r\n            // Check that the credential endpoint url exists in the metadata\r\n            var credentialEndpoint = issuerMetaData[\"credential_endpoint\"]\r\n            if (!credentialEndpoint) {\r\n                let msg = \"credentialEndpoint object not found in issuerMetaData\"\r\n                myerror(msg)\r\n                gotoPage(\"ErrorPage\", { \"title\": \"Invalid issuerMetaData\", \"msg\": msg })\r\n                return\r\n            }\r\n\r\n            // TODO: check if 'authorization_server' is required or optional\r\n            var authorizationServer = issuerMetaData[\"authorization_server\"]\r\n            if (!authorizationServer) {\r\n                let msg = \"'authorizationServer' object not found in issuerMetaData\"\r\n                myerror(msg)\r\n                gotoPage(\"ErrorPage\", { \"title\": \"Invalid issuerMetaData\", \"msg\": msg })\r\n                return\r\n            }\r\n\r\n            // Get the AuthServer metadata from the well-known endpoint of the Authentication Server\r\n            var authServerMetaData = await getAuthServerMetadata(authorizationServer)\r\n            this.authServerMetaData = authServerMetaData\r\n            await storage.settingsPut(\"authServerMetaData\", authServerMetaData)\r\n\r\n            // The grant object in the credential offer will determine the type of flow to execute\r\n            const grants = credentialOffer[\"grants\"]\r\n            if (!grants) {\r\n                let msg = \"grants object not found in credentialOffer\"\r\n                myerror(msg)\r\n                gotoPage(\"ErrorPage\", { \"title\": \"Invalid credentialOffer\", \"msg\": msg })\r\n                return\r\n            }\r\n\r\n            // Check the type of authorization flows supported by Issuer\r\n            const authorization_code = grants[\"authorization_code\"]\r\n            if (authorization_code) {\r\n                await this.renderAuthCodeFlow(credentialOffer, issuerMetaData, authServerMetaData)\r\n                return\r\n            } else if (grants[PRE_AUTHORIZED_CODE_GRANT_TYPE]) {\r\n                await this.startPreAuthorizedCodeFlow()\r\n                return\r\n            } else {\r\n                let msg = \"No authorization flow type found in grants\"\r\n                myerror(msg)\r\n                gotoPage(\"ErrorPage\", { \"title\": \"Invalid grants\", \"msg\": msg })\r\n                return\r\n            }\r\n\r\n        } else {\r\n            mylog(\"Non-standard issuance\")\r\n            // This is a non-standard nechanism to issue credentials (easier in controlled environments).\r\n            // We have received a URL that was scanned as a QR code.\r\n            // First we should do a GET to the URL to retrieve the VC.\r\n\r\n            const theurl = new URL(qrData)\r\n            this.OriginServer = theurl.origin\r\n\r\n            // var myDid = await getOrCreateDidKey()\r\n            // const theProof = await generateDIDKeyProof(myDid, \"https://issuer.mycredential.eu\", \"1234567890\")\r\n            // debugger\r\n            // var result = await this.updateCredentialPOST(theProof, qrData)\r\n\r\n            var result = await doGETJSON(qrData)\r\n            this.VC = result[\"credential\"]\r\n            this.VCId = result[\"id\"]\r\n            this.VCType = result[\"type\"]\r\n            this.VCStatus = result[\"status\"]\r\n            this.renderedVC = this.prerenderEmployeeCredential(this.VC, this.VCType, this.VCStatus)\r\n\r\n            if (this.VCStatus == \"offered\") {\r\n                // Ask the user if we should accept the credential offer\r\n                let theHtml = html`\r\n                <ion-card color=\"warning\">\r\n                        \r\n                    <ion-card-content>\r\n                    <p><b>\r\n                    ${T(\"You received a proposal for a Verifiable Credential\")}. ${T(\"You can accept it, or cancel the operation.\")}\r\n                    </b></p>\r\n                    </ion-card-content>\r\n                    \r\n                </ion-card>\r\n\r\n                ${this.renderedVC}\r\n                `\r\n                this.render(theHtml)\r\n                return\r\n\r\n            }\r\n\r\n            // Ask the user if we should store the VC\r\n            let theHtml = html`\r\n            <ion-card color=\"warning\">\r\n                    \r\n                <ion-card-content>\r\n                <p><b>\r\n                ${T(\"You received a Verifiable Credential\")}. ${T(\"You can save it in this device for easy access later, or cancel the operation.\")}\r\n                </b></p>\r\n                </ion-card-content>\r\n                \r\n            </ion-card>\r\n\r\n            ${this.renderedVC}\r\n            `\r\n            this.render(theHtml)\r\n        }\r\n\r\n    }\r\n\r\n    async updateCredentialPOST(proof, credentialEndpoint) {\r\n\r\n        var credentialReq = {\r\n            // types: credentialTypes,\r\n            format: 'jwt_vc',\r\n            proof: {\r\n                proof_type: 'jwt',\r\n                jwt: proof\r\n            }\r\n        }\r\n    \r\n        console.log(\"Body \" + JSON.stringify(credentialReq))\r\n        let response = await fetch(credentialEndpoint, {\r\n            method: \"POST\",\r\n            cache: \"no-cache\",\r\n            headers: {\r\n                'Content-Type': 'application/json',\r\n                // 'Authorization': 'Bearer ' + accessToken\r\n            },\r\n            body: JSON.stringify(credentialReq),\r\n            mode: \"cors\"\r\n        });\r\n    \r\n    \r\n        if (response.ok) {\r\n            // The reply is the complete JWT\r\n            const credentialResponse = await response.json();\r\n            mylog(credentialResponse)\r\n            return credentialResponse\r\n        } else {\r\n            if (response.status == 400) {\r\n                throw new Error(\"Bad request 400 retrieving credential\")\r\n            } else {\r\n                throw new Error(response.statusText)            \r\n            }\r\n        }\r\n    \r\n    }\r\n    \r\n\r\n    // startPreAuthorizedCodeFlow asks the user for the PIN (required) and then processes the flow\r\n    async startPreAuthorizedCodeFlow() {\r\n\r\n        let theHtml = html`\r\n        <ion-card style=\"max-width:600px\">\r\n            <ion-card-content>\r\n            <p>Enter the PIN shown in the EBSI screen.<b>\r\n            <ion-input id=\"thepin\" label=\"PIN\" label-placement=\"stacked\" type=\"number\" placeholder=\"0000\"></ion-input>\r\n            </ion-card-content>\r\n            \r\n            <div class=\"ion-margin-start ion-margin-bottom\">\r\n                <ion-button @click=${async () => {\r\n                    const ionpin = document.getElementById(\"thepin\")\r\n                    const nativepin = await ionpin.getInputElement()\r\n                    const pin = nativepin.value\r\n                    if (pin.length > 0) {this.renderPreAuthorizedCodeFlow(pin)}\r\n                } }>\r\n                ${T(\"Continue\")}\r\n                </ion-button>\r\n            </div>\r\n\r\n        </ion-card>\r\n        `\r\n        this.render(theHtml)\r\n\r\n    }\r\n\r\n    async renderPreAuthorizedCodeFlow(user_pin) {\r\n        try {\r\n            this.user_pin = user_pin\r\n            const jwtCredential = await performPreAuthorizedCodeFlow(\r\n                this.credentialOffer,\r\n                this.issuerMetaData,\r\n                this.authServerMetaData, user_pin)\r\n\r\n            // Store in an instance variable\r\n            this.VC = jwtCredential\r\n            this.VCType = \"EBSI\"\r\n            this.VCStatus = \"signed\"\r\n\r\n            // Decode and render the credencial\r\n            const decoded = decodeJWT(jwtCredential)\r\n            this.renderedVC = this.renderEBSICredential(decoded)\r\n\r\n            // Ask the user if we should store the VC\r\n            let theHtml = html`\r\n            <ion-card color=\"warning\">\r\n                <ion-card-content>\r\n                <p><b>\r\n                ${T(\"You received a Verifiable Credential\")}. ${T(\"You can save it in this device for easy access later, or cancel the operation.\")}\r\n                </b></p>\r\n                </ion-card-content>\r\n            </ion-card>\r\n\r\n            ${this.renderedVC}\r\n            `\r\n            this.render(theHtml)\r\n        } catch (error) {\r\n            debugger\r\n            this.showError(error.name, error.message)\r\n        }\r\n\r\n    }\r\n\r\n    async renderAuthCodeFlow(credentialOffer, issuerMetaData, authServerMetaData) {\r\n\r\n        const jwtCredential = await performAuthCodeFlow(\r\n            credentialOffer,\r\n            issuerMetaData,\r\n            authServerMetaData)\r\n        \r\n        // Store in an instance variable\r\n        this.VC = jwtCredential\r\n        this.VCType = \"EBSI\"\r\n\r\n        // Decode and render the credencial\r\n        const decoded = decodeJWT(jwtCredential)\r\n        this.renderedVC = this.renderEBSICredential(decoded)\r\n\r\n        // Ask the user if we should store the VC\r\n        let theHtml = html`\r\n        <ion-card color=\"warning\">\r\n            <ion-card-content>\r\n            <p><b>\r\n            ${T(\"You received a Verifiable Credential\")}. ${T(\"You can save it in this device for easy access later, or cancel the operation.\")}\r\n            </b></p>\r\n            </ion-card-content>\r\n        </ion-card>\r\n\r\n        ${this.renderedVC}\r\n        `\r\n        this.render(theHtml)\r\n\r\n    }\r\n\r\n    async acceptVC() {\r\n        console.log(\"Accept VC \" + this.VC)\r\n        if (this.VCStatus == \"offered\") {\r\n            // We should update the credential offer with the did of the user\r\n\r\n            var myDid = await getOrCreateDidKey()\r\n            const theProof = await generateDIDKeyProof(myDid, \"https://issuer.mycredential.eu\", \"1234567890\")\r\n            debugger\r\n            var result = await this.updateCredentialPOST(theProof, qrData)\r\n            console.log(\"acceptVC\", result)\r\n\r\n            // Reload the application with a clean URL\r\n            location = window.location.origin + window.location.pathname\r\n            return\r\n\r\n        }\r\n\r\n    }\r\n\r\n    // Save the credential and perform any additional actions needed\r\n    async saveVC() {\r\n        var replace = false\r\n\r\n        console.log(\"Save VC \" + this.VC)\r\n\r\n        if (this.VCType == \"EBSI\") {\r\n            const decodedJWT = decodeJWT(this.VC)\r\n            const decoded = decodedJWT.body.vc\r\n\r\n            var credStruct = {\r\n                type: \"EBSI\",\r\n                status: this.VCStatus,\r\n                encoded: this.VC,\r\n                decoded: decoded\r\n            }\r\n            var saved = await credentialsSave(credStruct, replace)\r\n            if (!saved) {\r\n                return\r\n            }\r\n    \r\n        } else if (this.VCType == \"jwt_vc\") {\r\n            debugger\r\n\r\n            if (this.VCStatus == \"offered\") {\r\n                // We should update the credential offer with the did of the user\r\n\r\n                var myDid = await getOrCreateDidKey()\r\n\r\n                // Update the credential with the did:key\r\n                var sendidRequest = {\r\n                    did: myDid.did\r\n                }\r\n\r\n                // Send the DID to the Issuer\r\n                const senddidURL = `${this.OriginServer}/apiuser/senddid/${this.VCId}`\r\n                var result = await doPOST(senddidURL, sendidRequest)\r\n                if (!result) {\r\n                    return\r\n                }\r\n                console.log(\"after doPOST sending the DID\")\r\n\r\n                // We received back the updated credential. Status must be 'tobesigned'\r\n                this.VC = result[\"credential\"]\r\n                this.VCId = result[\"id\"]\r\n                this.VCType = result[\"type\"]\r\n                this.VCStatus = result[\"status\"]\r\n\r\n            }\r\n\r\n            // The credential is in JWT format, lets decode it\r\n            const decoded = decodeJWT(this.VC)\r\n\r\n            // Prepare for saving the credential in the local storage\r\n            var credStruct = {\r\n                type: this.VCType,\r\n                status: this.VCStatus,\r\n                encoded: this.VC,\r\n                decoded: decoded.body,\r\n                id: decoded.body.id\r\n            }\r\n\r\n            // If the credential already exists, we only replace it if it is 'signed'\r\n            if (this.VCStatus == \"signed\") {\r\n                replace = true\r\n            }\r\n            var saved = await credentialsSave(credStruct, replace)\r\n            if (!saved) {\r\n                return\r\n            }\r\n    \r\n            alert(\"Credential succesfully saved\")\r\n\r\n        } else {\r\n            const decoded = JSON.parse(this.VC)\r\n\r\n            var credStruct = {\r\n                type: \"w3cvc\",\r\n                status: this.VCStatus,\r\n                encoded: this.VC,\r\n                decoded: decoded\r\n            }\r\n            var saved = await credentialsSave(credStruct, replace)\r\n            if (!saved) {\r\n                return\r\n            }\r\n        \r\n        }\r\n        \r\n        // Reload the application with a clean URL\r\n        location = window.location.origin + window.location.pathname\r\n        return\r\n    }\r\n\r\n    cleanReload() {\r\n        // Reload the application with a clean URL\r\n        location = window.location.origin + window.location.pathname\r\n        return\r\n    }\r\n\r\n    renderEBSICredential(vcdecoded) {\r\n\r\n        const vc = vcdecoded.body.vc\r\n        const vcTypeArray = vc[\"type\"]\r\n        const vcType = vcTypeArray[vcTypeArray.length -1]\r\n    \r\n        const div = html`\r\n        <ion-card>\r\n    \r\n            <ion-card-header>\r\n                <ion-card-title>${vcType}</ion-card-title>\r\n                <ion-card-subtitle>EBSI</ion-card-subtitle>\r\n            </ion-card-header>\r\n    \r\n            <ion-card-content class=\"ion-padding-bottom\">\r\n    \r\n                <div>\r\n                    <p>Issuer: ${vc.issuer}</p>\r\n                </div>\r\n    \r\n            </ion-card-content>\r\n    \r\n            <div class=\"ion-margin-start ion-margin-bottom\">\r\n                <ion-button @click=${() => this.cleanReload()}>\r\n                    <ion-icon slot=\"start\" name=\"chevron-back\"></ion-icon>\r\n                    ${T(\"Do not save\")}\r\n                </ion-button>\r\n    \r\n                <ion-button @click=${() => this.saveVC()}>\r\n                    <ion-icon slot=\"start\" name=\"person-add\"></ion-icon>\r\n                    ${T(\"Save credential\")}\r\n                </ion-button>\r\n            </div>\r\n        </ion-card>\r\n        `\r\n        return div\r\n    \r\n    }\r\n    \r\n    prerenderEmployeeCredential(vcencoded, vctype, vcstatus) {\r\n\r\n        if (vctype == \"jwt_vc\") {\r\n            var decoded = decodeJWT(vcencoded)\r\n        } else {\r\n            decoded = vcencoded\r\n        }\r\n        let html = this.html\r\n\r\n        if (vcstatus == \"offered\") {\r\n\r\n            const vc = decoded.body\r\n            const div = html`\r\n            <ion-card>\r\n                ${renderLEARCredentialCard(vc, vcstatus)}\r\n    \r\n                <div class=\"ion-margin-start ion-margin-bottom\">\r\n                    <ion-button @click=${() => this.cleanReload()}>\r\n                        <ion-icon slot=\"start\" name=\"chevron-back\"></ion-icon>\r\n                        ${T(\"Cancel\")}\r\n                    </ion-button>\r\n    \r\n                    <ion-button @click=${() => this.acceptVC()}>\r\n                        <ion-icon slot=\"start\" name=\"person-add\"></ion-icon>\r\n                        ${T(\"Accept credential offer\")}\r\n                    </ion-button>\r\n                </div>\r\n            </ion-card>\r\n            `\r\n            return div\r\n    \r\n        }\r\n\r\n        const vc = decoded.body\r\n        const div = html`\r\n        <ion-card>\r\n            ${renderLEARCredentialCard(vc, vcstatus)}\r\n\r\n            <div class=\"ion-margin-start ion-margin-bottom\">\r\n                <ion-button @click=${() => this.cleanReload()}>\r\n                    <ion-icon slot=\"start\" name=\"chevron-back\"></ion-icon>\r\n                    ${T(\"Do not save\")}\r\n                </ion-button>\r\n\r\n                <ion-button @click=${() => this.saveVC()}>\r\n                    <ion-icon slot=\"start\" name=\"person-add\"></ion-icon>\r\n                    ${T(\"Save credential\")}\r\n                </ion-button>\r\n            </div>\r\n        </ion-card>\r\n        `\r\n        return div\r\n\r\n    }\r\n\r\n})\r\n\r\n\r\nasync function performAuthCodeFlow(credentialOffer, issuerMetaData, authServerMetaData) {\r\n\r\n\r\n    // Get the credential supported by issuer\r\n    const credentialTypes = credentialOffer.credentials[0].types\r\n\r\n    // The state will be used by the issuer to match request/reply\r\n    const issuer_state = credentialOffer[\"grants\"][\"authorization_code\"][\"issuer_state\"]\r\n\r\n    // This is the url of the Authorization Server\r\n    const authorization_endpoint = authServerMetaData[\"authorization_endpoint\"]\r\n\r\n    // Get my DID\r\n    const myDID = await window.MHR.storage.didFirst()\r\n\r\n    // **************************************\r\n    // **************************************\r\n    // Step 1: GET Authorization Request\r\n    // **************************************\r\n    // **************************************\r\n    console.log(\"Step 1: GET Authorization Request\")\r\n\r\n    // It has the following form:\r\n    //\r\n    // GET from https://api-conformance.ebsi.eu/conformance/v3/auth-mock/authorize\r\n    // ?response_type=code\r\n    // &scope=openid\r\n    // &state=tracker%3Dvcfghhj\r\n    // &client_id=did%3Akey%3Az2dmzD81cgPx8Vki7JbuuMmFYrWPgYoytykUZ3eyqht1j9KbsEYvdrjxMjQ4tpnje9BDBTzuNDP3knn6qLZErzd4bJ5go2CChoPjd5GAH3zpFJP5fuwSk66U5Pq6EhF4nKnHzDnznEP8fX99nZGgwbAh1o7Gj1X52Tdhf7U4KTk66xsA5r\r\n    // &authorization_details=%5B%7B%22type%22%3A%22openid_credential%22%2C%22format%22%3A%22jwt_vc%22%2C%22types%22%3A%5B%22VerifiableCredential%22%2C%22VerifiableAttestation%22%2C%22CTWalletInTime%22%5D%7D%5D\r\n    // &redirect_uri=openid%3A\r\n    // &nonce=glkFFoisdfEui43\r\n    // &code_challenge=YjI0ZTQ4NTBhMzJmMmZhNjZkZDFkYzVhNzlhNGMyZDdjZDlkMTM4YTY4NjcyMTA5M2Q2OWQ3YjNjOGJlZDBlMSAgLQo%3D\r\n    // &code_challenge_method=S256\r\n    // &client_metadata=%7B%22vp_formats_supported%22%3A%7B%22jwt_vp%22%3A%7B%22alg%22%3A%5B%22ES256%22%5D%7D%2C%22jwt_vc%22%3A%7B%22alg%22%3A%5B%22ES256%22%5D%7D%7D%2C%22response_types_supported%22%3A%5B%22vp_token%22%2C%22id_token%22%5D%2C%22authorization_endpoint%22%3A%22openid%3A%22%7D\r\n\r\n    // Calculate a code_challenge as BASE64URL-ENCODE(SHA256(code_verifier as UTF-8 string))\r\n    // Where code_verifier is a secure random, which will be used with token endpoint.\r\n    // It is between 43 and 128 characters long, and contains characters A-Z, a-z, 0-9, hyphen, period, underscore, and tilde.\r\n    // See RFC 7636 for more information\r\n    // TODO: should generate a random string\r\n    const code_verifier = \"this_is_a_code_verifierthis_is_a_code_verifierthis_is_a_code_verifier\"\r\n    const code_challenge = await hashFromString(code_verifier)\r\n    console.log(\"code_challenge\", code_challenge)\r\n\r\n    // Specify what we are requesting\r\n    var authorization_details = [\r\n        {\r\n            \"type\": \"openid_credential\",\r\n            \"format\": \"jwt_vc\",\r\n            \"types\": credentialTypes\r\n        }\r\n    ]\r\n\r\n    // If the Credential Issuer metadata contains an authorization_server parameter,\r\n    // the authorization detail's locations common data field MUST be set to the Credential Issuer Identifier value.\r\n    var authorizationServer = issuerMetaData[\"authorization_server\"]\r\n    if (authorizationServer) {\r\n        authorization_details[0][\"locations\"] = [\r\n            issuerMetaData[\"credential_issuer\"]\r\n        ]\r\n    }\r\n\r\n    var client_metadata = {\r\n        \"vp_formats_supported\":{\r\n            \"jwt_vp\":{\"alg\":[\"ES256\"]},\r\n            \"jwt_vc\":{\"alg\":[\"ES256\"]}\r\n        },\r\n        \"response_types_supported\":[\"vp_token\",\"id_token\"],\r\n        \"authorization_endpoint\": window.location.origin\r\n    }\r\n\r\n    var formAttributes = {\r\n        'response_type': 'code',\r\n        'scope': 'openid',\r\n        'issuer_state': issuer_state,\r\n        'client_id': myDID.did,\r\n        'authorization_details': JSON.stringify(authorization_details),\r\n        'redirect_uri': window.location.origin,\r\n        'nonce': 'thisisthenonce',\r\n        'code_challenge': code_challenge,\r\n        'code_challenge_method': 'S256',\r\n        'client_metadata': JSON.stringify(client_metadata),\r\n    }\r\n    // Encode in urlForm\r\n    var formBody = [];\r\n    for (var property in formAttributes) {\r\n        var encodedKey = encodeURIComponent(property);\r\n        var encodedValue = encodeURIComponent(formAttributes[property]);\r\n        formBody.push(encodedKey + \"=\" + encodedValue);\r\n    }\r\n    formBody = formBody.join(\"&\");\r\n\r\n    // There will be an HTTP 302 Redirection after this\r\n    // We will receive the url to invoke as a result from the POST\r\n    debugger\r\n    console.log(\"AuthRequest\", authorization_endpoint + \"?\" + formBody)\r\n    let resp = await fetch(authorization_endpoint + \"?\" + formBody, {\r\n        cache: \"no-cache\",\r\n        mode: \"cors\"\r\n    });\r\n\r\n    // Throw an error if something went wrong\r\n    if (!resp.ok || !resp.redirected) {\r\n        throw new Error(\"error retrieving OpenID metadata\")\r\n    }\r\n\r\n    var redirectedURL = resp.url\r\n\r\n    // The redirected URL contains the authorization type in the response_type. The URL can be of two types:\r\n    //\r\n    // Type 1: with response_type=vp_token, the AuthServer expects that the wallet sends a VP. The credentials required are specified\r\n    // in the presentation_definition parameter. This URL looks like:\r\n    //\r\n    // https://wallet.mycredential.eu/?\r\n    // state=66685746-05f4-4d3d-896d-877ad0043115&\r\n    // client_id=https://api-conformance.ebsi.eu/conformance/v3/auth-mock&\r\n    // redirect_uri=https://api-conformance.ebsi.eu/conformance/v3/auth-mock/direct_post&\r\n    // response_type=vp_token&\r\n    // response_mode=direct_post&\r\n    // scope=openid&\r\n    // nonce=560bc48c-e597-41d5-ab10-066a25a3758d&\r\n    // presentation_definition={....}&\r\n    // request=eyJ0eXAiOiJKV1QiLCJhbGciOi\r\n    //\r\n    // Type 2: with response_type=id_token, the AuthServer is expects that the wallet sends an ID Token. No credentials are needed.\r\n    // The URL looks like:\r\n    //\r\n    // https://wallet.mycredential.eu/?\r\n    // state=e6379c7f-1919-41aa-8194-9767295e1896&\r\n    // client_id=https%3A%2F%2Fapi-conformance.ebsi.eu%2Fconformance%2Fv3%2Fauth-mock&\r\n    // redirect_uri=https%3A%2F%2Fapi-conformance.ebsi.eu%2Fconformance%2Fv3%2Fauth-mock%2Fdirect_post&\r\n    // response_type=id_token&\r\n    // response_mode=direct_post&\r\n    // scope=openid&\r\n    // nonce=a8612b8a-8e8b-461c-a21e-e4b09988fc87&\r\n    // request_uri=https%3A%2F%2Fapi-conformance.ebsi.eu%2Fconformance%2Fv3%2Fauth-mock%2Frequest_uri%2F3e3a4bb3-3b22-4b14-92bb-3e198658fbf5\r\n\r\n\r\n    mylog(redirectedURL)\r\n    var urlParams = new URL(redirectedURL).searchParams;\r\n\r\n    const response_type = decodeURIComponent(urlParams.get('response_type'))\r\n    if (response_type == \"vp_token\") {\r\n        const pd = decodeURIComponent(urlParams.get('presentation_definition'))\r\n        console.log(\"Presentation Definition\", pd)\r\n        throw new Error(\"Response type vp_token not implemented yet\")\r\n    } else if (response_type == \"id_token\") {\r\n        // Do nothing. This is for documentation purposes\r\n    } else {\r\n        throw new Error(\"Invalid response_type: \" + response_type)\r\n    }\r\n\r\n    // **************************************\r\n    // **************************************\r\n    // Step 2: ID Token Request\r\n    //\r\n    // The authorization server requests an ID Token from the Wallet to authenticate the DID without any claims.\r\n    // The request from the Auth Server comes in the redirected URL received as a response of the authorization request.\r\n    // \r\n    // **************************************\r\n    // **************************************\r\n    console.log(\"Step 2: ID Token Request\")\r\n\r\n    const redirect_uri = decodeURIComponent(urlParams.get('redirect_uri'))\r\n    console.log(\"redirect_uri\", redirect_uri)\r\n    const client_id = decodeURIComponent(urlParams.get('client_id'))\r\n    const state = decodeURIComponent(urlParams.get('state'))\r\n    var nonce = decodeURIComponent(urlParams.get('nonce'))\r\n\r\n    // Generate the ID Token according to the request from the authorization server\r\n    const IDToken = await generateEBSIIDToken(myDID, client_id, state, nonce)\r\n    console.log(\"IDToken\", IDToken)\r\n\r\n    // **************************************\r\n    // **************************************\r\n    // Step 3: Send ID Token Response to Authorization Server\r\n    //\r\n    // The Wallet answers the ID Token Request by providing the id_token in the redirect_uri as instructed by response_mode\r\n    // of direct_post. The id_token must be signed with the DID document's authentication key.\r\n    // The state parameter is mandatory for the ID Token Response when it is present in the ID Token Request sent by\r\n    // the Authorization Server. In such cases, the Wallet must ensure that the values of the state parameter are identical in both.\r\n    // \r\n    // **************************************\r\n    // **************************************\r\n    console.log(\"Step 2: ID Token Request\")\r\n\r\n    var formAttributes = {\r\n        id_token: IDToken,\r\n        state: state,\r\n    }\r\n\r\n    formBody = [];\r\n    for (var property in formAttributes) {\r\n        var encodedKey = encodeURIComponent(property);\r\n        var encodedValue = encodeURIComponent(formAttributes[property]);\r\n        formBody.push(encodedKey + \"=\" + encodedValue);\r\n    }\r\n    formBody = formBody.join(\"&\");\r\n    console.log(\"Body\", formBody)\r\n\r\n    // There will be an HTTP 302 Redirection after this\r\n    // We will receive the url to invoke as a result from the POST\r\n    resp = await fetch(redirect_uri, {\r\n        method: \"POST\",\r\n        redirect: \"follow\",\r\n        cache: \"no-cache\",\r\n        headers: {\r\n            'Content-Type': 'application/x-www-form-urlencoded'\r\n        },\r\n        body: formBody,\r\n        mode: \"cors\"\r\n    });\r\n\r\n    // Throw an error if something went wrong\r\n    if (!resp.ok || !resp.redirected) {\r\n        throw new Error(resp.statusText)\r\n    }\r\n\r\n    redirectedURL = resp.url\r\n\r\n    // **************************************\r\n    // **************************************\r\n    // Step 4: Receive Authorization response\r\n    //\r\n    // The redirected URL contains the Authorization Response, with the authorization code. The url is something like:\r\n    // https://wallet.mycredential.eu?code=530dfe71-845b-4310-acb6-06023a036ff5\r\n    // \r\n    // **************************************\r\n    // **************************************\r\n    console.log(\"Step 4: Receive Authorization response\")\r\n    mylog(redirectedURL)\r\n    var urlParams = new URL(redirectedURL).searchParams;\r\n\r\n    // Get the authorization code from the URL\r\n    const code = decodeURIComponent(urlParams.get('code'))\r\n    console.log(\"code\", code)\r\n\r\n    // **************************************\r\n    // **************************************\r\n    // Step 5: Request Access Token from Authorization Server\r\n    //\r\n    // The Wallet (Relying Party) proceeds with the code flow by calling the Token Endpoint with the required details\r\n    // and providing a code_verifier corresponding to the initial Authorisation Request code_challenge.\r\n    // \r\n    // **************************************\r\n    // **************************************\r\n    console.log(\"Step 5: Request Access Token from Authorization Server\")\r\n\r\n    const tokenEndpoint = authServerMetaData.token_endpoint\r\n\r\n    var formAttributes = {\r\n        grant_type: \"authorization_code\",\r\n        client_id: myDID.did,\r\n        code: code,\r\n        code_verifier: code_verifier\r\n    }\r\n    formBody = encodeFormAttributes(formAttributes)\r\n    console.log(tokenEndpoint)\r\n    console.log(formBody)\r\n\r\n    // This request is a normal one and will not be redirected\r\n    resp = await fetch(tokenEndpoint, {\r\n        method: \"POST\",\r\n        redirect: \"follow\",\r\n        cache: \"no-cache\",\r\n        headers: {\r\n            'Content-Type': 'application/x-www-form-urlencoded'\r\n        },\r\n        body: formBody,\r\n        mode: \"cors\"\r\n    });\r\n\r\n    if (!resp.ok) {\r\n        throw new Error(resp.statusText)\r\n    }\r\n\r\n    // **************************************\r\n    // **************************************\r\n    // Step 6: Receive Access Token from Authorization Server\r\n    //\r\n    // The Access Token is delivered inside a response payload from a successful Token Endpoint initiation.\r\n    // c_nonce (Challenge Nonce) must be stored until a new one is given. The response looks like:\r\n    //\r\n    // Content-Type: application/json\r\n    // {\r\n    //     \"access_token\": \"eyJhbGciOiJSUzI1NiIsInR5cCI6Ikp..sHQ\",\r\n    //     \"refresh_token\": \"eyJhbGciOiJSUzI1NiIsInR5cCI4a5k..zEF\",\r\n    //     \"token_type\": \"bearer\",\r\n    //     \"expires_in\": 86400,\r\n    //     \"id_token\": \"eyJodHRwOi8vbWF0dHIvdGVuYW50L..3Mz\",\r\n    //     \"c_nonce\": \"PAPPf3h9lexTv3WYHZx8ajTe\",\r\n    //     \"c_nonce_expires_in\": 86400\r\n    // }\r\n    // **************************************\r\n    // **************************************\r\n    console.log(\"Step 6: Receive Access Token from Authorization Server\")\r\n\r\n    const authTokenObject = await resp.json()\r\n    console.log(\"Auth Token object:\", authTokenObject)\r\n\r\n    // Get the nonce and access token from the retrieved object\r\n    var nonce = authTokenObject.c_nonce\r\n    const access_token = authTokenObject.access_token\r\n\r\n    // **************************************\r\n    // **************************************\r\n    // Step 7: Send a Credential Request\r\n    //\r\n    // At this point, the Wallet has successfully obtained a valid Access Token, which can be used to gain access to\r\n    // the Credential's Issuer.\r\n    // The Relying Party proceeds by requesting issuance of the Verifiable Credential from the Issuer Mock.\r\n    // The requested Credential must match the granted access. The DID document's authentication key must be used\r\n    // for signing the JWT proof, where the DID must also match the one used for authentication.\r\n    //\r\n    // **************************************\r\n    // **************************************\r\n    console.log(\"Step 7: Send a Credential Request\")\r\n\r\n    // Get the proof object that we have to include in the Credential Request\r\n    const proof = await generateDIDKeyProof(myDID, issuerMetaData.credential_issuer, nonce)\r\n\r\n    // Get the credential from EBSI\r\n    var credentialResponse = await requestEBSICredential(proof, access_token, issuerMetaData.credential_endpoint, credentialTypes)\r\n\r\n    var acceptance_token = credentialResponse[\"acceptance_token\"]\r\n    const max_iterations = 10\r\n    var iterations = 0\r\n\r\n    while (acceptance_token && iterations < max_iterations) {\r\n        \r\n        console.log(\"Waiting for credential ...\")\r\n        await delay(1000)\r\n        console.log(\"Finished waiting for credential\")\r\n\r\n        // Get the credential from EBSI\r\n        \r\n        credentialResponse = await requestDeferredEBSICredential(acceptance_token, issuerMetaData[\"deferred_credential_endpoint\"])\r\n        // credentialResponse = await requestEBSICredential(proof, acceptance_token, issuerMetaData.credential_endpoint, credentialTypes)\r\n        console.log(\"CredentialResponse\", credentialResponse)\r\n        acceptance_token = credentialResponse[\"acceptance_token\"]\r\n\r\n        iterations = iterations + 1\r\n    }\r\n\r\n    if (!credentialResponse.credential) {\r\n        throw new Error(\"No credential after all retries\")\r\n    }\r\n\r\n    // **************************************\r\n    // **************************************\r\n    // Step 8: Receive the credential\r\n    //\r\n    // After a successful request, the response payload will contain the requested credential. It looks like:\r\n    //\r\n    // Content-Type: application/json\r\n    // {\r\n    //   \"format\": \"jwt_vc\",\r\n    //   \"credential\": \"eyJ0eXAiOiJKV1QiLCJhbGciOi...Y5kwU_qJzvBWEVsBP8QvRlLvcWJDwyyGJF0YluuK2Cog\",\r\n    // }\r\n    //\r\n    // **************************************\r\n    // **************************************\r\n    console.log(\"Step 8: Receive the credential\")\r\n\r\n    return credentialResponse.credential\r\n\r\n}\r\n\r\nfunction delay(ms) {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\n\r\nasync function performPreAuthorizedCodeFlow(credentialOffer, issuerMetaData, authServerMetaData, user_pin) {\r\n    console.log(\"credentialOffer\")\r\n    console.log(credentialOffer)\r\n\r\n    console.log(\"issuerMetaData\")\r\n    console.log(issuerMetaData)\r\n\r\n    console.log(\"authServerMetaData\")\r\n    console.log(authServerMetaData)\r\n\r\n    // Get the credential supported by issuer\r\n    const credentialTypes = credentialOffer.credentials[0].types\r\n\r\n    // Get an accesstoken for retrieving the credential\r\n    const tokenEndpoint = authServerMetaData[\"token_endpoint\"]\r\n    const code = credentialOffer[\"grants\"][PRE_AUTHORIZED_CODE_GRANT_TYPE][\"pre-authorized_code\"]\r\n    const authTokenObject = await getPreAuthToken(tokenEndpoint, code, user_pin)\r\n\r\n    // Get the nonce and access token from the retrieved object\r\n    const nonce = authTokenObject.c_nonce\r\n    const access_token = authTokenObject.access_token\r\n\r\n    // Get my DID\r\n    const myDID = await window.MHR.storage.didFirst()\r\n\r\n    // Get the proof object that we have to include in the Credential Request\r\n    const proof = await generateDIDKeyProof(myDID, issuerMetaData.credential_issuer, nonce)\r\n\r\n    // Get the credential from EBSI\r\n    const credentialResponse = await requestEBSICredential(proof, access_token, issuerMetaData.credential_endpoint, credentialTypes)\r\n\r\n   return credentialResponse.credential\r\n}\r\n\r\nasync function getPreAuthToken(tokenEndpoint, preAuthCode, user_pin) {\r\n    try {\r\n        var formAttributes = {\r\n            'grant_type': PRE_AUTHORIZED_CODE_GRANT_TYPE,\r\n            'user_pin': user_pin,\r\n            'pre-authorized_code': preAuthCode\r\n        }\r\n        var formBody = [];\r\n        for (var property in formAttributes) {\r\n            var encodedKey = encodeURIComponent(property);\r\n            var encodedValue = encodeURIComponent(formAttributes[property]);\r\n            formBody.push(encodedKey + \"=\" + encodedValue);\r\n        }\r\n        formBody = formBody.join(\"&\");\r\n        console.log(\"The body: \" + formBody)\r\n\r\n        let response = await fetch(tokenEndpoint, {\r\n            method: \"POST\",\r\n            cache: \"no-cache\",\r\n            headers: {\r\n                'Content-Type': 'application/x-www-form-urlencoded'\r\n            },\r\n            body: formBody,\r\n            mode: \"cors\"\r\n        });\r\n        if (response.ok) {\r\n            var tokenBody = await response.json();\r\n        } else {\r\n            if (response.status == 403) {\r\n                alert(\"error 403\");\r\n                window.MHR.goHome();\r\n                return \"Error 403\";\r\n            }\r\n            var error = await response.text();\r\n            myerror(error);\r\n            window.MHR.goHome();\r\n            alert(error);\r\n            return null;\r\n        }\r\n    } catch (error2) {\r\n        myerror(error2);\r\n        alert(error2);\r\n        return null;\r\n    }\r\n    console.log(tokenBody);\r\n    return tokenBody;\r\n}\r\n\r\n\r\n\r\nasync function requestEBSICredential(proof, accessToken, credentialEndpoint, credentialTypes) {\r\n\r\n    var credentialReq = {\r\n        types: credentialTypes,\r\n        format: 'jwt_vc',\r\n        proof: {\r\n            proof_type: 'jwt',\r\n            jwt: proof\r\n        }\r\n    }\r\n\r\n    console.log(\"Body \" + JSON.stringify(credentialReq))\r\n    let response = await fetch(credentialEndpoint, {\r\n        method: \"POST\",\r\n        cache: \"no-cache\",\r\n        headers: {\r\n            'Content-Type': 'application/json',\r\n            'Authorization': 'Bearer ' + accessToken\r\n        },\r\n        body: JSON.stringify(credentialReq),\r\n        mode: \"cors\"\r\n    });\r\n\r\n\r\n    if (response.ok) {\r\n        // The reply is the complete JWT\r\n        const credentialResponse = await response.json();\r\n        mylog(credentialResponse)\r\n        return credentialResponse\r\n    } else {\r\n        if (response.status == 400) {\r\n            throw new Error(\"Bad request 400 retrieving credential\")\r\n        } else {\r\n            throw new Error(response.statusText)            \r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\nasync function requestDeferredEBSICredential(acceptance_token, deferredCredentialEndpoint) {\r\n\r\n    let response = await fetch(deferredCredentialEndpoint, {\r\n        method: \"POST\",\r\n        cache: \"no-cache\",\r\n        headers: {\r\n            'Content-Type': 'application/json',\r\n            'Authorization': 'Bearer ' + acceptance_token\r\n        },\r\n        mode: \"cors\"\r\n    });\r\n\r\n    if (response.ok) {\r\n        // The reply is the complete JWT\r\n        const credentialResponse = await response.json();\r\n        mylog(credentialResponse)\r\n        return credentialResponse\r\n    } else {\r\n        throw new Error(response.statusText)\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\nasync function getCredentialOIDC4VCI(credentialEndpoint, accessToken, format, credential_type) {\r\n    try {\r\n        var credentialReq = {\r\n            format: format,\r\n            types: credential_type\r\n        }\r\n        console.log(\"Body \" + JSON.stringify(credentialReq))\r\n        let response = await fetch(credentialEndpoint, {\r\n            method: \"POST\",\r\n            cache: \"no-cache\",\r\n            headers: {\r\n                'Content-Type': 'application/json',\r\n                'Authorization': 'Bearer ' + accessToken\r\n            },\r\n            body: JSON.stringify(credentialReq),\r\n            mode: \"cors\"\r\n        });\r\n        if (response.ok) {\r\n            var credentialBody = await response.json();\r\n        } else {\r\n            if (response.status == 403) {\r\n                alert.apply(\"error 403\");\r\n                window.MHR.goHome();\r\n                return \"Error 403\";\r\n            }\r\n            var error = await response.text();\r\n            myerror(error);\r\n            window.MHR.goHome();\r\n            alert(error);\r\n            return null;\r\n        }\r\n    } catch (error2) {\r\n        myerror(error2);\r\n        alert(error2);\r\n        return null;\r\n    }\r\n    console.log(credentialBody);\r\n    return credentialBody;\r\n}\r\n\r\n\r\n// getIssuerOpenIdConfig retrieves the OpenID metadata for an Issuer\r\nasync function getIssuerMetadata(issuerAddress) {\r\n    mylog(\"IssuerMetadata at\", issuerAddress)\r\n    let response = await fetch(issuerAddress + \"/.well-known/openid-credential-issuer\", {\r\n        cache: \"no-cache\",\r\n        mode: \"cors\"\r\n    });\r\n    if (response.ok) {\r\n        var openIdInfo = await response.json();\r\n        mylog(\"IssuerMetadata\",openIdInfo);\r\n        return openIdInfo;\r\n    } else {\r\n        throw new Error(\"error retrieving OpenID metadata\")\r\n    }\r\n}\r\n\r\n// getAuthServerOpenIdConfig retrieves the OpenID metadata for a server\r\nasync function getAuthServerMetadata(authServerAddress) {\r\n    mylog(\"AuthServerMetadata at\", authServerAddress)\r\n    let response = await fetch(authServerAddress + \"/.well-known/openid-configuration\", {\r\n        cache: \"no-cache\",\r\n        mode: \"cors\"\r\n    });\r\n    if (response.ok) {\r\n        var openIdInfo = await response.json();\r\n        console.log(openIdInfo)\r\n        mylog(\"AuthServerMetadata\", openIdInfo);\r\n        return openIdInfo;\r\n    } else {\r\n        throw new Error(\"error retrieving OpenID metadata\")\r\n    }\r\n}\r\n\r\n\r\nasync function getVerifiableCredentialLD(backEndpoint) {\r\n\r\n    var vc = await doGETText(backEndpoint)\r\n\r\n}\r\n\r\nasync function getCredentialOffer(url) {\r\n    const urlParams = new URL(url).searchParams;\r\n    const credentialOfferURI = decodeURIComponent(urlParams.get('credential_offer_uri'));\r\n    console.log(\"Get: \" + credentialOfferURI)\r\n    let response = await fetch(credentialOfferURI, {\r\n        cache: \"no-cache\",\r\n        mode: \"cors\"\r\n    });\r\n    if (response.ok) {\r\n        const credentialOffer = await response.json();\r\n        mylog(\"CredentialOffer\", credentialOffer);\r\n        return credentialOffer;\r\n    } else {\r\n        const errorText = await response.text()\r\n        myerror(response.status + \" \" + response.statusText + \"->\" + errorText)\r\n        throw new Error(response.status + \" \" + response.statusText + \"->\" + errorText)\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Returns the string representation of the SHA-256 hash of a string\r\n * @param {string} string \r\n * @returns {Promise<string>}\r\n */\r\nasync function hashFromString(string) {\r\n    const hash = await crypto.subtle.digest(\"SHA-256\", (new TextEncoder()).encode(string))\r\n    let astr = btoa(String.fromCharCode(...new Uint8Array(hash)))\r\n\r\n    // Remove padding equal characters\r\n    astr = astr.replace(/=+$/, '');\r\n\r\n    // Replace non-url compatible chars with base64 standard chars\r\n    astr = astr.replace(/\\+/g, '-').replace(/\\//g, '_');\r\n\r\n    return astr;\r\n\r\n}\r\n\r\nfunction btoaUrl(input) {\r\n\r\n    // Encode using the standard Javascript function\r\n    let astr = btoa(input)\r\n\r\n    // Replace non-url compatible chars with base64 standard chars\r\n    astr = astr.replace(/\\+/g, '-').replace(/\\//g, '_');\r\n\r\n    return astr;\r\n}\r\n\r\n// async function sendEBSIIDToken(redirectedURL) {\r\n//     // The url should be something like the following:\r\n//     //\r\n//     // https://wallet.mycredential.eu/?\r\n//     // state=e6379c7f-1919-41aa-8194-9767295e1896&\r\n//     // client_id=https%3A%2F%2Fapi-conformance.ebsi.eu%2Fconformance%2Fv3%2Fauth-mock&\r\n//     // redirect_uri=https%3A%2F%2Fapi-conformance.ebsi.eu%2Fconformance%2Fv3%2Fauth-mock%2Fdirect_post&\r\n//     // response_type=id_token&\r\n//     // response_mode=direct_post&\r\n//     // scope=openid&\r\n//     // nonce=a8612b8a-8e8b-461c-a21e-e4b09988fc87&\r\n//     // request_uri=https%3A%2F%2Fapi-conformance.ebsi.eu%2Fconformance%2Fv3%2Fauth-mock%2Frequest_uri%2F3e3a4bb3-3b22-4b14-92bb-3e198658fbf5\r\n\r\n//     mylog(redirectedURL)\r\n//     const urlParams = new URL(redirectedURL).searchParams;\r\n\r\n//     const redirect_uri = decodeURIComponent(urlParams.get('redirect_uri'))\r\n//     console.log(\"redirect_uri\", redirect_uri)\r\n//     const client_id = decodeURIComponent(urlParams.get('client_id'))\r\n//     const state = decodeURIComponent(urlParams.get('state'))\r\n//     const nonce = decodeURIComponent(urlParams.get('nonce'))\r\n\r\n//     // Get my DID\r\n//     const myDID = await window.MHR.storage.didFirst()\r\n\r\n//     const signedstring = await generateEBSIIDToken(myDID.did, client_id, state, nonce)\r\n//     const IDToken = signedstring.signedString\r\n//     console.log(\"IDToken\", IDToken)\r\n\r\n//     var formAttributes = {\r\n//         id_token: IDToken,\r\n//         state: state,\r\n//     }\r\n\r\n//     var formBody = [];\r\n//     for (var property in formAttributes) {\r\n//         var encodedKey = encodeURIComponent(property);\r\n//         var encodedValue = encodeURIComponent(formAttributes[property]);\r\n//         formBody.push(encodedKey + \"=\" + encodedValue);\r\n//     }\r\n//     formBody = formBody.join(\"&\");\r\n//     console.log(\"Body\", formBody)\r\n\r\n//     let resp = await fetch(redirect_uri, {\r\n//         method: \"POST\",\r\n//         redirect: \"follow\",\r\n//         cache: \"no-cache\",\r\n//         headers: {\r\n//             'Content-Type': 'application/x-www-form-urlencoded'\r\n//         },\r\n//         body: formBody,\r\n//         mode: \"cors\"\r\n//     });\r\n\r\n//     if (resp.ok && resp.redirected) {\r\n//         // The reply is the complete JWT\r\n//         debugger\r\n//         await getEBSIAccessToken(resp.url, client_id)\r\n//         return\r\n//     } else {\r\n//         throw new Error(resp.statusText)\r\n//     }\r\n\r\n// }\r\n\r\n// async function getEBSIAccessToken(redirectedURL, client_id) {\r\n//     // The received url is something like:\r\n//     //\r\n//     // https://wallet.mycredential.eu/?\r\n//     // code=d3f7532d-3cd3-4c96-80a4-8876c61b505b\r\n\r\n//     mylog(redirectedURL)\r\n//     const urlParams = new URL(redirectedURL).searchParams;\r\n\r\n//     const code = decodeURIComponent(urlParams.get('code'))\r\n//     console.log(\"code\", code)\r\n\r\n//     // Get my DID\r\n//     const myDID = await window.MHR.storage.didFirst()\r\n\r\n//     const authServerMetaData = await storage.settingsGet(\"authServerMetaData\")\r\n//     const tokenEndpoint = authServerMetaData.token_endpoint\r\n\r\n//     var formAttributes = {\r\n//         grant_type: \"authorization_code\",\r\n//         client_id: myDID.did,\r\n//         code: code,\r\n//         code_verifier: \"this_is_a_code_verifierthis_is_a_code_verifierthis_is_a_code_verifier\"\r\n//     }\r\n//     const formBody = encodeFormAttributes(formAttributes)\r\n//     console.log(tokenEndpoint)\r\n//     console.log(formBody)\r\n\r\n//     let resp = await fetch(tokenEndpoint, {\r\n//         method: \"POST\",\r\n//         redirect: \"follow\",\r\n//         cache: \"no-cache\",\r\n//         headers: {\r\n//             'Content-Type': 'application/x-www-form-urlencoded'\r\n//         },\r\n//         body: formBody,\r\n//         mode: \"cors\"\r\n//     });\r\n\r\n//     if (!resp.ok) {\r\n//         throw new Error(resp.statusText)\r\n//     }\r\n\r\n//     // The reply is the complete JWT\r\n//     const authTokenObject = await resp.json()\r\n//     console.log(\"Auth Token object:\", authTokenObject)\r\n//     debugger\r\n\r\n//     // Get the nonce and access token from the retrieved object\r\n//     const nonce = authTokenObject.c_nonce\r\n//     const access_token = authTokenObject.access_token\r\n\r\n//     // Retrieve the issuer metadata\r\n//     const issuerMetaData = await storage.settingsGet(\"issuerMetaData\")\r\n\r\n//     // Get the proof object that we have to include in the Credential Request\r\n//     const proofObject = await generateEBSIProof(myDID.did, issuerMetaData.credential_issuer, nonce)\r\n//     const proof = proofObject.signedString\r\n\r\n//     // Get the credential supported by issuer\r\n//     const credentialOffer = await storage.settingsGet(\"credentialOffer\")\r\n//     const credentialTypes = credentialOffer.credentials[0].types\r\n\r\n\r\n//     // Get the credential from EBSI\r\n//     const credentialResponse = await requestEBSICredential(proof, access_token, issuerMetaData.credential_endpoint, credentialTypes)\r\n\r\n//     return credentialResponse.credential\r\n    \r\n\r\n// }\r\n\r\nfunction encodeFormAttributes(formAttributes) {\r\n    var formBody = [];\r\n    for (var property in formAttributes) {\r\n        var encodedKey = encodeURIComponent(property);\r\n        var encodedValue = encodeURIComponent(formAttributes[property]);\r\n        formBody.push(encodedKey + \"=\" + encodedValue);\r\n    }\r\n    formBody = formBody.join(\"&\");\r\n    return formBody\r\n\r\n}\r\n\r\nwindow.MHR.register(\"EBSIRedirect\", class extends window.MHR.AbstractPage {\r\n\r\n    constructor(id) {\r\n        console.log(\"EBSIRedirect constructor\")\r\n        super(id)\r\n    }\r\n\r\n    async enter(qrData) {\r\n        mylog(qrData)\r\n        const urlParams = new URL(qrData).searchParams;\r\n\r\n        const redirect_uri = decodeURIComponent(urlParams.get('redirect_uri'))\r\n        console.log(\"redirect_uri\", redirect_uri)\r\n        const client_id = decodeURIComponent(urlParams.get('client_id'))\r\n        const state = decodeURIComponent(urlParams.get('state'))\r\n        const nonce = decodeURIComponent(urlParams.get('nonce'))\r\n\r\n        // Get my DID\r\n        const myDID = await window.MHR.storage.didFirst()\r\n\r\n        const IDToken = await generateEBSIIDToken(myDID, client_id, state, nonce)\r\n        console.log(\"IDToken\", IDToken)\r\n\r\n        var formAttributes = {\r\n            id_token: IDToken,\r\n            state: state,\r\n        }\r\n\r\n        var formBody = [];\r\n        for (var property in formAttributes) {\r\n            var encodedKey = encodeURIComponent(property);\r\n            var encodedValue = encodeURIComponent(formAttributes[property]);\r\n            formBody.push(encodedKey + \"=\" + encodedValue);\r\n        }\r\n        formBody = formBody.join(\"&\");\r\n        console.log(\"Body\", formBody)\r\n\r\n        let resp = await fetch(redirect_uri, {\r\n            method: \"POST\",\r\n            redirect: \"follow\",\r\n            cache: \"no-cache\",\r\n            headers: {\r\n                'Content-Type': 'application/x-www-form-urlencoded'\r\n            },\r\n            body: formBody,\r\n            mode: \"cors\"\r\n        });\r\n\r\n\r\n        if (resp.ok && resp.redirected) {\r\n            // The reply is the complete JWT\r\n            debugger        \r\n            console.log(resp.url)\r\n            location = resp.url\r\n            return\r\n        } else {\r\n            throw new Error(resp.statusText)\r\n        }\r\n\r\n    }\r\n})\r\n\r\n/**\r\n * generateDIDKeyProof creates a JWT which is used as a proof that the creator (the signer of the JWT) contrrols the\r\n * private key associated to the did:key (which is essentially the public key).\r\n * This concrete proof is specialised for OIDC4VCI flows, as indicated by the 'typ' field in the header.\r\n * @param {{did: string, privateKey: JsonWebKey}} subjectDID The did and associated private key object for the Subject\r\n * @param {string} issuerID The did for the Issuer in the OID4VCI flow. Do not confuse with the issuer of the JWT, \r\n * which should be the person who will be receiving the Verifiable Credential.\r\n * @param {string} nonce The challenge received from the Issuer that we have to sign as a proof of possession\r\n * @returns {Promise<string>} The JWT in compact string form\r\n */\r\nasync function generateDIDKeyProof(subjectDID, issuerID, nonce) {\r\n\r\n    const keyStr = subjectDID.did.replace(\"did:key:\", \"\")\r\n    const subjectKid = subjectDID.did + \"#\" + keyStr\r\n\r\n    // Create the headers of the JWT\r\n    var jwtHeaders = {\r\n        typ: 'openid4vci-proof+jwt',\r\n        alg: 'ES256',\r\n        kid: subjectKid\r\n    }\r\n\r\n    // It expires in one day (it could be much shorter in many flows)\r\n    const iat = Math.floor(Date.now()/1000) - 2\r\n    const exp = iat + 86500\r\n\r\n    // The issuer of the JWT is the person who will receive the Verifiable Credential at the end of the OID4VCI flow.\r\n    // This is why the 'iss' claim is set to the did:key of the Subject.\r\n    // The JWT is intended for the entity that is issuing the Verifiable Credential in the OID4VCI flow. This is the\r\n    // reason why the 'aud' claim is set to the did (whatever did method is used) of the VC Issuer. \r\n    var jwtPayload = {\r\n        iss: subjectDID.did,\r\n        aud: issuerID,\r\n        iat: iat,\r\n        exp: exp,\r\n        nonce: nonce\r\n    }\r\n\r\n    // The JWT is signed with the private key associated to the did:key of the creator of the JWT.\r\n    const jwt = await signJWT(jwtHeaders, jwtPayload, subjectDID.privateKey)\r\n    return jwt\r\n\r\n}\r\n\r\nasync function generateEBSIIDToken(subjectDID, issuerID, state, nonce) {\r\n\r\n    const keyStr = subjectDID.did.replace(\"did:key:\", \"\")\r\n    const subjectKid = subjectDID.did + \"#\" + keyStr\r\n\r\n    // Create the request proof for authenticating this request\r\n    var jwtHeaders = {\r\n        typ: 'JWT',\r\n        alg: 'ES256',\r\n        kid: subjectKid\r\n    }\r\n\r\n    const iat = Math.floor(Date.now()/1000) - 2\r\n    const exp = iat + 86500\r\n\r\n    var jwtPayload = {\r\n        iss: subjectDID.did,\r\n        sub: subjectDID.did,\r\n        aud: issuerID,\r\n        iat: iat,\r\n        exp: exp,\r\n        state: state,\r\n        nonce: nonce\r\n    }\r\n\r\n    const jwt = await signJWT(jwtHeaders, jwtPayload, subjectDID.privateKey)\r\n    return jwt\r\n\r\n}\r\n\r\n\r\nwindow.MHR.register(\"EBSIRedirectCode\", class extends window.MHR.AbstractPage {\r\n\r\n    constructor(id) {\r\n        console.log(\"EBSIRedirectCode constructor\")\r\n        super(id)\r\n    }\r\n\r\n    async enter(qrData) {\r\n        mylog(qrData)\r\n        const urlParams = new URL(qrData).searchParams;\r\n        debugger\r\n\r\n        const code = decodeURIComponent(urlParams.get('code'))\r\n        console.log(\"redirect_uri\", redirect_uri)\r\n\r\n        // Get my DID\r\n        const myDID = await window.MHR.storage.didFirst()\r\n\r\n        const IDToken = await generateEBSIIDToken(myDID, client_id, state, nonce)\r\n        console.log(\"IDToken\", IDToken)\r\n        debugger        \r\n\r\n        var formAttributes = {\r\n            id_token: IDToken,\r\n            state: state,\r\n        }\r\n\r\n        var formBody = [];\r\n        for (var property in formAttributes) {\r\n            var encodedKey = encodeURIComponent(property);\r\n            var encodedValue = encodeURIComponent(formAttributes[property]);\r\n            formBody.push(encodedKey + \"=\" + encodedValue);\r\n        }\r\n        formBody = formBody.join(\"&\");\r\n        console.log(\"Body\", formBody)\r\n\r\n        let response = await fetch(redirect_uri, {\r\n            method: \"POST\",\r\n            cache: \"no-cache\",\r\n            headers: {\r\n                'Content-Type': 'application/x-www-form-urlencoded'\r\n            },\r\n            body: formBody,\r\n            mode: \"cors\"\r\n        });\r\n\r\n\r\n        if (response.ok) {\r\n            // The reply is the complete JWT\r\n            return\r\n        } else {\r\n            throw new Error(response.statusText)\r\n        }\r\n\r\n    }\r\n})\r\n\r\n\r\nasync function doGETJSON(serverURL) {\r\n\r\n    try {\r\n        var response = await fetch(serverURL)      \r\n    } catch (error) {\r\n        myerror(error.message)\r\n        await gotoPage(\"ErrorPage\", { \"title\": \"Error fetching data\", \"msg\": error.message })\r\n        return\r\n    }\r\n    if (response.ok) {\r\n        var responseJSON = await response.json();\r\n        mylog(`doFetchJSON ${serverURL}:`, responseJSON)\r\n        return responseJSON;\r\n    } else {\r\n        const errormsg = `doFetchJSON ${serverURL}: ${response.statusText}`\r\n        myerror(errormsg)\r\n        await gotoPage(\"ErrorPage\", { \"title\": \"Error fetching data\", \"msg\": errormsg })\r\n        return\r\n    }                \r\n\r\n}\r\n\r\nasync function doGETText(serverURL) {\r\n\r\n    try {\r\n        var response = await fetch(serverURL, {\r\n            cache: \"no-cache\",\r\n            mode: \"cors\"\r\n        });            \r\n    } catch (error) {\r\n        myerror(error.message)\r\n        await gotoPage(\"ErrorPage\", { \"title\": \"Error fetching data\", \"msg\": error.message })\r\n        return        \r\n    }\r\n    if (response.ok) {\r\n        var responseText = await response.text();\r\n        mylog(`doFetchText ${serverURL}:`, responseText)\r\n        return responseText;\r\n    } else {\r\n        const errormsg = `doFetchText ${serverURL}: ${response.statusText}`\r\n        myerror(errormsg)\r\n        await gotoPage(\"ErrorPage\", { \"title\": \"Error fetching data\", \"msg\": errormsg })\r\n        return\r\n    }                \r\n\r\n}\r\n\r\nasync function doPOST(serverURL, body) {\r\n    try {\r\n        var response = await fetch(serverURL,\r\n        {\r\n            method: \"POST\",\r\n            body: JSON.stringify(body),\r\n            headers: {\r\n                \"Content-Type\": \"application/json\",\r\n            },\r\n            cache: \"no-cache\",\r\n        })\r\n        console.log(response)            \r\n    } catch (error) {\r\n        myerror(error.message)\r\n        await gotoPage(\"ErrorPage\", { \"title\": \"Error sending data\", \"msg\": error.message })\r\n        return\r\n    }\r\n    if (response.ok) {\r\n        var responseJSON = await response.json();\r\n        console.log(responseJSON)\r\n        mylog(`doPOST ${serverURL}:`, responseJSON)\r\n        return responseJSON;\r\n    } else {\r\n        const errormsg = `doPOST ${serverURL}: ${response.statusText}`\r\n        myerror(errormsg)\r\n        await gotoPage(\"ErrorPage\", { \"title\": \"Error sending data\", \"msg\": errormsg })\r\n        return\r\n    }                \r\n\r\n}"],
  "mappings": "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",
  "names": ["qrData", "html", "theHtml", "vc", "div", "redirect_uri", "client_id", "state", "nonce", "qrData", "redirect_uri", "client_id", "state", "nonce"]
}
