{
  "version": 3,
  "sources": ["../../front/node_modules/js-base64/base64.mjs", "../../front/src/pages/SIOPSelectCredential.js"],
  "sourcesContent": ["/**\n *  base64.ts\n *\n *  Licensed under the BSD 3-Clause License.\n *    http://opensource.org/licenses/BSD-3-Clause\n *\n *  References:\n *    http://en.wikipedia.org/wiki/Base64\n *\n * @author Dan Kogai (https://github.com/dankogai)\n */\nconst version = '3.7.5';\n/**\n * @deprecated use lowercase `version`.\n */\nconst VERSION = version;\nconst _hasatob = typeof atob === 'function';\nconst _hasbtoa = typeof btoa === 'function';\nconst _hasBuffer = typeof Buffer === 'function';\nconst _TD = typeof TextDecoder === 'function' ? new TextDecoder() : undefined;\nconst _TE = typeof TextEncoder === 'function' ? new TextEncoder() : undefined;\nconst b64ch = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\nconst b64chs = Array.prototype.slice.call(b64ch);\nconst b64tab = ((a) => {\n    let tab = {};\n    a.forEach((c, i) => tab[c] = i);\n    return tab;\n})(b64chs);\nconst b64re = /^(?:[A-Za-z\\d+\\/]{4})*?(?:[A-Za-z\\d+\\/]{2}(?:==)?|[A-Za-z\\d+\\/]{3}=?)?$/;\nconst _fromCC = String.fromCharCode.bind(String);\nconst _U8Afrom = typeof Uint8Array.from === 'function'\n    ? Uint8Array.from.bind(Uint8Array)\n    : (it) => new Uint8Array(Array.prototype.slice.call(it, 0));\nconst _mkUriSafe = (src) => src\n    .replace(/=/g, '').replace(/[+\\/]/g, (m0) => m0 == '+' ? '-' : '_');\nconst _tidyB64 = (s) => s.replace(/[^A-Za-z0-9\\+\\/]/g, '');\n/**\n * polyfill version of `btoa`\n */\nconst btoaPolyfill = (bin) => {\n    // console.log('polyfilled');\n    let u32, c0, c1, c2, asc = '';\n    const pad = bin.length % 3;\n    for (let i = 0; i < bin.length;) {\n        if ((c0 = bin.charCodeAt(i++)) > 255 ||\n            (c1 = bin.charCodeAt(i++)) > 255 ||\n            (c2 = bin.charCodeAt(i++)) > 255)\n            throw new TypeError('invalid character found');\n        u32 = (c0 << 16) | (c1 << 8) | c2;\n        asc += b64chs[u32 >> 18 & 63]\n            + b64chs[u32 >> 12 & 63]\n            + b64chs[u32 >> 6 & 63]\n            + b64chs[u32 & 63];\n    }\n    return pad ? asc.slice(0, pad - 3) + \"===\".substring(pad) : asc;\n};\n/**\n * does what `window.btoa` of web browsers do.\n * @param {String} bin binary string\n * @returns {string} Base64-encoded string\n */\nconst _btoa = _hasbtoa ? (bin) => btoa(bin)\n    : _hasBuffer ? (bin) => Buffer.from(bin, 'binary').toString('base64')\n        : btoaPolyfill;\nconst _fromUint8Array = _hasBuffer\n    ? (u8a) => Buffer.from(u8a).toString('base64')\n    : (u8a) => {\n        // cf. https://stackoverflow.com/questions/12710001/how-to-convert-uint8-array-to-base64-encoded-string/12713326#12713326\n        const maxargs = 0x1000;\n        let strs = [];\n        for (let i = 0, l = u8a.length; i < l; i += maxargs) {\n            strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));\n        }\n        return _btoa(strs.join(''));\n    };\n/**\n * converts a Uint8Array to a Base64 string.\n * @param {boolean} [urlsafe] URL-and-filename-safe a la RFC4648 ยง5\n * @returns {string} Base64 string\n */\nconst fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);\n// This trick is found broken https://github.com/dankogai/js-base64/issues/130\n// const utob = (src: string) => unescape(encodeURIComponent(src));\n// reverting good old fationed regexp\nconst cb_utob = (c) => {\n    if (c.length < 2) {\n        var cc = c.charCodeAt(0);\n        return cc < 0x80 ? c\n            : cc < 0x800 ? (_fromCC(0xc0 | (cc >>> 6))\n                + _fromCC(0x80 | (cc & 0x3f)))\n                : (_fromCC(0xe0 | ((cc >>> 12) & 0x0f))\n                    + _fromCC(0x80 | ((cc >>> 6) & 0x3f))\n                    + _fromCC(0x80 | (cc & 0x3f)));\n    }\n    else {\n        var cc = 0x10000\n            + (c.charCodeAt(0) - 0xD800) * 0x400\n            + (c.charCodeAt(1) - 0xDC00);\n        return (_fromCC(0xf0 | ((cc >>> 18) & 0x07))\n            + _fromCC(0x80 | ((cc >>> 12) & 0x3f))\n            + _fromCC(0x80 | ((cc >>> 6) & 0x3f))\n            + _fromCC(0x80 | (cc & 0x3f)));\n    }\n};\nconst re_utob = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFFF]|[^\\x00-\\x7F]/g;\n/**\n * @deprecated should have been internal use only.\n * @param {string} src UTF-8 string\n * @returns {string} UTF-16 string\n */\nconst utob = (u) => u.replace(re_utob, cb_utob);\n//\nconst _encode = _hasBuffer\n    ? (s) => Buffer.from(s, 'utf8').toString('base64')\n    : _TE\n        ? (s) => _fromUint8Array(_TE.encode(s))\n        : (s) => _btoa(utob(s));\n/**\n * converts a UTF-8-encoded string to a Base64 string.\n * @param {boolean} [urlsafe] if `true` make the result URL-safe\n * @returns {string} Base64 string\n */\nconst encode = (src, urlsafe = false) => urlsafe\n    ? _mkUriSafe(_encode(src))\n    : _encode(src);\n/**\n * converts a UTF-8-encoded string to URL-safe Base64 RFC4648 ยง5.\n * @returns {string} Base64 string\n */\nconst encodeURI = (src) => encode(src, true);\n// This trick is found broken https://github.com/dankogai/js-base64/issues/130\n// const btou = (src: string) => decodeURIComponent(escape(src));\n// reverting good old fationed regexp\nconst re_btou = /[\\xC0-\\xDF][\\x80-\\xBF]|[\\xE0-\\xEF][\\x80-\\xBF]{2}|[\\xF0-\\xF7][\\x80-\\xBF]{3}/g;\nconst cb_btou = (cccc) => {\n    switch (cccc.length) {\n        case 4:\n            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)\n                | ((0x3f & cccc.charCodeAt(1)) << 12)\n                | ((0x3f & cccc.charCodeAt(2)) << 6)\n                | (0x3f & cccc.charCodeAt(3)), offset = cp - 0x10000;\n            return (_fromCC((offset >>> 10) + 0xD800)\n                + _fromCC((offset & 0x3FF) + 0xDC00));\n        case 3:\n            return _fromCC(((0x0f & cccc.charCodeAt(0)) << 12)\n                | ((0x3f & cccc.charCodeAt(1)) << 6)\n                | (0x3f & cccc.charCodeAt(2)));\n        default:\n            return _fromCC(((0x1f & cccc.charCodeAt(0)) << 6)\n                | (0x3f & cccc.charCodeAt(1)));\n    }\n};\n/**\n * @deprecated should have been internal use only.\n * @param {string} src UTF-16 string\n * @returns {string} UTF-8 string\n */\nconst btou = (b) => b.replace(re_btou, cb_btou);\n/**\n * polyfill version of `atob`\n */\nconst atobPolyfill = (asc) => {\n    // console.log('polyfilled');\n    asc = asc.replace(/\\s+/g, '');\n    if (!b64re.test(asc))\n        throw new TypeError('malformed base64.');\n    asc += '=='.slice(2 - (asc.length & 3));\n    let u24, bin = '', r1, r2;\n    for (let i = 0; i < asc.length;) {\n        u24 = b64tab[asc.charAt(i++)] << 18\n            | b64tab[asc.charAt(i++)] << 12\n            | (r1 = b64tab[asc.charAt(i++)]) << 6\n            | (r2 = b64tab[asc.charAt(i++)]);\n        bin += r1 === 64 ? _fromCC(u24 >> 16 & 255)\n            : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255)\n                : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);\n    }\n    return bin;\n};\n/**\n * does what `window.atob` of web browsers do.\n * @param {String} asc Base64-encoded string\n * @returns {string} binary string\n */\nconst _atob = _hasatob ? (asc) => atob(_tidyB64(asc))\n    : _hasBuffer ? (asc) => Buffer.from(asc, 'base64').toString('binary')\n        : atobPolyfill;\n//\nconst _toUint8Array = _hasBuffer\n    ? (a) => _U8Afrom(Buffer.from(a, 'base64'))\n    : (a) => _U8Afrom(_atob(a).split('').map(c => c.charCodeAt(0)));\n/**\n * converts a Base64 string to a Uint8Array.\n */\nconst toUint8Array = (a) => _toUint8Array(_unURI(a));\n//\nconst _decode = _hasBuffer\n    ? (a) => Buffer.from(a, 'base64').toString('utf8')\n    : _TD\n        ? (a) => _TD.decode(_toUint8Array(a))\n        : (a) => btou(_atob(a));\nconst _unURI = (a) => _tidyB64(a.replace(/[-_]/g, (m0) => m0 == '-' ? '+' : '/'));\n/**\n * converts a Base64 string to a UTF-8 string.\n * @param {String} src Base64 string.  Both normal and URL-safe are supported\n * @returns {string} UTF-8 string\n */\nconst decode = (src) => _decode(_unURI(src));\n/**\n * check if a value is a valid Base64 string\n * @param {String} src a value to check\n  */\nconst isValid = (src) => {\n    if (typeof src !== 'string')\n        return false;\n    const s = src.replace(/\\s+/g, '').replace(/={0,2}$/, '');\n    return !/[^\\s0-9a-zA-Z\\+/]/.test(s) || !/[^\\s0-9a-zA-Z\\-_]/.test(s);\n};\n//\nconst _noEnum = (v) => {\n    return {\n        value: v, enumerable: false, writable: true, configurable: true\n    };\n};\n/**\n * extend String.prototype with relevant methods\n */\nconst extendString = function () {\n    const _add = (name, body) => Object.defineProperty(String.prototype, name, _noEnum(body));\n    _add('fromBase64', function () { return decode(this); });\n    _add('toBase64', function (urlsafe) { return encode(this, urlsafe); });\n    _add('toBase64URI', function () { return encode(this, true); });\n    _add('toBase64URL', function () { return encode(this, true); });\n    _add('toUint8Array', function () { return toUint8Array(this); });\n};\n/**\n * extend Uint8Array.prototype with relevant methods\n */\nconst extendUint8Array = function () {\n    const _add = (name, body) => Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));\n    _add('toBase64', function (urlsafe) { return fromUint8Array(this, urlsafe); });\n    _add('toBase64URI', function () { return fromUint8Array(this, true); });\n    _add('toBase64URL', function () { return fromUint8Array(this, true); });\n};\n/**\n * extend Builtin prototypes with relevant methods\n */\nconst extendBuiltins = () => {\n    extendString();\n    extendUint8Array();\n};\nconst gBase64 = {\n    version: version,\n    VERSION: VERSION,\n    atob: _atob,\n    atobPolyfill: atobPolyfill,\n    btoa: _btoa,\n    btoaPolyfill: btoaPolyfill,\n    fromBase64: decode,\n    toBase64: encode,\n    encode: encode,\n    encodeURI: encodeURI,\n    encodeURL: encodeURI,\n    utob: utob,\n    btou: btou,\n    decode: decode,\n    isValid: isValid,\n    fromUint8Array: fromUint8Array,\n    toUint8Array: toUint8Array,\n    extendString: extendString,\n    extendUint8Array: extendUint8Array,\n    extendBuiltins: extendBuiltins,\n};\n// makecjs:CUT //\nexport { version };\nexport { VERSION };\nexport { _atob as atob };\nexport { atobPolyfill };\nexport { _btoa as btoa };\nexport { btoaPolyfill };\nexport { decode as fromBase64 };\nexport { encode as toBase64 };\nexport { utob };\nexport { encode };\nexport { encodeURI };\nexport { encodeURI as encodeURL };\nexport { btou };\nexport { decode };\nexport { isValid };\nexport { fromUint8Array };\nexport { toUint8Array };\nexport { extendString };\nexport { extendUint8Array };\nexport { extendBuiltins };\n// and finally,\nexport { gBase64 as Base64 };\n", "import { Base64 } from 'js-base64';\n\nimport { decodeJWT } from '../components/jwt'\nimport { renderLEARCredentialCard } from '../components/renderLEAR';\n\n// @ts-ignore\nconst MHR = window.MHR\n\n// Copy some globals to make code less verbose\nlet gotoPage = MHR.gotoPage\nlet goHome = MHR.goHome\nlet storage = MHR.storage\nlet myerror = window.MHR.storage.myerror\nlet mylog = window.MHR.storage.mylog\nlet html = MHR.html\n\n// We will perform SIOP/OpenID4VP Authentication flow\nMHR.register(\"SIOPSelectCredential\", class extends MHR.AbstractPage {\n    WebAuthnSupported = false\n    PlatformAuthenticatorSupported = false\n\n    constructor(id) {\n        super(id)\n    }\n\n    /**\n     * @param {string} openIdUrl\n     */\n    async enter(openIdUrl) {\n        // openIdUrl is the url for a SIOP/OpenID4VP Authentication Request\n        let html = this.html\n\n        mylog(\"Inside SIOPSelectCredential:\", openIdUrl)\n        if (openIdUrl == null) {\n            myerror(\"No URL has been specified\")\n            this.showError(\"Error\", \"No URL has been specified\")\n            return\n        }\n\n        // check whether current browser supports WebAuthn\n        if (window.PublicKeyCredential) {\n            this.WebAuthnSupported = true\n\n            // Check for PlatformAuthenticator\n            let available = await PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable()\n            if (available) {\n                this.PlatformAuthenticatorSupported = true\n            } \n        }\n\n        // Derive from the received URL a simple one ready for parsing\n        openIdUrl = openIdUrl.replace(\"openid4vp://?\", \"https://wallet.mycredential.eu//?\")\n\n        // Convert the input string to a URL object\n        const inputURL = new URL(openIdUrl)\n\n        // The URL can have two formats:\n        // 1. An OpenId url with an Authentication Request object specified in the query parameters\n        // 2. A url specifying a reference to an Authentication Request object\n        //\n        // We detect which one is it by looking at the query parameters:\n        // 1. If 'scope' is in the url, then the AR object is in the url\n        // 2. If 'jar' is in the url, then the AR is by reference, and the object can be retrieved\n        //    by fetching the object.\n\n        // Get the relevant parameters from the query string\n        const params = new URLSearchParams(inputURL.search)\n        var request_uri = params.get(\"request_uri\")\n        if (!request_uri) {\n            gotoPage(\"ErrorPage\", {\n                title: \"Error\",\n                msg: \"'request_uri' parameter not found in URL\"\n            });\n            return\n        }\n\n        request_uri = decodeURIComponent(request_uri)\n\n        const authRequestJWT = await getAuthRequest(request_uri)\n        console.log(authRequestJWT)\n        if (authRequestJWT == \"error\") {\n            this.showError(\"Error\", \"Error fetching Authorization Request\")\n            return    \n        }\n        const authRequest = decodeJWT(authRequestJWT)\n        console.log(\"Decoded authRequest\", authRequest)\n\n        const scope = authRequest.body.scope\n        const response_uri = authRequest.body.response_uri\n        const state = authRequest.body.state\n\n        mylog(\"state\", state)\n        mylog(\"request_uri\", request_uri)\n        mylog(\"scope\", scope)\n\n        // Get the last segment of the credential type in 'scope'\n        const scopeParts = scope.split(\".\")\n        if (scopeParts.length == 0) {\n            myerror(\"Invalid scope specified\")\n            this.showError(\"Error\", \"Invalid scope specified\")\n            return\n        }\n        const displayCredType = scopeParts[scopeParts.length-1]       \n\n        // response_uri is the endpoint where we have to send the Authentication Response\n        // We are going to extract the RP identity from that URL\n        var rpURL = new URL(response_uri)\n        var rpDomain = rpURL.hostname \n\n        // Retrieve all credentials from storage, to process them in memory\n        var credStructs = await storage.credentialsGetAllRecent()\n        if (!credStructs) {\n            let theHtml = html`\n                <div class=\"w3-panel w3-margin w3-card w3-center w3-round color-error\">\n                <p>You do not have a Verifiable Credential.</p>\n                <p>Please go to an Issuer to obtain one.</p>\n                </div>\n            `;\n            this.render(theHtml)\n            return\n        }\n\n        // Select all credentials of the requested type, specified in \"scope\"\n        var credentials = []\n        for (const cc of credStructs) {\n            const vc = cc.decoded\n            const vctype = vc.type\n            if (vctype.includes(scope)) {\n                console.log(\"found\", cc.encoded)\n                credentials.push(vc)\n            }\n        }\n\n        // Error message if no credentials satisfy the condition \n        if (credentials.length == 0) {\n            var msg = html`\n                <p><b>${rpDomain}</b> has requested a Verifiable Credential of type ${displayCredType} to perform authentication,\n                but you do not have any credential of that type.</p>\n                <p>Please go to an Issuer to obtain one.</p>\n            `\n            this.showError(\"Error\", msg)\n            return\n        }\n\n        let theHtml = html`\n        <ion-card color=\"warning\">\n                \n            <ion-card-content>\n            <div style=\"line-height:1.2\"><b>${rpDomain}</b> <span class=\"text-small\">has requested a Verifiable Credential of type ${displayCredType} to perform authentication.</span></div>\n            </ion-card-content>\n            \n        </ion-card>\n\n        ${credentials.map(cred => html`${vcToHtml(cred, response_uri, state, this.WebAuthnSupported)}`)}\n        \n        `\n\n        this.render(theHtml)\n\n    }\n\n})\n\n// Render the credential with buttons so the user can select it for authentication\nfunction vcToHtml(vc, response_uri, state, webAuthnSupported) {\n\n    // TODO: retrieve the holder and its private key from DB\n    // Get the holder that will present the credential\n    // We get this from the credential subject\n    const holder = vc.credentialSubject.id\n\n    var credentials = [vc]\n\n    const div = html`\n    <ion-card>\n        ${renderLEARCredentialCard(vc)}\n\n        <div class=\"ion-margin-start ion-margin-bottom\">\n            <ion-button @click=${()=> MHR.cleanReload()}>\n                <ion-icon slot=\"start\" name=\"chevron-back\"></ion-icon>\n                ${T(\"Cancel\")}\n            </ion-button>\n\n            <ion-button @click=${(e)=> sendAuthenticationResponse(e, holder, response_uri, credentials, state, webAuthnSupported)}>\n                <ion-icon slot=\"start\" name=\"paper-plane\"></ion-icon>\n                ${T(\"Send Credential\")}\n            </ion-button>\n        </div>\n    </ion-card>\n    `\n\n    return div\n\n}\n\n\n// sendAuthenticationResponse prepares an Authentication Response and sends it to the server as specified in the endpoint\nasync function sendAuthenticationResponse(e, holder, backEndpoint, credentials, state, authSupported) {\n    e.preventDefault();\n\n    const endpointURL  = new URL(backEndpoint)\n    const origin = endpointURL.origin\n\n    mylog(\"sending AuthenticationResponse to:\", backEndpoint + \"?state=\" + state)\n\n    const uuid = self.crypto.randomUUID()\n\n    // Create the vp_token structure\n    var vpToken = {\n        context: [\"https://www.w3.org/ns/credentials/v2\"],\n        type: [\"VerifiablePresentation\"],\n        id: uuid,\n        verifiableCredential: credentials,\n        holder: holder\n    }\n    mylog(\"The encoded vpToken \", Base64.encodeURI(JSON.stringify(vpToken)))\n\n    // Create the top-level structure for the Authentication Response\n    var formAttributes = {\n        'vp_token': Base64.encodeURI(JSON.stringify(vpToken)),\n        'presentation_submission': Base64.encodeURI(JSON.stringify(presentationSubmissionJWT()))\n    }\n    // var formBody = [];\n    // for (var property in formAttributes) {\n    //     var encodedKey = encodeURIComponent(property);\n    //     var encodedValue = encodeURIComponent(formAttributes[property]);\n    //     formBody.push(encodedKey + \"=\" + encodedValue);\n    // }\n\n    // var formBody = formBody.join(\"&\");\n\n    // Encode in JSON to put it in the body of the POST\n    var formBody = JSON.stringify(formAttributes)\n    mylog(\"The body: \" + formBody)\n\n    // Send the Authentication Response\n    try {\n        let response = await fetch(backEndpoint + \"?state=\" + state, {\n            method: \"POST\",\n            mode: \"cors\",\n            cache: \"no-cache\",\n            headers: {\n                'Content-Type': 'application/x-www-form-urlencoded',\n            },\n            body: formBody,\n        })\n\n        if (!authSupported) {\n            gotoPage(\"ErrorPage\", {\n                title: \"Error\",\n                msg: \"Authenticator not supported in this device\"\n            });\n            return\n        }\n\n        if (response.status == 200) {\n            const res = await response.json()\n            mylog(res)\n\n            // Check if the server requires the authenticator to be used\n            if (res.authenticatorRequired == \"yes\") {\n\n                res[\"origin\"] = origin\n                res[\"state\"] = state\n\n                mylog(\"Authenticator required\")\n                // The credential has been sent\n                gotoPage(\"AuthenticatorPage\", res);\n                return\n            } else {\n                gotoPage(\"AuthenticatorSuccessPage\")\n                return\n            }\n        }\n\n        // There was an error, present it\n        myerror(\"error sending credential\", response.status)\n        const res = await response.text()\n        mylog(\"response:\", res)\n\n        gotoPage(\"ErrorPage\", {\n            title: \"Error\",\n            msg: \"Error sending the credential\"\n        });\n        return\n\n    } catch (error) {\n        // There was an error, present it\n        myerror(error)\n        gotoPage(\"ErrorPage\", {\n            title: \"Error\",\n            msg: \"Error sending the credential\"\n        });\n        return\n    }\n}\n\nvar apiPrefix = \"/webauthn\"\n\n// registerUser asks the authenticator device where the wallet is running for a new WebAuthn credential\n// and sends the new credential to the server, which will store it associated to the user+device \nasync function registerUser(origin, username, state) {\n\n    try {\n\n        // Get from the server the CredentialCreationOptions\n        // It will be associated to the username that corresponds to the current state, which is the\n        // username inside the credential that was sent to the Verifier\n        var response = await fetch(origin + apiPrefix + '/register/begin/' + username + \"?state=\" + state,\n            {\n                mode: \"cors\"\n            })\n        if (!response.ok) {\n            var errorText = await response.text()\n            mylog(errorText)\n            return \"error\"\n        }\n        var responseJSON = await response.json()\n        var credentialCreationOptions = responseJSON.options\n\n        // This request is associated to a session in the server. We will send the response associated to that session\n        // so the server can match the reply with the request\n        var session = responseJSON.session\n        \n        mylog(\"Received CredentialCreationOptions\", credentialCreationOptions)\n        mylog(\"Session:\", session)\n\n\n        // Decode the fields that are b64Url encoded for transmission\n        credentialCreationOptions.publicKey.challenge = bufferDecode(credentialCreationOptions.publicKey.challenge);\n        credentialCreationOptions.publicKey.user.id = bufferDecode(credentialCreationOptions.publicKey.user.id);\n\n        // Decode each of the excluded credentials\n        // This is a list of existing credentials in the server, to avoid the authenticator creating a new one\n        // if the server already has a credential for this authenticator\n        if (credentialCreationOptions.publicKey.excludeCredentials) {\n            for (var i = 0; i < credentialCreationOptions.publicKey.excludeCredentials.length; i++) {\n                credentialCreationOptions.publicKey.excludeCredentials[i].id = bufferDecode(credentialCreationOptions.publicKey.excludeCredentials[i].id);\n            }\n        }\n\n        // Make the Authenticator create the credential\n        mylog(\"creating new Authenticator credential\")\n        try {\n            var credential = await navigator.credentials.create({\n                publicKey: credentialCreationOptions.publicKey\n            })\n        } catch (error) {\n            myerror(error)\n            return error\n        }\n\n        mylog(\"Authenticator created Credential\", credential)\n\n        // Get the fields that we should encode for transmission to the server\n        let attestationObject = credential.response.attestationObject;\n        let clientDataJSON = credential.response.clientDataJSON;\n        let rawId = credential.rawId;\n\n        // Create the object to send\n        var data = {\n            id: credential.id,\n            rawId: bufferEncode(rawId),\n            type: credential.type,\n            response: {\n                attestationObject: bufferEncode(attestationObject),\n                clientDataJSON: bufferEncode(clientDataJSON),\n            },\n        }\n\n        var wholeData = {\n            response: data,\n            session: session\n        }\n\n        // Perform a POST to the server\n        mylog(\"sending Authenticator credential to server\")\n        var response = await fetch(origin + apiPrefix + '/register/finish/' + username + \"?state=\" + state, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'session_id': session\n            },\n            mode: 'cors',\n            body: JSON.stringify(wholeData) // body data type must match \"Content-Type\" header\n        });\n        if (!response.ok) {\n            var errorText = await response.text()\n            mylog(errorText)\n            return \"error\"\n        }\n\n        mylog(\"Authenticator credential sent successfully to server\")\n        return\n\n\n    } catch (error) {\n        myerror(error)\n        return error\n    }\n\n}\n\n\nasync function loginUser(origin, username, state) {\n\n    try {\n\n        // Get from the server the CredentialRequestOptions\n        var response = await fetch(origin + apiPrefix + '/login/begin/' + username + \"?state=\" + state,\n            {\n                mode: \"cors\"\n            })\n        if (!response.ok) {\n            myerror(\"error requesting CredentialRequestOptions\", response.status)\n            return \"error\"\n        }\n\n        var responseJSON = await response.json()\n        var credentialRequestOptions = responseJSON.options\n        var session = responseJSON.session\n\n        mylog(\"Received CredentialRequestOptions\", credentialRequestOptions)\n\n        // Decode the challenge from the server\n        credentialRequestOptions.publicKey.challenge = bufferDecode(credentialRequestOptions.publicKey.challenge)\n\n        // Decode each of the allowed credentials\n        credentialRequestOptions.publicKey.allowCredentials.forEach(function (listItem) {\n            listItem.id = bufferDecode(listItem.id)\n        });\n\n        // Call the authenticator to create the assertion\n        try {\n            var assertion = await navigator.credentials.get({\n                publicKey: credentialRequestOptions.publicKey\n            })\n            if (assertion == null) {\n                myerror(\"null assertion received from authenticator device\")\n                return \"error\"\n            }\n        } catch (error) {\n            // Log and present the error page\n            myerror(error)\n            return error\n        }\n\n        mylog(\"Authenticator created Assertion\", assertion)\n\n        // Get the fields that we should encode for transmission to the server\n        let authData = assertion.response.authenticatorData\n        let clientDataJSON = assertion.response.clientDataJSON\n        let rawId = assertion.rawId\n        let sig = assertion.response.signature\n        let userHandle = assertion.response.userHandle\n\n        // Create the object to send\n        var data = {\n            id: assertion.id,\n            rawId: bufferEncode(rawId),\n            type: assertion.type,\n            response: {\n                authenticatorData: bufferEncode(authData),\n                clientDataJSON: bufferEncode(clientDataJSON),\n                signature: bufferEncode(sig),\n                userHandle: bufferEncode(userHandle),\n            },\n        }\n\n        // The wrapper object for the POST body\n        var wholeData = {\n            response: data,\n            session: session\n        }\n\n        // Perform a POST to the server\n        try {\n            \n            var response = await fetch(origin + apiPrefix + '/login/finish/' + username + \"?state=\" + state, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'session_id': session\n                },\n                mode: 'cors',\n                body: JSON.stringify(wholeData)\n            });\n\n            if (!response.ok) {\n                var errorText = await response.text()\n                mylog(errorText)\n                return \"error\"\n            }\n\n            return\n    \n\n        } catch (error) {\n            myerror(error)\n            return error        \n        }\n\n    } catch (error) {\n        myerror(error)\n        return error\n    }\n\n\n}\n\nfunction presentationSubmission() {\n    return {\n        \"definition_id\": \"SingleCredentialPresentation\",\n        \"id\": \"SingleCredentialSubmission\",\n        \"descriptor_map\": [{\n            \"id\": \"single_credential\",\n            \"path\": \"$\",\n            \"format\": \"ldp_vp\",\n            \"path_nested\": {\n                \"format\": \"ldp_vc\",\n                \"path\": \"$.verifiableCredential[0]\"\n            }\n        }]\n    }\n}\n\nfunction presentationSubmissionJWT() {\n    return {\n        \"definition_id\": \"SingleCredentialPresentation\",\n        \"id\": \"SingleCredentialSubmission\",\n        \"descriptor_map\": [{\n            \"id\": \"single_credential\",\n            \"path\": \"$\",\n            \"format\": \"jwt_vp_json\",\n            \"path_nested\": {\n                \"format\": \"jwt_vc_json\",\n                \"path\": \"$.verifiableCredential[0]\"\n            }\n        }]\n    }\n}\n\n\n// Base64 to ArrayBuffer\nfunction bufferDecode(value) {\n    return Uint8Array.from(atob(value), c => c.charCodeAt(0));\n}\n\n// ArrayBuffer to URLBase64\nfunction bufferEncode(value) {\n    return btoa(String.fromCharCode.apply(null, new Uint8Array(value)))\n        .replace(/\\+/g, \"-\")\n        .replace(/\\//g, \"_\")\n        .replace(/=/g, \"\");;\n}\n\nasync function getAuthRequest(uri) {\n    var response = await fetch(uri,\n        {\n            mode: \"cors\"\n        })\n    if (!response.ok) {\n        var errorText = await response.text()\n        mylog(errorText)\n        return \"error\"\n    }\n    var responseText = await response.text()\n    return responseText\n}"],
  "mappings": "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",
  "names": ["html", "theHtml", "res"]
}
