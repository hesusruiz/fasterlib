{
  "version": 3,
  "sources": ["../../front/src/pages/ScanQrPage.js"],
  "sourcesContent": ["import { getPreferredVideoDevice, getPlatformOS } from '../components/camerainfo'\r\n\r\nlet myerror = window.MHR.storage.myerror\r\nlet mylog = window.MHR.storage.mylog\r\nlet html = window.MHR.html\r\n\r\n// This is to facilitate debugging of certificates\r\nvar testQRdata = \"HC1:NC\"\r\n\r\nvar testQR = {\r\n    text: testQRdata\r\n}\r\n\r\n// Set the QR raw data above and enable debugging setting this flag to true\r\nvar debugging = false\r\n\r\n// Types of QR codes that we can scan\r\nconst QR_UNKNOWN = 0\r\nconst QR_URL = 1\r\nconst QR_MULTI = 2\r\nconst QR_HC1 = 3\r\nconst QR_SIOP_URL = \"QR_SIOP_URL\"\r\nconst QR_W3C_VC = \"QR_W3C_VC\"\r\nconst QR_OIDC4VCI = \"QR_OIDC4VCI\"\r\n\r\n\r\nwindow.MHR.register(\"ScanQrPage\", class extends window.MHR.AbstractPage {\r\n    displayPage                 // The page name used to display the HC1 QR code\r\n    detectionInterval = 200     // Milliseconds between attempts to decode QR\r\n    videoElement = {}           // DOMElement where the video is displayed, reused across invocations\r\n    nativeBarcodeDetector       // Instance of the native barcode detector object\r\n    zxingReader                 // Barcode detector in JavaScript\r\n    lastUsedCameraId            // The last used camera ID\r\n    canvasElement\r\n    canvasSpace\r\n\r\n    constructor(id) {\r\n    \r\n        super(id);\r\n\r\n        // Check if native barcode detection is supported\r\n        if (!('BarcodeDetector' in window)) {\r\n            mylog('Barcode Detector is not supported by this browser.')\r\n\r\n            // Native support not available, import the ZXING javascript library\r\n            this.zxingPromise = import('@zxing/browser')\r\n        } else {\r\n            mylog('Barcode Detector supported!');\r\n\r\n            // create new detector\r\n            this.nativeBarcodeDetector = new BarcodeDetector({ formats: ['qr_code'] });\r\n        }\r\n\r\n        this.videoElement = {}\r\n        this.canvasElement = document.createElement('canvas')\r\n        this.canvasSpace = this.canvasElement.getContext(\"2d\")\r\n\r\n    }\r\n\r\n    // Scan a QR and then route to the displayPage to display the QR\r\n    async enter(displayPage) {\r\n\r\n        // displayPage is the page that should display the scanned QR\r\n        // If not specified, we default to the LoadAndVerifyQRVC page\r\n        if (!displayPage) {\r\n            displayPage = \"LoadAndVerifyQRVC\"\r\n        }\r\n        // Set as a local class instance variable\r\n        this.displayPage = displayPage\r\n\r\n        // If debugging, just try to decode the test QR\r\n        if (debugging) {\r\n            await this.processQRpiece(testQR, displayPage)\r\n            return\r\n        }\r\n\r\n        // Initialize the non-native QR reader if needed\r\n        if (!this.nativeBarcodeDetector) {\r\n            let zxing = await this.zxingPromise\r\n            this.zxingReader = new zxing.BrowserQRCodeReader()\r\n        }\r\n\r\n        // Select the camera and store locally for later uses\r\n        this.lastUsedCameraId = await this.selectCamera()\r\n\r\n        // Display the screen with the video element\r\n        // The 'ref' in the template will set the 'current' property in the specified object\r\n        // to the video DOM element. In this case, the video DOM element can be accessed later at\r\n        // this.videoElement.current\r\n        let theHtml = html`<div class=\"w3-content\" style=\"max-width:500px\">\r\n        <video style=\"max-width:500px\" ref=${this.videoElement} oncanPlay=${()=>this.canPlay()}></video>\r\n        </div>`;\r\n        this.render(theHtml)\r\n\r\n        let constraints;\r\n        if (!this.lastUsedCameraId) {\r\n            mylog(\"Constraints without camera\")\r\n            constraints = {\r\n                audio: false,\r\n                video: {\r\n                    // width: { ideal: 1080, max: 1920 },\r\n                    facingMode: \"environment\"\r\n                }\r\n            }\r\n        } else {\r\n            mylog(\"Constraints with deviceID:\", this.lastUsedCameraId)\r\n            constraints = {\r\n                audio: false,\r\n                video: {\r\n                    // width: { ideal: 1080, max: 1920 },\r\n                    deviceId: this.lastUsedCameraId\r\n                }\r\n            }\r\n        }\r\n\r\n        let stream;\r\n        try {\r\n            // Request a stream which forces the system to ask permission to the user\r\n            stream = await navigator.mediaDevices.getUserMedia(constraints);\r\n            let videoTracks = stream.getVideoTracks()\r\n            for (let i = 0; i < videoTracks.length; i++) {\r\n                let caps = videoTracks[i].getCapabilities()\r\n                mylog(caps)\r\n            }\r\n\r\n            // Assign the camera stream to the video element in the page\r\n            // Eventually, the event 'canPlay' will be fired signallig video is ready to be displayed\r\n            this.videoElement.current.setAttribute('autoplay', 'true');\r\n            this.videoElement.current.setAttribute('muted', 'true');\r\n            this.videoElement.current.setAttribute('playsinline', 'true');\r\n            this.videoElement.current.srcObject = stream\r\n            mylog(stream)\r\n\r\n        } catch (error) {\r\n            log.error(\"Error getting stream\", error)\r\n            window.MHR.gotoPage(\"ErrorPage\", {title: \"Error getting video stream\", msg: \"There was an error trying to start the camera.\"})\r\n            return\r\n        }\r\n\r\n    }\r\n\r\n    async selectCamera() {\r\n\r\n        // Try to use the camera explicitly configured by the user\r\n        var selectedCameraId = localStorage.getItem(\"selectedCamera\")\r\n        mylog(\"User selected camera:\", selectedCameraId)\r\n\r\n        // If nothing configured, try to use last one used, if any\r\n        if (!selectedCameraId) {\r\n            selectedCameraId = this.lastUsedCameraId\r\n            mylog(\"Last used camera:\", selectedCameraId)\r\n        }\r\n\r\n        // Some Android phones have a problem selecting automatically the best camera for scanning (eg. some Samsung)\r\n        // If we are in Android and this is the first time, try to select the most appropriate camera\r\n        // This will request permission from the user\r\n        if (!selectedCameraId && (\"Android\" == getPlatformOS())) {\r\n            mylog(\"We are in Andoid and this is the first time\")\r\n            let allVideoDevices;\r\n            try {\r\n                allVideoDevices = await getPreferredVideoDevice()\r\n                mylog(\"Video devices in Android:\", allVideoDevices)\r\n            } catch (error) {\r\n                log.error(\"Error requesting camera access\", error)\r\n            }\r\n            if (allVideoDevices && allVideoDevices.defaultPreferredCamera) {\r\n                selectedCameraId = allVideoDevices.defaultPreferredCamera.deviceId\r\n                mylog(\"Selected camera in Android:\", selectedCameraId)\r\n            }\r\n\r\n            if (!selectedCameraId) {\r\n                mylog(\"In Android and no selected camera\")\r\n            }\r\n\r\n        }\r\n\r\n        return selectedCameraId;\r\n\r\n    }\r\n\r\n    // canPlay is called when the video element is ready, so we can start detecting QR codes\r\n    async canPlay() {\r\n        mylog(\"Video can play, try to detect QR\")\r\n        // The video stream is ready, show the 'video' element\r\n        this.videoElement.current.style.display = \"block\"\r\n\r\n        // Start playing the video from the camera\r\n        this.videoElement.current.play()\r\n\r\n        // Start the detector of QR codes directly in the video element\r\n        this.detectCode()\r\n\r\n    }\r\n\r\n    // Detect code function \r\n    async detectCode() {\r\n\r\n        let qrType = QR_UNKNOWN\r\n        let qrData\r\n\r\n        // Detect QR codes in the video element\r\n        // We will try first the native detector if available (at this moment only on Android)\r\n        if (this.nativeBarcodeDetector) {\r\n            // Native BarcodeDetector is available\r\n\r\n            let codes\r\n            try {\r\n                codes = await this.nativeBarcodeDetector.detect(this.videoElement.current)\r\n            } catch (error) {\r\n                // Log an error if one happens\r\n                log.error(error);\r\n                return;\r\n            }\r\n    \r\n            // If not detected, try again\r\n            if (codes.length === 0) {\r\n                setTimeout(() => this.detectCode(), this.detectionInterval)\r\n                return;\r\n            }\r\n    \r\n            // There may be several QR codes detected\r\n            // We will process the first one that is recognized\r\n            for (const barcode of codes) {\r\n                // Log the barcode to the console\r\n                mylog(barcode)\r\n                qrData = barcode.rawValue\r\n                qrType = this.detectQRtype(qrData)\r\n                if (qrType != QR_UNKNOWN) {\r\n                    // Exit from the loop as soon as we recognize a QR type\r\n                    break;\r\n                }\r\n            }\r\n    \r\n        } else {\r\n            // Native support not available, use the JavaScript library\r\n\r\n            try {\r\n                const result = await this.zxingReader.decodeOnceFromVideoElement(this.videoElement.current);     \r\n                qrData = result.text\r\n                mylog(\"RESULT\", qrData)\r\n            } catch (error) {\r\n                log.error(\"ZXING decoding error\", error)\r\n            }\r\n            \r\n            qrType = this.detectQRtype(qrData)\r\n\r\n        }\r\n\r\n        mylog(`QRTYPE: ${qrType}`)\r\n\r\n        // If no QR code recognized, keep trying\r\n        if (qrType === QR_UNKNOWN) {\r\n            setTimeout(() => this.detectCode(), this.detectionInterval)\r\n            return;\r\n        }\r\n\r\n        // Handle a SIOP AuthenticationRequest QR\r\n        if (qrType === QR_SIOP_URL) {\r\n            mylog(\"Going to \", \"SIOPSelectCredential\", qrData)\r\n            window.MHR.gotoPage(\"SIOPSelectCredential\", qrData)\r\n            return true;\r\n        }\r\n\r\n        // Handle HCERT data\r\n        if (qrType === QR_HC1) {\r\n            mylog(\"Going to \", \"DisplayHcert\")\r\n            window.MHR.gotoPage(\"DisplayHcert\", qrData)\r\n            return true;\r\n        }\r\n\r\n        // Handle a normal QR code with a URL\r\n        if (qrType === QR_URL) {\r\n            mylog(\"Going to \", this.displayPage)\r\n            window.MHR.gotoPage(this.displayPage, qrData)\r\n            return true;\r\n        }\r\n\r\n        // We scanned a QR for VC Issuance (OIDC4VCI)\r\n        if (qrType === QR_OIDC4VCI) {\r\n            mylog(\"Going to \", \"LoadAndSaveQRVC\")\r\n            // Create a valid URL\r\n            qrData = qrData.replace(\"openid-credential-offer://\", \"https://\")\r\n            window.MHR.gotoPage(\"LoadAndSaveQRVC\", qrData)\r\n            return true;\r\n        }\r\n\r\n    }\r\n\r\n    async exit() {\r\n\r\n        if (!this.videoElement.current) {\r\n            return;\r\n        }\r\n\r\n        // Reset the decoder just in case the camera was still working\r\n        this.videoElement.current.style.display = \"none\"\r\n\r\n        // Release resources\r\n        if (this.videoElement.current.srcObject !== undefined) {\r\n            this.videoElement.current.srcObject.getVideoTracks().forEach((track) => {\r\n                track.stop();\r\n            });\r\n        }\r\n\r\n    }\r\n\r\n    // Try to detect the type of data received\r\n    detectQRtype(qrData) {\r\n\r\n        if (!qrData || !qrData.startsWith) {\r\n            log.error(\"detectQRtype: data is not string\")\r\n            return QR_UNKNOWN;\r\n        }\r\n\r\n        if (qrData.startsWith(\"HC1:\")) {\r\n            // An EU COVID Certificate\r\n            return QR_HC1;\r\n\r\n        } else if (qrData.startsWith(\"multi|w3cvc|\")) {\r\n            // A multi-piece JWT\r\n            return QR_MULTI;\r\n\r\n        } else if (qrData.startsWith(\"openid4vp:\")) {\r\n            // A SIOP Authentication Request, URL-encoded\r\n            return QR_SIOP_URL;\r\n\r\n        } else if (qrData.startsWith(\"openid-credential-offer://\")) {\r\n            // A SIOP OpenID for VC Issuance, URL-encoded\r\n            return QR_OIDC4VCI;\r\n\r\n        } else if (qrData.includes(\"credential_offer_uri=\")) {\r\n            return QR_OIDC4VCI\r\n            \r\n        } else if (qrData.startsWith(\"VC1:\")) {\r\n            // A Verifiable Credential in raw format\r\n            return QR_W3C_VC;\r\n\r\n        } else if (qrData.startsWith(\"https\")) {\r\n\r\n            let params = new URL(qrData).searchParams\r\n            let jar = params.get(\"jar\")\r\n            if (jar == \"yes\") {\r\n                return QR_SIOP_URL\r\n            }\r\n    \r\n            // Normal QR with a URL where the real data is located\r\n            // We require secure connections with https, and do not accept http schemas\r\n            return QR_URL;\r\n            \r\n        } else {\r\n            return QR_UNKNOWN\r\n        }\r\n    }\r\n\r\n})\r\n\r\n\r\n// This is the state object used by the background animation routine.\r\n// Its values are set by the QR scanning initialization routine\r\nvar qrScan = {\r\n    // The page that has invoked the scan\r\n    callerPage: \"\",\r\n\r\n    // The HTML element where the video frames will be placed for analysis\r\n    canvasElement: \"\",\r\n\r\n    // The canvas context with image data\r\n    canvas: \"\",\r\n\r\n    // The element in the page to display messages about status of scanning\r\n    progressMessages: \"\",\r\n\r\n    // The page where thee coded QR will be displayed\r\n    displayQRPage: \"\",\r\n\r\n    // Page that initiated the scanning\r\n    callerType: \"\",\r\n\r\n    // To build the whole JWT from the received pieces\r\n    receivedQRPieces: [],\r\n    receivedPieces: \"\",\r\n\r\n    // The HTML element where the video stream is going to be placed\r\n    video: \"\",\r\n\r\n    // The video stream object\r\n    myStream: \"\",\r\n};\r\n\r\n// Start the camera to scan the QR\r\n// The scan can be used either by the Passenger or the Verifier\r\nexport async function initiateReceiveQRScanning(\r\n    _canvasElement,\r\n    _qrMessageElement,\r\n    _displayQRPage,\r\n    _callerType\r\n) {\r\n    // _canvasElement: DOM element where the images will be displayed\r\n    // _qrMessageElement: DOM element to display info messages\r\n    // _displayQRPage: page to switch to display contents of the QR\r\n    // _callerType: who is calling, to customise the display of the QR\r\n\r\n\r\n    // Get the current page where scanning is started\r\n    var currentPage = \"\";\r\n    if (window.history.state != null) {\r\n        currentPage = window.history.state.pageName;\r\n    }\r\n    qrScan[\"callerPage\"] = currentPage;\r\n\r\n    // The HTML element where the video frames will be placed for analysis\r\n    qrScan[\"canvasElement\"] = _canvasElement;\r\n\r\n    // Save in global variable the element to display messages about progress of scanning\r\n    qrScan[\"progressMessages\"] = _qrMessageElement;\r\n\r\n    // Save the input parameters in global variables to keep state across timer ticks\r\n    qrScan[\"displayQRPage\"] = _displayQRPage;\r\n\r\n    // Save the input parameters in global variables to keep state across timer ticks\r\n    qrScan[\"callerType\"] = _callerType;\r\n\r\n    // Reset the variables holding the received pieces\r\n    qrScan[\"receivedQRPieces\"] = [];\r\n    qrScan[\"receivedPieces\"] = new Set();\r\n\r\n    // Get the canvas context with image data and store in global variable\r\n    qrScan[\"canvas\"] = qrScan[\"canvasElement\"].getContext(\"2d\");\r\n\r\n    // Create the HTML element to place the video stream and save in global variable\r\n    qrScan[\"video\"] = document.createElement(\"video\");\r\n    //  let elwidth = Math.min(screen.availWidth - 50, 450);\r\n    //  qrScan[\"video\"].style.width = document.querySelector(\"#passengerQRScanPage .container\").clientWidth + \"px\"\r\n\r\n    // Make sure that the canvas element is hidden for the moment\r\n    qrScan[\"canvasElement\"].hidden = true;\r\n\r\n    // Display a message while we have not detected anything\r\n    qrScan[\"progressMessages\"].innerText = \"Waiting for QR .........\";\r\n\r\n    // Request permission from user to get the video stream\r\n    // Use \"facingMode: environment\" to attempt to get the main camera on phones\r\n    navigator.mediaDevices\r\n        .getUserMedia({ video: { facingMode: \"environment\" } })\r\n        .then(function (stream) {\r\n            // Store the stream in global variable for later\r\n            qrScan[\"myStream\"] = stream;\r\n\r\n            // Connect the video stream to the \"video\" element in the page\r\n            qrScan[\"video\"].srcObject = stream;\r\n            qrScan[\"video\"].setAttribute(\"playsinline\", true); // required to tell iOS safari we don't want fullscreen\r\n            qrScan[\"video\"].play();\r\n\r\n            // Call the \"tick\" function on the next animation interval\r\n            //      setTimeout(ReceiveQRtick, scanRefreshInterval);\r\n            requestAnimationFrame(ReceiveQRtick);\r\n        });\r\n}\r\n\r\n// This function is called periodically until we get a result from the scan\r\n// We use global variables to know the context on which it was called\r\nasync function ReceiveQRtick() {\r\n    try {\r\n        // Load variables for easier referencing\r\n        var video = qrScan[\"video\"];\r\n        var canvas = qrScan[\"canvas\"];\r\n        var canvasElement = qrScan[\"canvasElement\"];\r\n        var receivedPieces = qrScan[\"receivedPieces\"];\r\n        var receivedQRPieces = qrScan[\"receivedQRPieces\"];\r\n        var progressMessages = qrScan[\"progressMessages\"];\r\n        var myStream = qrScan[\"myStream\"];\r\n        var callerType = qrScan[\"callerType\"];\r\n        var callerPage = qrScan[\"callerPage\"];\r\n        var displayQRPage = qrScan[\"displayQRPage\"];\r\n\r\n        var currentPage = \"\";\r\n        if (window.history.state != null) {\r\n            currentPage = window.history.state.pageName;\r\n        }\r\n        // Ckeck if we are running in the context of the page that initiated scanning\r\n        if (currentPage != callerPage) {\r\n            // The user navigated out of the scan page, should stop using the camera\r\n            stopMediaTracks(myStream);\r\n\r\n            // Return without activating the callback again, so it will stop completely\r\n            return;\r\n        }\r\n\r\n        // We have to wait until the video stream is ready\r\n        if (video.readyState !== video.HAVE_ENOUGH_DATA) {\r\n            // We are not yet ready\r\n\r\n            // Request to be called again in next frame\r\n            //      setTimeout(ReceiveQRtick, scanRefreshInterval);\r\n            requestAnimationFrame(ReceiveQRtick);\r\n\r\n            // Exit from the function until it will be called again\r\n            return;\r\n        }\r\n\r\n        // Video is ready, display canvas\r\n        canvasElement.hidden = false;\r\n\r\n        // Set the canvas size to match the video stream\r\n        canvasElement.height = video.videoHeight;\r\n        canvasElement.width = video.videoWidth;\r\n        //let elwidth = Math.min(screen.availWidth - 60, 350);\r\n        let displayWidth = video.videoWidth\r\n        let displayHeight = video.videoHeight\r\n\r\n        // Get a video frame and decode an image data using the canvas element\r\n        canvas.drawImage(video, 0, 0, displayWidth, displayHeight);\r\n        var imageData = canvas.getImageData(\r\n            0,\r\n            0,\r\n            displayWidth,\r\n            displayHeight\r\n        );\r\n\r\n        try {\r\n            // Try to decode the image as a QR code\r\n            var code = jsQR(imageData.data, imageData.width, imageData.height, {\r\n                inversionAttempts: \"dontInvert\",\r\n            });\r\n        } catch (error) {\r\n            console.error(\"jsQR:\", error)\r\n        }\r\n\r\n        // If unsuccessful, exit requesting to be called again at next animation frame\r\n        if (!code) {\r\n            // Request to be called again in next frame\r\n            //      setTimeout(ReceiveQRtick, scanRefreshInterval);\r\n            requestAnimationFrame(ReceiveQRtick);\r\n\r\n            // Exit from the function\r\n            return;\r\n        }\r\n\r\n        // If we reached up to here, we have a valid QR\r\n\r\n        // Try to detect the type of data received\r\n        var qrType = detectQRtype(code.data);\r\n        if (qrType == \"unknown\") {\r\n            // We do not know what type it is. Continue scanning\r\n\r\n            // Request to be called again in next frame\r\n            //      setTimeout(ReceiveQRtick, scanRefreshInterval);\r\n            requestAnimationFrame(ReceiveQRtick);\r\n\r\n            // Exit from the function\r\n            return;\r\n        }\r\n\r\n        if (qrType == \"MultiJWT\") {\r\n            mylog(\"Scanned MultiJWT QR\");\r\n            // We are going to receive a series of QRs and then join the pieces together\r\n            // Each piece has the format: \"xx|yy|data\" where\r\n            //   xx is the total number of pieces to receive, expressed as two decimal digits\r\n            //   yy is the index of this piece in the whole data, expressed as two decimal digits\r\n            //   data is the actual data of the piece\r\n\r\n            // Split the data in the QR in the components\r\n            var components = code.data.split(\"|\");\r\n\r\n            // The first and second components are \"multi\" and \"w3cvc\" and we do not need them\r\n\r\n            // The third component is the total number of pieces to receive\r\n            var total = components[2];\r\n\r\n            // The fourth is the index of the received component\r\n            var index = components[3];\r\n\r\n            // And the fifth is the actual piece of data\r\n            var piece = components[4];\r\n\r\n            // Check if we received two integers each with two digits, from \"00\" to \"99\"\r\n            // ASCII code for \"0\" is 48 and for \"9\" is 57\r\n            var total1 = total.charCodeAt(0);\r\n            var total2 = total.charCodeAt(1);\r\n            var index1 = index.charCodeAt(0);\r\n            var index2 = index.charCodeAt(1);\r\n            if (\r\n                total1 < 48 ||\r\n                total1 > 57 ||\r\n                total2 < 48 ||\r\n                total2 > 57 ||\r\n                index1 < 48 ||\r\n                index1 > 57 ||\r\n                index2 < 48 ||\r\n                index2 > 57\r\n            ) {\r\n                // Invalid data received, keep trying\r\n                // Request to be called again in next frame\r\n                //        setTimeout(ReceiveQRtick, scanRefreshInterval);\r\n                requestAnimationFrame(ReceiveQRtick);\r\n\r\n                // Exit from the function\r\n                return;\r\n            }\r\n\r\n            // Check if we already received this piece\r\n            if (receivedPieces.has(index)) {\r\n                // Already received, continue scanning\r\n\r\n                // Request to be called again in next frame\r\n                //        setTimeout(ReceiveQRtick, scanRefreshInterval);\r\n                requestAnimationFrame(ReceiveQRtick);\r\n\r\n                // Exit from the function\r\n                return;\r\n            }\r\n\r\n            // This is a new piece. Add it to the set\r\n            receivedPieces.add(index);\r\n            receivedQRPieces[+index] = piece; // Make sure that index is considered an integer and not a string\r\n\r\n            // Display in the page the number of the object received.\r\n            progressMessages.innerText = \"Received piece: \" + index;\r\n\r\n            // Check if we need more pieces\r\n            if (receivedPieces.size < total) {\r\n                // Continue scanning\r\n\r\n                // Request to be called again in next frame\r\n                //        setTimeout(ReceiveQRtick, scanRefreshInterval);\r\n                requestAnimationFrame(ReceiveQRtick);\r\n\r\n                // Exit from the function\r\n                return;\r\n            }\r\n\r\n            // We have received all pieces\r\n\r\n            // Stop the media stream\r\n            stopMediaTracks(myStream);\r\n\r\n            // Hide the picture\r\n            canvasElement.hidden = true;\r\n\r\n            mylog(\"Received all pieces\", receivedQRPieces);\r\n\r\n            // Assemble all pieces together\r\n            var jwt = receivedQRPieces.join(\"\");\r\n            mylog(\"Received jwt\", jwt);\r\n\r\n            // Extract the credential and save in the temporary storage\r\n            try {\r\n                var cred = decodeJWT(jwt);\r\n\r\n                // Store in temporal storage so the page will retrieve it\r\n                let currentCredential = {\r\n                    type: \"w3cvc\",\r\n                    encoded: jwt,\r\n                    decoded: cred,\r\n                };\r\n                mylog(\"Writing current cred: \", currentCredential);\r\n                await settingsPut(\"currentCredential\", currentCredential);\r\n            } catch (error) {\r\n                myerror(error);\r\n                progressMessages.innerText = error;\r\n                return;\r\n            }\r\n\r\n            // Switch to the presentation of results\r\n            window.MHR.gotoPage(displayQRPage, { screenType: callerType });\r\n\r\n            return;\r\n        }\r\n\r\n        if (qrType == \"URL\") {\r\n            // We received a URL in the QR. Perform a GET to obtain the JWT from a server\r\n            mylog(\"Scanned normal URL QR\");\r\n\r\n            // Stop the media stream\r\n            stopMediaTracks(myStream);\r\n\r\n            // Build the URL to call\r\n            let targetURLRead = code.data.trim();\r\n\r\n            // Check if the URL points to a JWT or to the wallet\r\n            if (targetURLRead.startsWith(MYSELF)) {\r\n                // The URL points to the wallet. We should have received a param with the credential id\r\n                const url = new URL(targetURLRead);\r\n\r\n                // First we check for a normal credential\r\n                let credId = url.searchParams.get(\"id\");\r\n                if (credId) {\r\n                    targetURLRead = ISSUER_GET_CREDENTIAL + credId;\r\n                } else {\r\n                    // Now check for a Public Credential\r\n                    credId = url.searchParams.get(\"pubid\");\r\n                    if (credId) {\r\n                        targetURLRead = ISSUER_GET_PUBLIC_CREDENTIAL + credId;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Retrieve the credential from the server and display it\r\n            await requestQRAndDisplay(targetURLRead, displayQRPage, callerType);\r\n\r\n            return;\r\n        }\r\n\r\n        const HC_ISS = 1;\r\n        const HC_IAT = 6;\r\n        const HC_EXP = 4;\r\n        const HC_CTI = 7;\r\n        const HC_HCERT = -260;\r\n\r\n        if (qrType == \"HC1\") {\r\n            // We received a Health Certificate (HC) version 1 encoded QR.\r\n            mylog(\"Scanned HC1 QR\");\r\n\r\n            let plain = await CWT.decodeHC1QR(code.data);\r\n            mylog(\"CWT.decodeHC1QR\", plain)\r\n\r\n            // Store in temporal storage so the page will retrieve it\r\n            let currentCredential = {\r\n                type: \"hcert\",\r\n                encoded: code.data,\r\n                decoded: plain,\r\n            };\r\n            await settingsPut(\"currentCredential\", currentCredential);\r\n\r\n            // Stop the media stream\r\n            stopMediaTracks(myStream);\r\n\r\n            // Switch to the presentation of results\r\n            window.MHR.gotoPage(displayQRPage, { screenType: callerType });\r\n\r\n            return;\r\n        }\r\n\r\n        if (qrType == \"Base64\") {\r\n            // We received a Base64 encoded QR. May be it is the UK Immigration document\r\n            mylog(\"Scanned Base64 simple QR\");\r\n\r\n            let decodedQR = JSON.parse(atobUrl(code.data));\r\n\r\n            // Store in temporal storage so the page will retrieve it\r\n            let currentCredential = {\r\n                type: \"ukimmigration\",\r\n                encoded: code.data,\r\n                decoded: decodedQR,\r\n            };\r\n            await settingsPut.setItem(\"currentCredential\", currentCredential);\r\n\r\n            // Stop the media stream\r\n            stopMediaTracks(myStream);\r\n\r\n            // Switch to the presentation of results\r\n            window.MHR.gotoPage(displayQRPage, { screenType: callerType });\r\n\r\n            return;\r\n        }\r\n    } catch (error) {\r\n\r\n        // Stop the media stream\r\n        stopMediaTracks(myStream);\r\n\r\n        console.error(error)\r\n        alert(`Error: ${error}`)\r\n\r\n        // Go to the home page to start again\r\n        window.MHR.gotoPage(homePage);\r\n\r\n        // Exit from the function\r\n        return;\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
